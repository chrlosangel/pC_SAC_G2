!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AllocPoolIterator	octree.h	/^    typedef typename DynamicAllocator< OcTreeNode< CoordType, ValueType > >::PoolIterator AllocPoolIterator;$/;"	t	class:spatialaggregate::OcTreeNodeDynamicAllocator	access:public
Allocate	XYMatrix.h	/^    void Allocate (bool bSetToZero);$/;"	p	class:CXYMatrix	access:private	signature:(bool bSetToZero)
Allocate	XYMatrix.inl	/^void CXYMatrix<Real>::Allocate (bool bSetToZero)$/;"	f	class:CXYMatrix	signature:(bool bSetToZero)
AlmostEqual2sComplement	XYMath.h	/^	static bool AlmostEqual2sComplement(float A, float B, int maxUlps);$/;"	p	class:CXYMath	access:public	signature:(float A, float B, int maxUlps)
AlmostEqual2sComplement	XYMath.inl	/^bool CXYMath<Real>::AlmostEqual2sComplement(float A, float B, int maxUlps)$/;"	f	class:CXYMath	signature:(float A, float B, int maxUlps)
Avg	XYVector.h	/^	Real Avg() const;$/;"	p	class:CXYVector	access:public	signature:() const
Avg	XYVector.inl	/^Real CXYVector<Real>::Avg () const$/;"	f	class:CXYVector	signature:() const
BaseName	XYUtility.cpp	/^char* CXYUtility::BaseName(char *name, int with_suffix)$/;"	f	class:CXYUtility	signature:(char *name, int with_suffix)
BaseName	XYUtility.h	/^	static char *BaseName(char *name, int with_suffix);$/;"	p	class:CXYUtility	access:public	signature:(char *name, int with_suffix)
BinSearchConstC	XYSIS.cpp	/^float CXYSIS::BinSearchConstC(vector<float>& vfBeta_t)$/;"	f	class:CXYSIS	signature:(vector<float>& vfBeta_t)
BinSearchConstC	XYSIS.h	/^  float BinSearchConstC(vector<float>& vfBeta_t);$/;"	p	class:CXYSIS	access:public	signature:(vector<float>& vfBeta_t)
CONFIGFILE_H	ConfigFile.h	44;"	d
CXYEigen	XYEigen.cpp	/^CXYEigen<Real>::CXYEigen (const CXYMatrix<Real>& rkM)$/;"	f	class:CXYEigen	signature:(const CXYMatrix<Real>& rkM)
CXYEigen	XYEigen.cpp	/^CXYEigen<Real>::CXYEigen (int iSize)$/;"	f	class:CXYEigen	signature:(int iSize)
CXYEigen	XYEigen.cpp	/^template class CXYEigen<double>;$/;"	x	file:
CXYEigen	XYEigen.cpp	/^template class CXYEigen<float>;$/;"	x	file:
CXYEigen	XYEigen.h	/^	CXYEigen (const CXYMatrix<Real>& rkM);$/;"	p	class:CXYEigen	access:public	signature:(const CXYMatrix<Real>& rkM)
CXYEigen	XYEigen.h	/^	CXYEigen(int iSize);$/;"	p	class:CXYEigen	access:public	signature:(int iSize)
CXYEigen	XYEigen.h	/^class CXYEigen{$/;"	c
CXYEigen::CXYEigen	XYEigen.cpp	/^CXYEigen<Real>::CXYEigen (const CXYMatrix<Real>& rkM)$/;"	f	class:CXYEigen	signature:(const CXYMatrix<Real>& rkM)
CXYEigen::CXYEigen	XYEigen.cpp	/^CXYEigen<Real>::CXYEigen (int iSize)$/;"	f	class:CXYEigen	signature:(int iSize)
CXYEigen::CXYEigen	XYEigen.h	/^	CXYEigen (const CXYMatrix<Real>& rkM);$/;"	p	class:CXYEigen	access:public	signature:(const CXYMatrix<Real>& rkM)
CXYEigen::CXYEigen	XYEigen.h	/^	CXYEigen(int iSize);$/;"	p	class:CXYEigen	access:public	signature:(int iSize)
CXYEigen::DecrSortEigenStuffN	XYEigen.cpp	/^void CXYEigen<Real>::DecrSortEigenStuffN ()$/;"	f	class:CXYEigen	signature:()
CXYEigen::DecrSortEigenStuffN	XYEigen.h	/^    void DecrSortEigenStuffN ();$/;"	p	class:CXYEigen	access:public	signature:()
CXYEigen::DecreasingSort	XYEigen.cpp	/^void CXYEigen<Real>::DecreasingSort ()$/;"	f	class:CXYEigen	signature:()
CXYEigen::DecreasingSort	XYEigen.h	/^    void DecreasingSort ();$/;"	p	class:CXYEigen	access:private	signature:()
CXYEigen::EigenStuffN	XYEigen.cpp	/^void CXYEigen<Real>::EigenStuffN ()$/;"	f	class:CXYEigen	signature:()
CXYEigen::EigenStuffN	XYEigen.h	/^    void EigenStuffN ();$/;"	p	class:CXYEigen	access:public	signature:()
CXYEigen::GetEigenvalue	XYEigen.cpp	/^Real CXYEigen<Real>::GetEigenvalue (int i) const$/;"	f	class:CXYEigen	signature:(int i) const
CXYEigen::GetEigenvalue	XYEigen.h	/^    Real GetEigenvalue (int i) const;$/;"	p	class:CXYEigen	access:public	signature:(int i) const
CXYEigen::GetEigenvalues	XYEigen.cpp	/^const Real* CXYEigen<Real>::GetEigenvalues () const$/;"	f	class:CXYEigen	signature:() const
CXYEigen::GetEigenvalues	XYEigen.h	/^    const Real* GetEigenvalues () const;$/;"	p	class:CXYEigen	access:public	signature:() const
CXYEigen::GetEigenvector	XYEigen.cpp	/^CXYVector<Real> CXYEigen<Real>::GetEigenvector (int i) const$/;"	f	class:CXYEigen	signature:(int i) const
CXYEigen::GetEigenvector	XYEigen.h	/^    CXYVector<Real> GetEigenvector (int i) const;$/;"	p	class:CXYEigen	access:public	signature:(int i) const
CXYEigen::GetEigenvectors	XYEigen.cpp	/^const CXYMatrix<Real>& CXYEigen<Real>::GetEigenvectors () const$/;"	f	class:CXYEigen	signature:() const
CXYEigen::GetEigenvectors	XYEigen.h	/^    const CXYMatrix<Real>& GetEigenvectors () const;$/;"	p	class:CXYEigen	access:public	signature:() const
CXYEigen::GuaranteeRotation	XYEigen.cpp	/^void CXYEigen<Real>::GuaranteeRotation ()$/;"	f	class:CXYEigen	signature:()
CXYEigen::GuaranteeRotation	XYEigen.h	/^    void GuaranteeRotation ();$/;"	p	class:CXYEigen	access:private	signature:()
CXYEigen::IncrSortEigenStuffN	XYEigen.cpp	/^void CXYEigen<Real>::IncrSortEigenStuffN ()$/;"	f	class:CXYEigen	signature:()
CXYEigen::IncrSortEigenStuffN	XYEigen.h	/^    void IncrSortEigenStuffN ();$/;"	p	class:CXYEigen	access:public	signature:()
CXYEigen::IncreasingSort	XYEigen.cpp	/^void CXYEigen<Real>::IncreasingSort ()$/;"	f	class:CXYEigen	signature:()
CXYEigen::IncreasingSort	XYEigen.h	/^    void IncreasingSort ();$/;"	p	class:CXYEigen	access:private	signature:()
CXYEigen::QLAlgorithm	XYEigen.cpp	/^bool CXYEigen<Real>::QLAlgorithm ()$/;"	f	class:CXYEigen	signature:()
CXYEigen::QLAlgorithm	XYEigen.h	/^    bool QLAlgorithm ();$/;"	p	class:CXYEigen	access:private	signature:()
CXYEigen::TridiagonalN	XYEigen.cpp	/^void CXYEigen<Real>::TridiagonalN ()$/;"	f	class:CXYEigen	signature:()
CXYEigen::TridiagonalN	XYEigen.h	/^    void TridiagonalN ();$/;"	p	class:CXYEigen	access:private	signature:()
CXYEigen::m_afDiag	XYEigen.h	/^    Real* m_afDiag;$/;"	m	class:CXYEigen	access:private
CXYEigen::m_afSubd	XYEigen.h	/^    Real* m_afSubd;$/;"	m	class:CXYEigen	access:private
CXYEigen::m_bIsRotation	XYEigen.h	/^    bool m_bIsRotation;$/;"	m	class:CXYEigen	access:private
CXYEigen::m_iSize	XYEigen.h	/^    int m_iSize;$/;"	m	class:CXYEigen	access:private
CXYEigen::m_kMat	XYEigen.h	/^    CXYMatrix<Real> m_kMat;$/;"	m	class:CXYEigen	access:private
CXYEigen::operator ()	XYEigen.cpp	/^Real& CXYEigen<Real>::operator() (int iRow, int iCol)$/;"	f	class:CXYEigen	signature:(int iRow, int iCol)
CXYEigen::operator ()	XYEigen.h	/^    Real& operator() (int iRow, int iCol);$/;"	p	class:CXYEigen	access:public	signature:(int iRow, int iCol)
CXYEigen::operator =	XYEigen.cpp	/^CXYEigen<Real>& CXYEigen<Real>::operator= (const CXYMatrix<Real>& rkM)$/;"	f	class:CXYEigen	signature:(const CXYMatrix<Real>& rkM)
CXYEigen::operator =	XYEigen.h	/^    CXYEigen& operator= (const CXYMatrix<Real>& rkM);$/;"	p	class:CXYEigen	access:public	signature:(const CXYMatrix<Real>& rkM)
CXYEigen::~CXYEigen	XYEigen.cpp	/^CXYEigen<Real>::~CXYEigen ()$/;"	f	class:CXYEigen	signature:()
CXYEigen::~CXYEigen	XYEigen.h	/^	~CXYEigen(void);$/;"	p	class:CXYEigen	access:public	signature:(void)
CXYEnsemble	XYEnsemble.cpp	/^CXYEnsemble::CXYEnsemble($/;"	f	class:CXYEnsemble	signature:( char* cOutPath, float fPersistenLength, float fCollisionLength, float fPackingDensity, float fNucleusSphereDiameter, int iNumNodes, int iNumSamplePoints, char* cStartEndFile, char* cSegLenFile, char* cContIndFile)
CXYEnsemble	XYEnsemble.cpp	/^CXYEnsemble::CXYEnsemble()$/;"	f	class:CXYEnsemble	signature:()
CXYEnsemble	XYEnsemble.h	/^	CXYEnsemble($/;"	p	class:CXYEnsemble	access:public	signature:( char* cOutPath, float fPersistenLength, float fCollisionLength, float fPackingDensity, float fNucleusSphereDiameter, int iNumNodes, int iNumSamplePoints, char* cStartEndFile, char* cSegLenFile, char* cContIndFile)
CXYEnsemble	XYEnsemble.h	/^	CXYEnsemble();$/;"	p	class:CXYEnsemble	access:public	signature:()
CXYEnsemble	XYEnsemble.h	/^class CXYEnsemble{$/;"	c
CXYEnsemble::CXYEnsemble	XYEnsemble.cpp	/^CXYEnsemble::CXYEnsemble($/;"	f	class:CXYEnsemble	signature:( char* cOutPath, float fPersistenLength, float fCollisionLength, float fPackingDensity, float fNucleusSphereDiameter, int iNumNodes, int iNumSamplePoints, char* cStartEndFile, char* cSegLenFile, char* cContIndFile)
CXYEnsemble::CXYEnsemble	XYEnsemble.cpp	/^CXYEnsemble::CXYEnsemble()$/;"	f	class:CXYEnsemble	signature:()
CXYEnsemble::CXYEnsemble	XYEnsemble.h	/^	CXYEnsemble($/;"	p	class:CXYEnsemble	access:public	signature:( char* cOutPath, float fPersistenLength, float fCollisionLength, float fPackingDensity, float fNucleusSphereDiameter, int iNumNodes, int iNumSamplePoints, char* cStartEndFile, char* cSegLenFile, char* cContIndFile)
CXYEnsemble::CXYEnsemble	XYEnsemble.h	/^	CXYEnsemble();$/;"	p	class:CXYEnsemble	access:public	signature:()
CXYEnsemble::GetBendingAngleBeg	XYEnsemble.h	/^	float GetBendingAngleBeg(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
CXYEnsemble::GetBendingAngleEnd	XYEnsemble.h	/^	float GetBendingAngleEnd(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
CXYEnsemble::GetCollisionLength	XYEnsemble.cpp	/^float CXYEnsemble::GetCollisionLength(void)$/;"	f	class:CXYEnsemble	signature:(void)
CXYEnsemble::GetCollisionLength	XYEnsemble.h	/^	float GetCollisionLength(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
CXYEnsemble::GetGoodPoints	XYEnsemble.cpp	/^void CXYEnsemble::GetGoodPoints( CXYVector<float>& prvnode, CXYMatrix<float>& kMSamplesPoints,vector<int>& GoodPointInd, vector<int>& NoCollisionPointInd){$/;"	f	class:CXYEnsemble	signature:( CXYVector<float>& prvnode, CXYMatrix<float>& kMSamplesPoints,vector<int>& GoodPointInd, vector<int>& NoCollisionPointInd)
CXYEnsemble::GetGoodPoints	XYEnsemble.h	/^  void GetGoodPoints( CXYVector<float>& prvnode, CXYMatrix<float>& kMSamplesPoints,vector<int>& GoodPointInd, vector<int>& NoCollisionPointInd);$/;"	p	class:CXYEnsemble	access:public	signature:( CXYVector<float>& prvnode, CXYMatrix<float>& kMSamplesPoints,vector<int>& GoodPointInd, vector<int>& NoCollisionPointInd)
CXYEnsemble::GetMiddlePoints	XYEnsemble.cpp	/^void CXYEnsemble::GetMiddlePoints(CXYVector<float>& StartPoint, CXYVector<float>& EndPoint, CXYMatrix<float> & MiddleEndPoints){$/;"	f	class:CXYEnsemble	signature:(CXYVector<float>& StartPoint, CXYVector<float>& EndPoint, CXYMatrix<float> & MiddleEndPoints)
CXYEnsemble::GetMiddlePoints	XYEnsemble.h	/^  void GetMiddlePoints(CXYVector<float>& StartPoint, CXYVector<float>& EndPoint, CXYMatrix<float> & MiddleEndPoints);$/;"	p	class:CXYEnsemble	access:public	signature:(CXYVector<float>& StartPoint, CXYVector<float>& EndPoint, CXYMatrix<float> & MiddleEndPoints)
CXYEnsemble::GetNodeSamples	XYEnsemble.h	/^	CXYMatrix<float> GetNodeSamples(tree<CXYVector<float> >::iterator  &itNode, int iSegInd);$/;"	p	class:CXYEnsemble	access:public	signature:(tree<CXYVector<float> >::iterator &itNode, int iSegInd)
CXYEnsemble::GetNucleusSphereDiameter	XYEnsemble.cpp	/^float CXYEnsemble::GetNucleusSphereDiameter(void)$/;"	f	class:CXYEnsemble	signature:(void)
CXYEnsemble::GetNucleusSphereDiameter	XYEnsemble.h	/^	float GetNucleusSphereDiameter(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
CXYEnsemble::GetNumBendingAngle	XYEnsemble.h	/^	int GetNumBendingAngle(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
CXYEnsemble::GetNumNodes	XYEnsemble.cpp	/^int CXYEnsemble::GetNumNodes(void){$/;"	f	class:CXYEnsemble	signature:(void)
CXYEnsemble::GetNumNodes	XYEnsemble.h	/^	int GetNumNodes(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
CXYEnsemble::GetNumTorsionAngle	XYEnsemble.h	/^	int GetNumTorsionAngle(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
CXYEnsemble::GetOutPath	XYEnsemble.cpp	/^char* CXYEnsemble::GetOutPath(void)$/;"	f	class:CXYEnsemble	signature:(void)
CXYEnsemble::GetOutPath	XYEnsemble.h	/^	char* GetOutPath(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
CXYEnsemble::GetPackingDensity	XYEnsemble.cpp	/^float CXYEnsemble::GetPackingDensity(void)$/;"	f	class:CXYEnsemble	signature:(void)
CXYEnsemble::GetPackingDensity	XYEnsemble.h	/^	float GetPackingDensity(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
CXYEnsemble::GetPersistenceLength	XYEnsemble.cpp	/^float CXYEnsemble::GetPersistenceLength(void)$/;"	f	class:CXYEnsemble	signature:(void)
CXYEnsemble::GetPersistenceLength	XYEnsemble.h	/^	float GetPersistenceLength(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
CXYEnsemble::GetRotMatrix	XYEnsemble.h	/^	CXYMatrix<float> GetRotMatrix(CXYMatrix<float> &rkMXYZ);$/;"	p	class:CXYEnsemble	access:public	signature:(CXYMatrix<float> &rkMXYZ)
CXYEnsemble::GetSamplesOrg	XYEnsemble.cpp	/^CXYMatrix<float> CXYEnsemble::GetSamplesOrg()$/;"	f	class:CXYEnsemble	signature:()
CXYEnsemble::GetSamplesOrg	XYEnsemble.h	/^	CXYMatrix<float> GetSamplesOrg();$/;"	p	class:CXYEnsemble	access:public	signature:()
CXYEnsemble::GetSegLength	XYEnsemble.cpp	/^float CXYEnsemble::GetSegLength(int ind){$/;"	f	class:CXYEnsemble	signature:(int ind)
CXYEnsemble::GetSegLength	XYEnsemble.h	/^	float GetSegLength(int ind);$/;"	p	class:CXYEnsemble	access:public	signature:(int ind)
CXYEnsemble::GetSegLengths	XYEnsemble.cpp	/^vector<float> & CXYEnsemble::GetSegLengths(void){$/;"	f	class:CXYEnsemble	signature:(void)
CXYEnsemble::GetSegLengths	XYEnsemble.h	/^	vector<float> & GetSegLengths(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
CXYEnsemble::GetTorsionAngleBeg	XYEnsemble.h	/^	float GetTorsionAngleBeg(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
CXYEnsemble::GetTorsionAngleEnd	XYEnsemble.h	/^	float GetTorsionAngleEnd(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
CXYEnsemble::GetTree	XYEnsemble.cpp	/^tree< CXYVector<float> >* CXYEnsemble::GetTree()$/;"	f	class:CXYEnsemble	signature:()
CXYEnsemble::GetTree	XYEnsemble.h	/^	tree< CXYVector<float> >* GetTree();$/;"	p	class:CXYEnsemble	access:public	signature:()
CXYEnsemble::GrowOneChain	XYEnsemble.cpp	/^bool CXYEnsemble::GrowOneChain()$/;"	f	class:CXYEnsemble	signature:()
CXYEnsemble::GrowOneChain	XYEnsemble.h	/^	bool GrowOneChain();$/;"	p	class:CXYEnsemble	access:public	signature:()
CXYEnsemble::InitializeChain	XYEnsemble.cpp	/^void CXYEnsemble::InitializeChain()$/;"	f	class:CXYEnsemble	signature:()
CXYEnsemble::InitializeChain	XYEnsemble.h	/^	void InitializeChain();$/;"	p	class:CXYEnsemble	access:public	signature:()
CXYEnsemble::IsCollision	XYEnsemble.cpp	/^bool CXYEnsemble::IsCollision(CXYMatrix<float> & MiddleEndPoints){$/;"	f	class:CXYEnsemble	signature:(CXYMatrix<float> & MiddleEndPoints)
CXYEnsemble::IsCollision	XYEnsemble.cpp	/^bool CXYEnsemble::IsCollision(CXYVector<float> kV_point)$/;"	f	class:CXYEnsemble	signature:(CXYVector<float> kV_point)
CXYEnsemble::IsCollision	XYEnsemble.h	/^	bool IsCollision(CXYVector<float> kV_point);$/;"	p	class:CXYEnsemble	access:public	signature:(CXYVector<float> kV_point)
CXYEnsemble::IsCollision	XYEnsemble.h	/^  bool IsCollision(CXYMatrix<float> & MiddleEndPoints);$/;"	p	class:CXYEnsemble	access:public	signature:(CXYMatrix<float> & MiddleEndPoints)
CXYEnsemble::IsInsideSphere	XYEnsemble.cpp	/^bool CXYEnsemble::IsInsideSphere(CXYVector<float> kV_point)$/;"	f	class:CXYEnsemble	signature:(CXYVector<float> kV_point)
CXYEnsemble::IsInsideSphere	XYEnsemble.cpp	/^bool CXYEnsemble::IsInsideSphere(float* fCoord)$/;"	f	class:CXYEnsemble	signature:(float* fCoord)
CXYEnsemble::IsInsideSphere	XYEnsemble.h	/^	bool IsInsideSphere(CXYVector<float> kV_point);$/;"	p	class:CXYEnsemble	access:public	signature:(CXYVector<float> kV_point)
CXYEnsemble::IsInsideSphere	XYEnsemble.h	/^	bool IsInsideSphere(float* fCoord);$/;"	p	class:CXYEnsemble	access:public	signature:(float* fCoord)
CXYEnsemble::IsSatisfyCondition	XYEnsemble.cpp	/^bool CXYEnsemble::IsSatisfyCondition(CXYMatrix<float> & MiddleEndPoints){$/;"	f	class:CXYEnsemble	signature:(CXYMatrix<float> & MiddleEndPoints)
CXYEnsemble::IsSatisfyCondition	XYEnsemble.h	/^  bool IsSatisfyCondition(CXYMatrix<float> & MiddleEndPoints);$/;"	p	class:CXYEnsemble	access:public	signature:(CXYMatrix<float> & MiddleEndPoints)
CXYEnsemble::NewXYZ	XYEnsemble.h	/^	CXYMatrix<float> NewXYZ(CXYVector<float> kV_0, CXYVector<float> kV_1, CXYVector<float> kV_2);$/;"	p	class:CXYEnsemble	access:public	signature:(CXYVector<float> kV_0, CXYVector<float> kV_1, CXYVector<float> kV_2)
CXYEnsemble::NewXYZ	XYEnsemble.h	/^	CXYMatrix<float> NewXYZ(CXYVector<float> kV_1, CXYVector<float> kV_2);$/;"	p	class:CXYEnsemble	access:public	signature:(CXYVector<float> kV_1, CXYVector<float> kV_2)
CXYEnsemble::RndSetStartPoint	XYEnsemble.cpp	/^CXYVector<float> CXYEnsemble::RndSetStartPoint(void)$/;"	f	class:CXYEnsemble	signature:(void)
CXYEnsemble::RndSetStartPoint	XYEnsemble.h	/^	CXYVector<float> RndSetStartPoint(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
CXYEnsemble::SetBendingAngleBeg	XYEnsemble.h	/^	void SetBendingAngleBeg(float fAng);$/;"	p	class:CXYEnsemble	access:public	signature:(float fAng)
CXYEnsemble::SetBendingAngleEnd	XYEnsemble.h	/^	void SetBendingAngleEnd(float fAng);$/;"	p	class:CXYEnsemble	access:public	signature:(float fAng)
CXYEnsemble::SetCollisionLength	XYEnsemble.cpp	/^void CXYEnsemble::SetCollisionLength(float fCollision)$/;"	f	class:CXYEnsemble	signature:(float fCollision)
CXYEnsemble::SetCollisionLength	XYEnsemble.h	/^	void SetCollisionLength(float fCollision);$/;"	p	class:CXYEnsemble	access:public	signature:(float fCollision)
CXYEnsemble::SetContIndex	XYEnsemble.cpp	/^void CXYEnsemble::SetContIndex(char* cContIndFile){$/;"	f	class:CXYEnsemble	signature:(char* cContIndFile)
CXYEnsemble::SetContIndex	XYEnsemble.cpp	/^void CXYEnsemble::SetContIndex(void){$/;"	f	class:CXYEnsemble	signature:(void)
CXYEnsemble::SetContIndex	XYEnsemble.h	/^	void SetContIndex(char* cContIndFile);$/;"	p	class:CXYEnsemble	access:public	signature:(char* cContIndFile)
CXYEnsemble::SetContIndex	XYEnsemble.h	/^  void SetContIndex(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
CXYEnsemble::SetNucleusSphereDiameter	XYEnsemble.cpp	/^void CXYEnsemble::SetNucleusSphereDiameter(float fNucleusSphereDiameter)$/;"	f	class:CXYEnsemble	signature:(float fNucleusSphereDiameter)
CXYEnsemble::SetNucleusSphereDiameter	XYEnsemble.h	/^	void SetNucleusSphereDiameter(float fNucleusSphereDiameter);$/;"	p	class:CXYEnsemble	access:public	signature:(float fNucleusSphereDiameter)
CXYEnsemble::SetNumBendingAngle	XYEnsemble.h	/^	void SetNumBendingAngle(int iNum);$/;"	p	class:CXYEnsemble	access:public	signature:(int iNum)
CXYEnsemble::SetNumNodes	XYEnsemble.cpp	/^void CXYEnsemble::SetNumNodes(int iNumNodes){$/;"	f	class:CXYEnsemble	signature:(int iNumNodes)
CXYEnsemble::SetNumNodes	XYEnsemble.h	/^	void SetNumNodes(int iNumNodes);$/;"	p	class:CXYEnsemble	access:public	signature:(int iNumNodes)
CXYEnsemble::SetNumTorsionAngle	XYEnsemble.h	/^	void SetNumTorsionAngle(int iNum);$/;"	p	class:CXYEnsemble	access:public	signature:(int iNum)
CXYEnsemble::SetOutPath	XYEnsemble.cpp	/^void CXYEnsemble::SetOutPath(char* cPathName)$/;"	f	class:CXYEnsemble	signature:(char* cPathName)
CXYEnsemble::SetOutPath	XYEnsemble.h	/^	void SetOutPath(char* cPathName);$/;"	p	class:CXYEnsemble	access:public	signature:(char* cPathName)
CXYEnsemble::SetPackingDensity	XYEnsemble.cpp	/^void CXYEnsemble::SetPackingDensity(float fPackingDensity)$/;"	f	class:CXYEnsemble	signature:(float fPackingDensity)
CXYEnsemble::SetPackingDensity	XYEnsemble.h	/^	void SetPackingDensity(float fPackingDensity);$/;"	p	class:CXYEnsemble	access:public	signature:(float fPackingDensity)
CXYEnsemble::SetPersistenceLength	XYEnsemble.cpp	/^void CXYEnsemble::SetPersistenceLength(float fPL)$/;"	f	class:CXYEnsemble	signature:(float fPL)
CXYEnsemble::SetPersistenceLength	XYEnsemble.h	/^	void SetPersistenceLength(float fPL);$/;"	p	class:CXYEnsemble	access:public	signature:(float fPL)
CXYEnsemble::SetSamplesOrg	XYEnsemble.cpp	/^void CXYEnsemble::SetSamplesOrg(void)$/;"	f	class:CXYEnsemble	signature:(void)
CXYEnsemble::SetSamplesOrg	XYEnsemble.h	/^	void SetSamplesOrg();$/;"	p	class:CXYEnsemble	access:public	signature:()
CXYEnsemble::SetSegLengths	XYEnsemble.cpp	/^void CXYEnsemble::SetSegLengths(char* cStartEndFile,const char* cMethod){$/;"	f	class:CXYEnsemble	signature:(char* cStartEndFile,const char* cMethod)
CXYEnsemble::SetSegLengths	XYEnsemble.cpp	/^void CXYEnsemble::SetSegLengths(void){$/;"	f	class:CXYEnsemble	signature:(void)
CXYEnsemble::SetSegLengths	XYEnsemble.h	/^	void SetSegLengths(char* cStartEndFile,const char* cMethod);$/;"	p	class:CXYEnsemble	access:public	signature:(char* cStartEndFile,const char* cMethod)
CXYEnsemble::SetSegLengths	XYEnsemble.h	/^	void SetSegLengths(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
CXYEnsemble::SetTorsionAngleBeg	XYEnsemble.h	/^	void SetTorsionAngleBeg(float fAng);$/;"	p	class:CXYEnsemble	access:public	signature:(float fAng)
CXYEnsemble::SetTorsionAngleEnd	XYEnsemble.h	/^	void SetTorsionAngleEnd(float fAng);$/;"	p	class:CXYEnsemble	access:public	signature:(float fAng)
CXYEnsemble::WriteChain	XYEnsemble.cpp	/^void CXYEnsemble::WriteChain(char* fn)$/;"	f	class:CXYEnsemble	signature:(char* fn)
CXYEnsemble::WriteChain	XYEnsemble.h	/^	void WriteChain(char* fn);$/;"	p	class:CXYEnsemble	access:public	signature:(char* fn)
CXYEnsemble::WriteContactDistance	XYEnsemble.cpp	/^void CXYEnsemble::WriteContactDistance(char* fn)$/;"	f	class:CXYEnsemble	signature:(char* fn)
CXYEnsemble::WriteContactDistance	XYEnsemble.h	/^  void WriteContactDistance(char* fn);$/;"	p	class:CXYEnsemble	access:public	signature:(char* fn)
CXYEnsemble::WriteDistance	XYEnsemble.cpp	/^void CXYEnsemble::WriteDistance(char* fn)$/;"	f	class:CXYEnsemble	signature:(char* fn)
CXYEnsemble::WriteDistance	XYEnsemble.h	/^	void WriteDistance(char* fn);	$/;"	p	class:CXYEnsemble	access:public	signature:(char* fn)
CXYEnsemble::WriteWeight	XYEnsemble.cpp	/^void CXYEnsemble::WriteWeight(char* fn)$/;"	f	class:CXYEnsemble	signature:(char* fn)
CXYEnsemble::WriteWeight	XYEnsemble.h	/^  void WriteWeight(char* fn);$/;"	p	class:CXYEnsemble	access:public	signature:(char* fn)
CXYEnsemble::m_LogWeight	XYEnsemble.h	/^  double m_LogWeight;$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_MContInd	XYEnsemble.h	/^	CXYMatrix<float> m_MContInd; \/\/ vector of contact index$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_cOutPath	XYEnsemble.h	/^	char* m_cOutPath;$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_center	XYEnsemble.h	/^  Eigen::Matrix< float, 4, 1 > m_center;$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_dr	XYEnsemble.h	/^  float m_dr;$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_fBendingAngleBeg	XYEnsemble.h	/^	float m_fBendingAngleBeg; \/\/ binding angle begin$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_fBendingAngleEnd	XYEnsemble.h	/^	float m_fBendingAngleEnd; \/\/ binding angle end$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_fCollisionLength	XYEnsemble.h	/^	float m_fCollisionLength;   \/\/ collision length$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_fNucleusSphereDiameter	XYEnsemble.h	/^	float m_fNucleusSphereDiameter; $/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_fPackingDensity	XYEnsemble.h	/^	float m_fPackingDensity;   \/\/ packing density$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_fPersistenceLength	XYEnsemble.h	/^	float m_fPersistenceLength; \/\/ persistence length$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_fTorsionAngleBeg	XYEnsemble.h	/^	float m_fTorsionAngleBeg;	\/\/ torsion angle begin$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_fTorsionAngleEnd	XYEnsemble.h	/^	float m_fTorsionAngleEnd;	\/\/ torsion angle end$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_iNumBendingAngle	XYEnsemble.h	/^	int   m_iNumBendingAngle; 	\/\/ number of binding angle$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_iNumMiddleEndPoints	XYEnsemble.h	/^  int m_iNumMiddleEndPoints;$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_iNumNodes	XYEnsemble.h	/^	int   m_iNumNodes;$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_iNumSamplePoints	XYEnsemble.h	/^	int   m_iNumSamplePoints;$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_iNumTorsionAngle	XYEnsemble.h	/^	int   m_iNumTorsionAngle; 	\/\/ number of torsion angle$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_maxDepth	XYEnsemble.h	/^  int m_maxDepth;$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_minimumVolumeSize	XYEnsemble.h	/^  float m_minimumVolumeSize;$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_pMSamplesOrg	XYEnsemble.h	/^	CXYMatrix<float>* m_pMSamplesOrg;$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_pOctree	XYEnsemble.h	/^  OcTree<float,int>* m_pOctree;$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_pTChain	XYEnsemble.h	/^	tree< CXYVector<float> >* m_pTChain; \/\/ tree stored coordinates$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_vLogWeight	XYEnsemble.h	/^  vector<float> m_vLogWeight;$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::m_vfSegLength	XYEnsemble.h	/^	vector<float> m_vfSegLength; \/\/ vector of segment length (may different)$/;"	m	class:CXYEnsemble	access:private
CXYEnsemble::~CXYEnsemble	XYEnsemble.cpp	/^CXYEnsemble::~CXYEnsemble(void)$/;"	f	class:CXYEnsemble	signature:(void)
CXYEnsemble::~CXYEnsemble	XYEnsemble.h	/^	~CXYEnsemble(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
CXYFile	XYFile.cpp	/^CXYFile::CXYFile(void)$/;"	f	class:CXYFile	signature:(void)
CXYFile	XYFile.h	/^	CXYFile(void);$/;"	p	class:CXYFile	access:public	signature:(void)
CXYFile	XYFile.h	/^class CXYFile$/;"	c
CXYFile::CXYFile	XYFile.cpp	/^CXYFile::CXYFile(void)$/;"	f	class:CXYFile	signature:(void)
CXYFile::CXYFile	XYFile.h	/^	CXYFile(void);$/;"	p	class:CXYFile	access:public	signature:(void)
CXYFile::DirExists	XYFile.cpp	/^bool CXYFile::DirExists(const char* cDirName){$/;"	f	class:CXYFile	signature:(const char* cDirName)
CXYFile::DirExists	XYFile.h	/^	static bool DirExists(const char* cDirName);$/;"	p	class:CXYFile	access:public	signature:(const char* cDirName)
CXYFile::FileExists	XYFile.cpp	/^bool CXYFile::FileExists(const char* cFileName){$/;"	f	class:CXYFile	signature:(const char* cFileName)
CXYFile::FileExists	XYFile.h	/^	static bool FileExists(const char* cFileName);$/;"	p	class:CXYFile	access:public	signature:(const char* cFileName)
CXYFile::MakeDirectory	XYFile.cpp	/^int CXYFile::MakeDirectory(char* sPath, int imode)$/;"	f	class:CXYFile	signature:(char* sPath, int imode)
CXYFile::MakeDirectory	XYFile.h	/^	static int MakeDirectory(char* sPath, int imode);$/;"	p	class:CXYFile	access:public	signature:(char* sPath, int imode)
CXYFile::ReadAtomsFromPDB	XYFile.cpp	/^CXYPDB CXYFile::ReadAtomsFromPDB(const char* acfname)$/;"	f	class:CXYFile	signature:(const char* acfname)
CXYFile::ReadAtomsFromPDB	XYFile.h	/^	static CXYPDB ReadAtomsFromPDB(const char* acfname);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname)
CXYFile::ReadCSV	XYFile.cpp	/^void CXYFile::ReadCSV(istream& in, vector<vector<string>*>& data) {$/;"	f	class:CXYFile	signature:(istream& in, vector<vector<string>*>& data)
CXYFile::ReadCSV	XYFile.h	/^	static void ReadCSV(istream& in, vector<vector<string>*>& data);$/;"	p	class:CXYFile	access:public	signature:(istream& in, vector<vector<string>*>& data)
CXYFile::ReadMatrix	XYFile.cpp	/^CXYMatrixf CXYFile::ReadMatrix(const char* acfname)$/;"	f	class:CXYFile	signature:(const char* acfname)
CXYFile::ReadMatrix	XYFile.cpp	/^CXYMatrixf CXYFile::ReadMatrix(const char* acfname, int iNumRowSkip, int iNumColSkip)$/;"	f	class:CXYFile	signature:(const char* acfname, int iNumRowSkip, int iNumColSkip)
CXYFile::ReadMatrix	XYFile.h	/^	static CXYMatrixf ReadMatrix(const char* acfname);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname)
CXYFile::ReadMatrix	XYFile.h	/^	static CXYMatrixf ReadMatrix(const char* acfname, int iNumRowSkip, int iNumColSkip);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname, int iNumRowSkip, int iNumColSkip)
CXYFile::ReadSparseMatrix	XYFile.cpp	/^CXYMatrixf CXYFile::ReadSparseMatrix(const char* acfname)$/;"	f	class:CXYFile	signature:(const char* acfname)
CXYFile::ReadSparseMatrix	XYFile.h	/^	static CXYMatrixf ReadSparseMatrix(const char* acfname);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname)
CXYFile::ReadSparseMatrixToTriple	XYFile.cpp	/^vector<CXYTriple<int, int, float> > CXYFile::ReadSparseMatrixToTriple(const char* acfname)$/;"	f	class:CXYFile	signature:(const char* acfname)
CXYFile::ReadSparseMatrixToTriple	XYFile.h	/^  vector<CXYTriple<int, int, float> > ReadSparseMatrixToTriple(const char* acfname);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname)
CXYFile::ReadVector	XYFile.cpp	/^CXYVector<float> CXYFile::ReadVector(const char* acfname)$/;"	f	class:CXYFile	signature:(const char* acfname)
CXYFile::ReadVector	XYFile.h	/^	static CXYVector<float> ReadVector(const char* acfname);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname)
CXYFile::ReadVectorInt	XYFile.cpp	/^CXYVector<int> CXYFile::ReadVectorInt(const char* acfname)$/;"	f	class:CXYFile	signature:(const char* acfname)
CXYFile::ReadVectorInt	XYFile.h	/^	static CXYVector<int> ReadVectorInt(const char* acfname);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname)
CXYFile::WriteAtomsToPDB	XYFile.cpp	/^void CXYFile::WriteAtomsToPDB( const char* acfname, const char* _mode, vector<CXYPDB>& rkvPDBs )$/;"	f	class:CXYFile	signature:( const char* acfname, const char* _mode, vector<CXYPDB>& rkvPDBs )
CXYFile::WriteAtomsToPDB	XYFile.cpp	/^void CXYFile::WriteAtomsToPDB(const char* acfname, const char* _mode, CXYPDB& rkP)$/;"	f	class:CXYFile	signature:(const char* acfname, const char* _mode, CXYPDB& rkP)
CXYFile::WriteAtomsToPDB	XYFile.h	/^	static void WriteAtomsToPDB(const char* acfname, const char* _mode, CXYPDB& rkP);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname, const char* _mode, CXYPDB& rkP)
CXYFile::WriteAtomsToPDB	XYFile.h	/^	static void WriteAtomsToPDB(const char* acfname, const char* _mode, vector<CXYPDB>& rkvPDBs);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname, const char* _mode, vector<CXYPDB>& rkvPDBs)
CXYFile::WriteComment	XYFile.cpp	/^void CXYFile::WriteComment(const char* acfname, const char* _mode, const char* acComment)$/;"	f	class:CXYFile	signature:(const char* acfname, const char* _mode, const char* acComment)
CXYFile::WriteComment	XYFile.h	/^	static void WriteComment(const char* acfname, const char* _mode, const char* acComment);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname, const char* _mode, const char* acComment)
CXYFile::WriteMatrix	XYFile.cpp	/^void CXYFile::WriteMatrix(const char* acfname, const char* _mode, const CXYMatrixf& rkM)$/;"	f	class:CXYFile	signature:(const char* acfname, const char* _mode, const CXYMatrixf& rkM)
CXYFile::WriteMatrix	XYFile.h	/^	static void WriteMatrix(const char* acfname, const char* _mode, const CXYMatrixf& rkM);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname, const char* _mode, const CXYMatrixf& rkM)
CXYFile::WriteSparseMatrix	XYFile.cpp	/^void CXYFile::WriteSparseMatrix(const char* acfname, const char* _mode, const CXYMatrixf& rkM)$/;"	f	class:CXYFile	signature:(const char* acfname, const char* _mode, const CXYMatrixf& rkM)
CXYFile::WriteSparseMatrix	XYFile.h	/^	static void WriteSparseMatrix(const char* acfname, const char* _mode, const CXYMatrixf& rkM);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname, const char* _mode, const CXYMatrixf& rkM)
CXYFile::WriteVector	XYFile.cpp	/^void CXYFile::WriteVector(const char* acfname, const char* _mode, const CXYVector<CXYPoint3D<float> >& rkV)$/;"	f	class:CXYFile	signature:(const char* acfname, const char* _mode, const CXYVector<CXYPoint3D<float> >& rkV)
CXYFile::WriteVector	XYFile.cpp	/^void CXYFile::WriteVector(const char* acfname, const char* _mode, const CXYVectorf& rkV)$/;"	f	class:CXYFile	signature:(const char* acfname, const char* _mode, const CXYVectorf& rkV)
CXYFile::WriteVector	XYFile.h	/^	static void WriteVector(const char* acfname, const char* _mode, const CXYVector<CXYPoint3D<float> >& rkV);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname, const char* _mode, const CXYVector<CXYPoint3D<float> >& rkV)
CXYFile::WriteVector	XYFile.h	/^	static void WriteVector(const char* acfname, const char* _mode, const CXYVectorf& rkV);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname, const char* _mode, const CXYVectorf& rkV)
CXYFile::~CXYFile	XYFile.cpp	/^CXYFile::~CXYFile(void)$/;"	f	class:CXYFile	signature:(void)
CXYFile::~CXYFile	XYFile.h	/^	~CXYFile(void);$/;"	p	class:CXYFile	access:public	signature:(void)
CXYLapackEigen	XYLapack.cpp	/^CXYLapackEigen<Real>::CXYLapackEigen (const CXYMatrix<Real>& rkM)$/;"	f	class:CXYLapackEigen	signature:(const CXYMatrix<Real>& rkM)
CXYLapackEigen	XYLapack.cpp	/^CXYLapackEigen<Real>::CXYLapackEigen (int iSize)$/;"	f	class:CXYLapackEigen	signature:(int iSize)
CXYLapackEigen	XYLapack.cpp	/^template class CXYLapackEigen<float>;$/;"	x	file:
CXYLapackEigen	XYLapack.h	/^	CXYLapackEigen (const CXYMatrix<Real>& rkM);$/;"	p	class:CXYLapackEigen	access:public	signature:(const CXYMatrix<Real>& rkM)
CXYLapackEigen	XYLapack.h	/^	CXYLapackEigen(int iSize);$/;"	p	class:CXYLapackEigen	access:public	signature:(int iSize)
CXYLapackEigen	XYLapack.h	/^class CXYLapackEigen{$/;"	c
CXYLapackEigen::CXYLapackEigen	XYLapack.cpp	/^CXYLapackEigen<Real>::CXYLapackEigen (const CXYMatrix<Real>& rkM)$/;"	f	class:CXYLapackEigen	signature:(const CXYMatrix<Real>& rkM)
CXYLapackEigen::CXYLapackEigen	XYLapack.cpp	/^CXYLapackEigen<Real>::CXYLapackEigen (int iSize)$/;"	f	class:CXYLapackEigen	signature:(int iSize)
CXYLapackEigen::CXYLapackEigen	XYLapack.h	/^	CXYLapackEigen (const CXYMatrix<Real>& rkM);$/;"	p	class:CXYLapackEigen	access:public	signature:(const CXYMatrix<Real>& rkM)
CXYLapackEigen::CXYLapackEigen	XYLapack.h	/^	CXYLapackEigen(int iSize);$/;"	p	class:CXYLapackEigen	access:public	signature:(int iSize)
CXYLapackEigen::GetEigenValue	XYLapack.cpp	/^Real CXYLapackEigen<Real>::GetEigenValue (int i) const$/;"	f	class:CXYLapackEigen	signature:(int i) const
CXYLapackEigen::GetEigenValue	XYLapack.h	/^	Real GetEigenValue (int i) const;$/;"	p	class:CXYLapackEigen	access:public	signature:(int i) const
CXYLapackEigen::GetEigenValues	XYLapack.cpp	/^CXYVector<Real> CXYLapackEigen<Real>::GetEigenValues() const$/;"	f	class:CXYLapackEigen	signature:() const
CXYLapackEigen::GetEigenValues	XYLapack.h	/^	CXYVector<Real> GetEigenValues() const;$/;"	p	class:CXYLapackEigen	access:public	signature:() const
CXYLapackEigen::GetEigenVector	XYLapack.cpp	/^CXYVector<Real> CXYLapackEigen<Real>::GetEigenVector (int i) const$/;"	f	class:CXYLapackEigen	signature:(int i) const
CXYLapackEigen::GetEigenVector	XYLapack.h	/^	CXYVector<Real> GetEigenVector (int i) const;$/;"	p	class:CXYLapackEigen	access:public	signature:(int i) const
CXYLapackEigen::GetEigenVectors	XYLapack.cpp	/^const CXYMatrix<Real>& CXYLapackEigen<Real>::GetEigenVectors () const$/;"	f	class:CXYLapackEigen	signature:() const
CXYLapackEigen::GetEigenVectors	XYLapack.h	/^	const CXYMatrix<Real>& GetEigenVectors () const;$/;"	p	class:CXYLapackEigen	access:public	signature:() const
CXYLapackEigen::Lapack_SSYEV	XYLapack.cpp	/^void CXYLapackEigen<Real>::Lapack_SSYEV()$/;"	f	class:CXYLapackEigen	signature:()
CXYLapackEigen::Lapack_SSYEV	XYLapack.h	/^	void Lapack_SSYEV();$/;"	p	class:CXYLapackEigen	access:public	signature:()
CXYLapackEigen::SetLwork	XYLapack.cpp	/^void CXYLapackEigen<Real>::SetLwork()$/;"	f	class:CXYLapackEigen	signature:()
CXYLapackEigen::SetLwork	XYLapack.h	/^	void SetLwork();$/;"	p	class:CXYLapackEigen	access:public	signature:()
CXYLapackEigen::m_a	XYLapack.h	/^	Real* m_a;$/;"	m	class:CXYLapackEigen	access:private
CXYLapackEigen::m_info	XYLapack.h	/^	int m_info;$/;"	m	class:CXYLapackEigen	access:private
CXYLapackEigen::m_jobz	XYLapack.h	/^	char* m_jobz;$/;"	m	class:CXYLapackEigen	access:private
CXYLapackEigen::m_kMat	XYLapack.h	/^	CXYMatrix<Real> m_kMat;$/;"	m	class:CXYLapackEigen	access:private
CXYLapackEigen::m_lda	XYLapack.h	/^	int m_lda;$/;"	m	class:CXYLapackEigen	access:private
CXYLapackEigen::m_lwork	XYLapack.h	/^	int m_lwork;$/;"	m	class:CXYLapackEigen	access:private
CXYLapackEigen::m_n	XYLapack.h	/^	int m_n;$/;"	m	class:CXYLapackEigen	access:private
CXYLapackEigen::m_uplo	XYLapack.h	/^	char* m_uplo;$/;"	m	class:CXYLapackEigen	access:private
CXYLapackEigen::m_w	XYLapack.h	/^	Real* m_w;$/;"	m	class:CXYLapackEigen	access:private
CXYLapackEigen::m_work	XYLapack.h	/^	Real* m_work;$/;"	m	class:CXYLapackEigen	access:private
CXYLapackEigen::operator ()	XYLapack.cpp	/^Real& CXYLapackEigen<Real>::operator() (int iRow, int iCol)$/;"	f	class:CXYLapackEigen	signature:(int iRow, int iCol)
CXYLapackEigen::operator ()	XYLapack.h	/^	Real& operator() (int iRow, int iCol);$/;"	p	class:CXYLapackEigen	access:public	signature:(int iRow, int iCol)
CXYLapackEigen::operator =	XYLapack.cpp	/^CXYLapackEigen<Real>& CXYLapackEigen<Real>::operator= (const CXYMatrix<Real>& rkM)$/;"	f	class:CXYLapackEigen	signature:(const CXYMatrix<Real>& rkM)
CXYLapackEigen::operator =	XYLapack.h	/^	CXYLapackEigen& operator= (const CXYMatrix<Real>& rkM);$/;"	p	class:CXYLapackEigen	access:public	signature:(const CXYMatrix<Real>& rkM)
CXYLapackEigen::~CXYLapackEigen	XYLapack.cpp	/^CXYLapackEigen<Real>::~CXYLapackEigen ()$/;"	f	class:CXYLapackEigen	signature:()
CXYLapackEigen::~CXYLapackEigen	XYLapack.h	/^	~CXYLapackEigen(void);$/;"	p	class:CXYLapackEigen	access:public	signature:(void)
CXYMath	XYMath.h	/^	CXYMath(void);$/;"	p	class:CXYMath	access:public	signature:(void)
CXYMath	XYMath.h	/^class CXYMath$/;"	c
CXYMath	XYMath.inl	/^CXYMath<Real>::CXYMath(void)$/;"	f	class:CXYMath	signature:(void)
CXYMath::AlmostEqual2sComplement	XYMath.h	/^	static bool AlmostEqual2sComplement(float A, float B, int maxUlps);$/;"	p	class:CXYMath	access:public	signature:(float A, float B, int maxUlps)
CXYMath::AlmostEqual2sComplement	XYMath.inl	/^bool CXYMath<Real>::AlmostEqual2sComplement(float A, float B, int maxUlps)$/;"	f	class:CXYMath	signature:(float A, float B, int maxUlps)
CXYMath::CXYMath	XYMath.h	/^	CXYMath(void);$/;"	p	class:CXYMath	access:public	signature:(void)
CXYMath::CXYMath	XYMath.inl	/^CXYMath<Real>::CXYMath(void)$/;"	f	class:CXYMath	signature:(void)
CXYMath::FAbs	XYMath.h	/^	static Real FAbs (Real fValue);$/;"	p	class:CXYMath	access:public	signature:(Real fValue)
CXYMath::FAbs	XYMath.inl	/^Real CXYMath<Real>::FAbs (Real fValue)$/;"	f	class:CXYMath	signature:(Real fValue)
CXYMath::FastInvSqrt	XYMath.cpp	/^double CXYMath<double>::FastInvSqrt (double dValue)$/;"	f	class:CXYMath	signature:(double dValue)
CXYMath::FastInvSqrt	XYMath.cpp	/^float CXYMath<float>::FastInvSqrt (float fValue)$/;"	f	class:CXYMath	signature:(float fValue)
CXYMath::FastInvSqrt	XYMath.h	/^	static Real FastInvSqrt (Real fValue);$/;"	p	class:CXYMath	access:public	signature:(Real fValue)
CXYMath::FastInvSqrt	XYMath.h	/^template<> double CXYMath<double>::FastInvSqrt (double dValue);$/;"	p	class:CXYMath	signature:(double dValue)
CXYMath::FastInvSqrt	XYMath.h	/^template<> float CXYMath<float>::FastInvSqrt (float fValue);$/;"	p	class:CXYMath	signature:(float fValue)
CXYMath::MAX_REAL	XYMath.cpp	/^	template<> const double CXYMath<double>::MAX_REAL = LLONG_MAX;$/;"	m	class:CXYMath	file:
CXYMath::MAX_REAL	XYMath.cpp	/^	template<> const double CXYMath<double>::MAX_REAL = _I64_MAX;$/;"	m	class:CXYMath	file:
CXYMath::MAX_REAL	XYMath.cpp	/^	template<> const float CXYMath<float>::MAX_REAL = LONG_MAX;$/;"	m	class:CXYMath	file:
CXYMath::MAX_REAL	XYMath.h	/^	static const Real MAX_REAL;$/;"	m	class:CXYMath	access:public
CXYMath::PI	XYMath.cpp	/^template<> const float CXYMath<float>::PI = 3.1415926;$/;"	m	class:CXYMath	file:
CXYMath::PI	XYMath.h	/^	static const Real PI; \/\/ pi$/;"	m	class:CXYMath	access:public
CXYMath::Sqrt	XYMath.h	/^	static Real Sqrt (Real fValue);$/;"	p	class:CXYMath	access:public	signature:(Real fValue)
CXYMath::Sqrt	XYMath.inl	/^Real CXYMath<Real>::Sqrt (Real fValue)$/;"	f	class:CXYMath	signature:(Real fValue)
CXYMath::ZERO_TOLERANCE	XYMath.cpp	/^template<> const double CXYMath<double>::ZERO_TOLERANCE = 1e-08;$/;"	m	class:CXYMath	file:
CXYMath::ZERO_TOLERANCE	XYMath.cpp	/^template<> const float CXYMath<float>::ZERO_TOLERANCE = 1e-06f;$/;"	m	class:CXYMath	file:
CXYMath::ZERO_TOLERANCE	XYMath.h	/^	static const Real ZERO_TOLERANCE;$/;"	m	class:CXYMath	access:public
CXYMath::k_B	XYMath.cpp	/^template<> const float CXYMath<float>::k_B = 1.3806505e-23;$/;"	m	class:CXYMath	file:
CXYMath::k_B	XYMath.h	/^	static const Real k_B; \/\/ Boltzmann constant$/;"	m	class:CXYMath	access:public
CXYMath::~CXYMath	XYMath.h	/^	~CXYMath(void);$/;"	p	class:CXYMath	access:public	signature:(void)
CXYMath::~CXYMath	XYMath.inl	/^CXYMath<Real>::~CXYMath(void)$/;"	f	class:CXYMath	signature:(void)
CXYMatrix	XYMatrix.h	/^    CXYMatrix (const CXYMatrix& rkM);$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM)
CXYMatrix	XYMatrix.h	/^    CXYMatrix (int iRows = 0, int iCols = 0);$/;"	p	class:CXYMatrix	access:public	signature:(int iRows = 0, int iCols = 0)
CXYMatrix	XYMatrix.h	/^    CXYMatrix (int iRows, int iCols, const Real* afData);$/;"	p	class:CXYMatrix	access:public	signature:(int iRows, int iCols, const Real* afData)
CXYMatrix	XYMatrix.h	/^    CXYMatrix (int iRows, int iCols, const Real** aafEntry);$/;"	p	class:CXYMatrix	access:public	signature:(int iRows, int iCols, const Real** aafEntry)
CXYMatrix	XYMatrix.h	/^class CXYMatrix$/;"	c
CXYMatrix	XYMatrix.inl	/^CXYMatrix<Real>::CXYMatrix (const CXYMatrix& rkM)$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM)
CXYMatrix	XYMatrix.inl	/^CXYMatrix<Real>::CXYMatrix (int iRows, int iCols)$/;"	f	class:CXYMatrix	signature:(int iRows, int iCols)
CXYMatrix	XYMatrix.inl	/^CXYMatrix<Real>::CXYMatrix (int iRows, int iCols, const Real* afEntry)$/;"	f	class:CXYMatrix	signature:(int iRows, int iCols, const Real* afEntry)
CXYMatrix	XYMatrix.inl	/^CXYMatrix<Real>::CXYMatrix (int iRows, int iCols, const Real** aafMatrix)$/;"	f	class:CXYMatrix	signature:(int iRows, int iCols, const Real** aafMatrix)
CXYMatrix::Allocate	XYMatrix.h	/^    void Allocate (bool bSetToZero);$/;"	p	class:CXYMatrix	access:private	signature:(bool bSetToZero)
CXYMatrix::Allocate	XYMatrix.inl	/^void CXYMatrix<Real>::Allocate (bool bSetToZero)$/;"	f	class:CXYMatrix	signature:(bool bSetToZero)
CXYMatrix::CXYMatrix	XYMatrix.h	/^    CXYMatrix (const CXYMatrix& rkM);$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM)
CXYMatrix::CXYMatrix	XYMatrix.h	/^    CXYMatrix (int iRows = 0, int iCols = 0);$/;"	p	class:CXYMatrix	access:public	signature:(int iRows = 0, int iCols = 0)
CXYMatrix::CXYMatrix	XYMatrix.h	/^    CXYMatrix (int iRows, int iCols, const Real* afData);$/;"	p	class:CXYMatrix	access:public	signature:(int iRows, int iCols, const Real* afData)
CXYMatrix::CXYMatrix	XYMatrix.h	/^    CXYMatrix (int iRows, int iCols, const Real** aafEntry);$/;"	p	class:CXYMatrix	access:public	signature:(int iRows, int iCols, const Real** aafEntry)
CXYMatrix::CXYMatrix	XYMatrix.inl	/^CXYMatrix<Real>::CXYMatrix (const CXYMatrix& rkM)$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM)
CXYMatrix::CXYMatrix	XYMatrix.inl	/^CXYMatrix<Real>::CXYMatrix (int iRows, int iCols)$/;"	f	class:CXYMatrix	signature:(int iRows, int iCols)
CXYMatrix::CXYMatrix	XYMatrix.inl	/^CXYMatrix<Real>::CXYMatrix (int iRows, int iCols, const Real* afEntry)$/;"	f	class:CXYMatrix	signature:(int iRows, int iCols, const Real* afEntry)
CXYMatrix::CXYMatrix	XYMatrix.inl	/^CXYMatrix<Real>::CXYMatrix (int iRows, int iCols, const Real** aafMatrix)$/;"	f	class:CXYMatrix	signature:(int iRows, int iCols, const Real** aafMatrix)
CXYMatrix::CompareArrays	XYMatrix.h	/^    int CompareArrays (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:private	signature:(const CXYMatrix& rkM) const
CXYMatrix::CompareArrays	XYMatrix.inl	/^int CXYMatrix<Real>::CompareArrays (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
CXYMatrix::Deallocate	XYMatrix.h	/^    void Deallocate ();$/;"	p	class:CXYMatrix	access:private	signature:()
CXYMatrix::Deallocate	XYMatrix.inl	/^void CXYMatrix<Real>::Deallocate ()$/;"	f	class:CXYMatrix	signature:()
CXYMatrix::GetColumn	XYMatrix.h	/^    CXYVector<Real> GetColumn (int iCol) const;$/;"	p	class:CXYMatrix	access:public	signature:(int iCol) const
CXYMatrix::GetColumn	XYMatrix.inl	/^CXYVector<Real> CXYMatrix<Real>::GetColumn (int iCol) const$/;"	f	class:CXYMatrix	signature:(int iCol) const
CXYMatrix::GetColumnMajor	XYMatrix.h	/^	void GetColumnMajor (Real* afCMajor) const;$/;"	p	class:CXYMatrix	access:public	signature:(Real* afCMajor) const
CXYMatrix::GetColumnMajor	XYMatrix.inl	/^void CXYMatrix<Real>::GetColumnMajor (Real* afCMajor) const$/;"	f	class:CXYMatrix	signature:(Real* afCMajor) const
CXYMatrix::GetColumns	XYMatrix.h	/^    int GetColumns () const;$/;"	p	class:CXYMatrix	access:public	signature:() const
CXYMatrix::GetColumns	XYMatrix.inl	/^int CXYMatrix<Real>::GetColumns () const$/;"	f	class:CXYMatrix	signature:() const
CXYMatrix::GetInverse	XYMatrix.h	/^    bool GetInverse (CXYMatrix<Real>& rkInverse) const;$/;"	p	class:CXYMatrix	access:public	signature:(CXYMatrix<Real>& rkInverse) const
CXYMatrix::GetInverse	XYMatrix.inl	/^bool CXYMatrix<Real>::GetInverse (CXYMatrix<Real>& rkInverse) const$/;"	f	class:CXYMatrix	signature:(CXYMatrix<Real>& rkInverse) const
CXYMatrix::GetQuantity	XYMatrix.h	/^    int GetQuantity () const;$/;"	p	class:CXYMatrix	access:public	signature:() const
CXYMatrix::GetQuantity	XYMatrix.inl	/^int CXYMatrix<Real>::GetQuantity () const$/;"	f	class:CXYMatrix	signature:() const
CXYMatrix::GetRow	XYMatrix.h	/^    CXYVector<Real> GetRow (int iRow) const;$/;"	p	class:CXYMatrix	access:public	signature:(int iRow) const
CXYMatrix::GetRow	XYMatrix.inl	/^CXYVector<Real> CXYMatrix<Real>::GetRow (int iRow) const$/;"	f	class:CXYMatrix	signature:(int iRow) const
CXYMatrix::GetRows	XYMatrix.h	/^    int GetRows () const;$/;"	p	class:CXYMatrix	access:public	signature:() const
CXYMatrix::GetRows	XYMatrix.inl	/^int CXYMatrix<Real>::GetRows () const$/;"	f	class:CXYMatrix	signature:() const
CXYMatrix::GetSize	XYMatrix.h	/^    void GetSize (int& riRows, int& riCols) const;$/;"	p	class:CXYMatrix	access:public	signature:(int& riRows, int& riCols) const
CXYMatrix::GetSize	XYMatrix.inl	/^void CXYMatrix<Real>::GetSize (int& riRows, int& riCols) const$/;"	f	class:CXYMatrix	signature:(int& riRows, int& riCols) const
CXYMatrix::QForm	XYMatrix.h	/^    Real QForm (const CXYVector<Real>& rkU, const CXYVector<Real>& rkV)$/;"	p	class:CXYMatrix	access:public	signature:(const CXYVector<Real>& rkU, const CXYVector<Real>& rkV) const
CXYMatrix::QForm	XYMatrix.inl	/^Real CXYMatrix<Real>::QForm (const CXYVector<Real>& rkU, const CXYVector<Real>& rkV)$/;"	f	class:CXYMatrix	signature:(const CXYVector<Real>& rkU, const CXYVector<Real>& rkV) const
CXYMatrix::SetColumn	XYMatrix.h	/^    void SetColumn (int iCol, const CXYVector<Real>& rkV);$/;"	p	class:CXYMatrix	access:public	signature:(int iCol, const CXYVector<Real>& rkV)
CXYMatrix::SetColumn	XYMatrix.inl	/^void CXYMatrix<Real>::SetColumn (int iCol, const CXYVector<Real>& rkV)$/;"	f	class:CXYMatrix	signature:(int iCol, const CXYVector<Real>& rkV)
CXYMatrix::SetMatrix	XYMatrix.h	/^	void SetMatrix (int iRows, int iCols, const Real* afEntry);$/;"	p	class:CXYMatrix	access:public	signature:(int iRows, int iCols, const Real* afEntry)
CXYMatrix::SetMatrix	XYMatrix.h	/^    void SetMatrix (int iRows, int iCols, const Real** aafMatrix);$/;"	p	class:CXYMatrix	access:public	signature:(int iRows, int iCols, const Real** aafMatrix)
CXYMatrix::SetMatrix	XYMatrix.inl	/^void CXYMatrix<Real>::SetMatrix (int iRows, int iCols, const Real* afData)$/;"	f	class:CXYMatrix	signature:(int iRows, int iCols, const Real* afData)
CXYMatrix::SetMatrix	XYMatrix.inl	/^void CXYMatrix<Real>::SetMatrix (int iRows, int iCols, const Real** aafEntry)$/;"	f	class:CXYMatrix	signature:(int iRows, int iCols, const Real** aafEntry)
CXYMatrix::SetRow	XYMatrix.h	/^	void SetRow (int iRow, const CXYVector<Real>& rkV);$/;"	p	class:CXYMatrix	access:public	signature:(int iRow, const CXYVector<Real>& rkV)
CXYMatrix::SetRow	XYMatrix.inl	/^void CXYMatrix<Real>::SetRow (int iRow, const CXYVector<Real>& rkV)$/;"	f	class:CXYMatrix	signature:(int iRow, const CXYVector<Real>& rkV)
CXYMatrix::SetSize	XYMatrix.h	/^    void SetSize (int iRows, int iCols);$/;"	p	class:CXYMatrix	access:public	signature:(int iRows, int iCols)
CXYMatrix::SetSize	XYMatrix.inl	/^void CXYMatrix<Real>::SetSize (int iRows, int iCols)$/;"	f	class:CXYMatrix	signature:(int iRows, int iCols)
CXYMatrix::SetZeros	XYMatrix.h	/^	void SetZeros();$/;"	p	class:CXYMatrix	access:public	signature:()
CXYMatrix::SetZeros	XYMatrix.inl	/^void CXYMatrix<Real>::SetZeros()$/;"	f	class:CXYMatrix	signature:()
CXYMatrix::SwapRows	XYMatrix.h	/^    void SwapRows (int iRow0, int iRow1);$/;"	p	class:CXYMatrix	access:public	signature:(int iRow0, int iRow1)
CXYMatrix::SwapRows	XYMatrix.inl	/^void CXYMatrix<Real>::SwapRows (int iRow0, int iRow1)$/;"	f	class:CXYMatrix	signature:(int iRow0, int iRow1)
CXYMatrix::TimesTranspose	XYMatrix.h	/^    CXYMatrix TimesTranspose (const CXYMatrix& rkM) const;  \/\/ this * M^T$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
CXYMatrix::TimesTranspose	XYMatrix.inl	/^CXYMatrix<Real> CXYMatrix<Real>::TimesTranspose (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
CXYMatrix::Transpose	XYMatrix.h	/^    CXYMatrix Transpose () const;  \/\/ M^T$/;"	p	class:CXYMatrix	access:public	signature:() const
CXYMatrix::Transpose	XYMatrix.inl	/^CXYMatrix<Real> CXYMatrix<Real>::Transpose () const$/;"	f	class:CXYMatrix	signature:() const
CXYMatrix::TransposeTimes	XYMatrix.h	/^    CXYMatrix TransposeTimes (const CXYMatrix& rkM) const;  \/\/ this^T * M$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
CXYMatrix::TransposeTimes	XYMatrix.inl	/^CXYMatrix<Real> CXYMatrix<Real>::TransposeTimes (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
CXYMatrix::m_aafEntry	XYMatrix.h	/^    Real** m_aafEntry;$/;"	m	class:CXYMatrix	access:private
CXYMatrix::m_afData	XYMatrix.h	/^    Real* m_afData;$/;"	m	class:CXYMatrix	access:private
CXYMatrix::m_iCols	XYMatrix.h	/^	int m_iRows, m_iCols, m_iQuantity;$/;"	m	class:CXYMatrix	access:private
CXYMatrix::m_iQuantity	XYMatrix.h	/^	int m_iRows, m_iCols, m_iQuantity;$/;"	m	class:CXYMatrix	access:private
CXYMatrix::m_iRows	XYMatrix.h	/^	int m_iRows, m_iCols, m_iQuantity;$/;"	m	class:CXYMatrix	access:private
CXYMatrix::operator	XYMatrix.h	/^    Real operator( ) (int iRow, int iCol) const;$/;"	p	class:CXYMatrix	access:public	signature:(int iRow, int iCol) const
CXYMatrix::operator	XYMatrix.h	/^    Real& operator( ) (int iRow, int iCol);$/;"	p	class:CXYMatrix	access:public	signature:(int iRow, int iCol)
CXYMatrix::operator !=	XYMatrix.h	/^    bool operator!= (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
CXYMatrix::operator !=	XYMatrix.inl	/^bool CXYMatrix<Real>::operator!= (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
CXYMatrix::operator ()	XYMatrix.inl	/^Real CXYMatrix<Real>::operator() (int iRow, int iCol) const$/;"	f	class:CXYMatrix	signature:(int iRow, int iCol) const
CXYMatrix::operator ()	XYMatrix.inl	/^Real& CXYMatrix<Real>::operator() (int iRow, int iCol)$/;"	f	class:CXYMatrix	signature:(int iRow, int iCol)
CXYMatrix::operator *	XYMatrix.h	/^    CXYMatrix operator* (Real fScalar) const;$/;"	p	class:CXYMatrix	access:public	signature:(Real fScalar) const
CXYMatrix::operator *	XYMatrix.h	/^    CXYMatrix operator* (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
CXYMatrix::operator *	XYMatrix.h	/^    CXYVector<Real> operator* (const CXYVector<Real>& rkV) const;  \/\/ M * v$/;"	p	class:CXYMatrix	access:public	signature:(const CXYVector<Real>& rkV) const
CXYMatrix::operator *	XYMatrix.inl	/^CXYMatrix<Real> CXYMatrix<Real>::operator* (Real fScalar) const$/;"	f	class:CXYMatrix	signature:(Real fScalar) const
CXYMatrix::operator *	XYMatrix.inl	/^CXYMatrix<Real> CXYMatrix<Real>::operator* (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
CXYMatrix::operator *	XYMatrix.inl	/^CXYVector<Real> CXYMatrix<Real>::operator* (const CXYVector<Real>& rkV) const$/;"	f	class:CXYMatrix	signature:(const CXYVector<Real>& rkV) const
CXYMatrix::operator *=	XYMatrix.h	/^    CXYMatrix& operator*= (Real fScalar);$/;"	p	class:CXYMatrix	access:public	signature:(Real fScalar)
CXYMatrix::operator *=	XYMatrix.inl	/^CXYMatrix<Real>& CXYMatrix<Real>::operator*= (Real fScalar)$/;"	f	class:CXYMatrix	signature:(Real fScalar)
CXYMatrix::operator +	XYMatrix.h	/^    CXYMatrix operator+ (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
CXYMatrix::operator +	XYMatrix.inl	/^CXYMatrix<Real> CXYMatrix<Real>::operator+ (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
CXYMatrix::operator +=	XYMatrix.h	/^    CXYMatrix& operator+= (const CXYMatrix& rkM);$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM)
CXYMatrix::operator +=	XYMatrix.inl	/^CXYMatrix<Real>& CXYMatrix<Real>::operator+= (const CXYMatrix& rkM)$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM)
CXYMatrix::operator -	XYMatrix.h	/^    CXYMatrix operator- () const;$/;"	p	class:CXYMatrix	access:public	signature:() const
CXYMatrix::operator -	XYMatrix.h	/^    CXYMatrix operator- (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
CXYMatrix::operator -	XYMatrix.inl	/^CXYMatrix<Real> CXYMatrix<Real>::operator- () const$/;"	f	class:CXYMatrix	signature:() const
CXYMatrix::operator -	XYMatrix.inl	/^CXYMatrix<Real> CXYMatrix<Real>::operator- (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
CXYMatrix::operator -=	XYMatrix.h	/^    CXYMatrix& operator-= (const CXYMatrix& rkM);$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM)
CXYMatrix::operator -=	XYMatrix.inl	/^CXYMatrix<Real>& CXYMatrix<Real>::operator-= (const CXYMatrix& rkM)$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM)
CXYMatrix::operator /	XYMatrix.h	/^    CXYMatrix operator\/ (Real fScalar) const;$/;"	p	class:CXYMatrix	access:public	signature:(Real fScalar) const
CXYMatrix::operator /	XYMatrix.inl	/^CXYMatrix<Real> CXYMatrix<Real>::operator\/ (Real fScalar) const$/;"	f	class:CXYMatrix	signature:(Real fScalar) const
CXYMatrix::operator /=	XYMatrix.h	/^    CXYMatrix& operator\/= (Real fScalar);$/;"	p	class:CXYMatrix	access:public	signature:(Real fScalar)
CXYMatrix::operator /=	XYMatrix.inl	/^CXYMatrix<Real>& CXYMatrix<Real>::operator\/= (Real fScalar)$/;"	f	class:CXYMatrix	signature:(Real fScalar)
CXYMatrix::operator <	XYMatrix.h	/^    bool operator<  (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
CXYMatrix::operator <	XYMatrix.inl	/^bool CXYMatrix<Real>::operator<  (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
CXYMatrix::operator <=	XYMatrix.h	/^    bool operator<= (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
CXYMatrix::operator <=	XYMatrix.inl	/^bool CXYMatrix<Real>::operator<= (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
CXYMatrix::operator =	XYMatrix.h	/^    CXYMatrix& operator= (const CXYMatrix& rkM);$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM)
CXYMatrix::operator =	XYMatrix.inl	/^CXYMatrix<Real>& CXYMatrix<Real>::operator= (const CXYMatrix& rkM)$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM)
CXYMatrix::operator ==	XYMatrix.h	/^    bool operator== (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
CXYMatrix::operator ==	XYMatrix.inl	/^bool CXYMatrix<Real>::operator== (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
CXYMatrix::operator >	XYMatrix.h	/^    bool operator>  (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
CXYMatrix::operator >	XYMatrix.inl	/^bool CXYMatrix<Real>::operator>  (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
CXYMatrix::operator >=	XYMatrix.h	/^    bool operator>= (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
CXYMatrix::operator >=	XYMatrix.inl	/^bool CXYMatrix<Real>::operator>= (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
CXYMatrix::operator Real*	XYMatrix.h	/^    operator Real* ();$/;"	p	class:CXYMatrix	access:public	signature:()
CXYMatrix::operator Real*	XYMatrix.inl	/^CXYMatrix<Real>::operator Real* ()$/;"	f	class:CXYMatrix	signature:()
CXYMatrix::operator []	XYMatrix.h	/^    Real* operator[] (int iRow);$/;"	p	class:CXYMatrix	access:public	signature:(int iRow)
CXYMatrix::operator []	XYMatrix.h	/^    const Real* operator[] (int iRow) const;$/;"	p	class:CXYMatrix	access:public	signature:(int iRow) const
CXYMatrix::operator []	XYMatrix.inl	/^Real* CXYMatrix<Real>::operator[] (int iRow)$/;"	f	class:CXYMatrix	signature:(int iRow)
CXYMatrix::operator []	XYMatrix.inl	/^const Real* CXYMatrix<Real>::operator[] (int iRow) const$/;"	f	class:CXYMatrix	signature:(int iRow) const
CXYMatrix::operator const Real*	XYMatrix.h	/^	operator const Real* () const;$/;"	p	class:CXYMatrix	access:public	signature:() const
CXYMatrix::operator const Real*	XYMatrix.inl	/^CXYMatrix<Real>::operator const Real* () const$/;"	f	class:CXYMatrix	signature:() const
CXYMatrix::~CXYMatrix	XYMatrix.h	/^	~CXYMatrix(void);$/;"	p	class:CXYMatrix	access:public	signature:(void)
CXYMatrix::~CXYMatrix	XYMatrix.inl	/^CXYMatrix<Real>::~CXYMatrix ()$/;"	f	class:CXYMatrix	signature:()
CXYMatrixd	XYMatrix.h	/^typedef CXYMatrix<double>	CXYMatrixd;$/;"	t
CXYMatrixf	XYMatrix.h	/^typedef CXYMatrix<float>	CXYMatrixf;$/;"	t
CXYPDB	XYPDB.cpp	/^CXYPDB::CXYPDB(void)$/;"	f	class:CXYPDB	signature:(void)
CXYPDB	XYPDB.h	/^	CXYPDB(void);$/;"	p	class:CXYPDB	access:public	signature:(void)
CXYPDB	XYPDB.h	/^class CXYPDB $/;"	c
CXYPDB::CXYPDB	XYPDB.cpp	/^CXYPDB::CXYPDB(void)$/;"	f	class:CXYPDB	signature:(void)
CXYPDB::CXYPDB	XYPDB.h	/^	CXYPDB(void);$/;"	p	class:CXYPDB	access:public	signature:(void)
CXYPDB::GetPDBAtoms	XYPDB.cpp	/^const vector<CXYPDBAtom >* CXYPDB::GetPDBAtoms() const$/;"	f	class:CXYPDB	signature:() const
CXYPDB::GetPDBAtoms	XYPDB.cpp	/^vector<CXYPDBAtom >* CXYPDB::GetPDBAtoms()$/;"	f	class:CXYPDB	signature:()
CXYPDB::GetPDBAtoms	XYPDB.h	/^	const vector<CXYPDBAtom >* GetPDBAtoms() const;$/;"	p	class:CXYPDB	access:public	signature:() const
CXYPDB::GetPDBAtoms	XYPDB.h	/^	vector<CXYPDBAtom >* GetPDBAtoms();$/;"	p	class:CXYPDB	access:public	signature:()
CXYPDB::GetPDBIndex	XYPDB.cpp	/^int CXYPDB::GetPDBIndex(int iResSeq)$/;"	f	class:CXYPDB	signature:(int iResSeq)
CXYPDB::GetPDBIndex	XYPDB.h	/^    int GetPDBIndex(int iResSeq);$/;"	p	class:CXYPDB	access:public	signature:(int iResSeq)
CXYPDB::PostDealPDB	XYPDB.cpp	/^void CXYPDB::PostDealPDB(char* sLevel)$/;"	f	class:CXYPDB	signature:(char* sLevel)
CXYPDB::PostDealPDB	XYPDB.h	/^	void PostDealPDB(char* sLevel);$/;"	p	class:CXYPDB	access:public	signature:(char* sLevel)
CXYPDB::ReduceToSCOfCA	XYPDB.cpp	/^void CXYPDB::ReduceToSCOfCA(void)$/;"	f	class:CXYPDB	signature:(void)
CXYPDB::ReduceToSCOfCA	XYPDB.h	/^	void ReduceToSCOfCA(void);$/;"	p	class:CXYPDB	access:public	signature:(void)
CXYPDB::Size	XYPDB.cpp	/^int CXYPDB::Size() const$/;"	f	class:CXYPDB	signature:() const
CXYPDB::Size	XYPDB.h	/^	int Size() const;$/;"	p	class:CXYPDB	access:public	signature:() const
CXYPDB::m_kPDBAtoms	XYPDB.h	/^	vector<CXYPDBAtom> m_kPDBAtoms;$/;"	m	class:CXYPDB	access:private
CXYPDB::operator =	XYPDB.cpp	/^CXYPDB& CXYPDB::operator= (const CXYPDB& rkPDB)$/;"	f	class:CXYPDB	signature:(const CXYPDB& rkPDB)
CXYPDB::operator =	XYPDB.h	/^	CXYPDB& operator= (const CXYPDB& rkPDB);$/;"	p	class:CXYPDB	access:public	signature:(const CXYPDB& rkPDB)
CXYPDB::operator []	XYPDB.cpp	/^CXYPDBAtom* CXYPDB::operator[] (int iInd)$/;"	f	class:CXYPDB	signature:(int iInd)
CXYPDB::operator []	XYPDB.cpp	/^const CXYPDBAtom* CXYPDB::operator[] (int iInd) const$/;"	f	class:CXYPDB	signature:(int iInd) const
CXYPDB::operator []	XYPDB.h	/^	CXYPDBAtom* operator[] (int iInd);$/;"	p	class:CXYPDB	access:public	signature:(int iInd)
CXYPDB::operator []	XYPDB.h	/^	const CXYPDBAtom* operator[] (int iInd) const;$/;"	p	class:CXYPDB	access:public	signature:(int iInd) const
CXYPDB::~CXYPDB	XYPDB.cpp	/^CXYPDB::~CXYPDB(void)$/;"	f	class:CXYPDB	signature:(void)
CXYPDB::~CXYPDB	XYPDB.h	/^	~CXYPDB(void);$/;"	p	class:CXYPDB	access:public	signature:(void)
CXYPDBAtom	XYPDBAtom.cpp	/^CXYPDBAtom::CXYPDBAtom(void):$/;"	f	class:CXYPDBAtom	signature:(void)
CXYPDBAtom	XYPDBAtom.h	/^	CXYPDBAtom(void);$/;"	p	class:CXYPDBAtom	access:public	signature:(void)
CXYPDBAtom	XYPDBAtom.h	/^class CXYPDBAtom$/;"	c
CXYPDBAtom::CXYPDBAtom	XYPDBAtom.cpp	/^CXYPDBAtom::CXYPDBAtom(void):$/;"	f	class:CXYPDBAtom	signature:(void)
CXYPDBAtom::CXYPDBAtom	XYPDBAtom.h	/^	CXYPDBAtom(void);$/;"	p	class:CXYPDBAtom	access:public	signature:(void)
CXYPDBAtom::GetAltLoc	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetAltLoc()$/;"	f	class:CXYPDBAtom	signature:()
CXYPDBAtom::GetAltLoc	XYPDBAtom.h	/^	char *GetAltLoc();$/;"	p	class:CXYPDBAtom	access:public	signature:()
CXYPDBAtom::GetAtomicSym	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetAtomicSym()$/;"	f	class:CXYPDBAtom	signature:()
CXYPDBAtom::GetAtomicSym	XYPDBAtom.h	/^	char *GetAtomicSym();$/;"	p	class:CXYPDBAtom	access:public	signature:()
CXYPDBAtom::GetBranchDes	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetBranchDes()$/;"	f	class:CXYPDBAtom	signature:()
CXYPDBAtom::GetBranchDes	XYPDBAtom.h	/^	char *GetBranchDes();$/;"	p	class:CXYPDBAtom	access:public	signature:()
CXYPDBAtom::GetChainID	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetChainID()$/;"	f	class:CXYPDBAtom	signature:()
CXYPDBAtom::GetChainID	XYPDBAtom.h	/^	char *GetChainID();$/;"	p	class:CXYPDBAtom	access:public	signature:()
CXYPDBAtom::GetCharge	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetCharge()$/;"	f	class:CXYPDBAtom	signature:()
CXYPDBAtom::GetCharge	XYPDBAtom.h	/^	char *GetCharge();$/;"	p	class:CXYPDBAtom	access:public	signature:()
CXYPDBAtom::GetElement	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetElement()$/;"	f	class:CXYPDBAtom	signature:()
CXYPDBAtom::GetElement	XYPDBAtom.h	/^	char *GetElement();$/;"	p	class:CXYPDBAtom	access:public	signature:()
CXYPDBAtom::GetICode	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetICode()$/;"	f	class:CXYPDBAtom	signature:()
CXYPDBAtom::GetICode	XYPDBAtom.h	/^	char *GetICode();$/;"	p	class:CXYPDBAtom	access:public	signature:()
CXYPDBAtom::GetName	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetName()$/;"	f	class:CXYPDBAtom	signature:()
CXYPDBAtom::GetName	XYPDBAtom.h	/^	char *GetName();$/;"	p	class:CXYPDBAtom	access:public	signature:()
CXYPDBAtom::GetOccupancy	XYPDBAtom.cpp	/^float CXYPDBAtom::GetOccupancy()$/;"	f	class:CXYPDBAtom	signature:()
CXYPDBAtom::GetOccupancy	XYPDBAtom.h	/^	float GetOccupancy();$/;"	p	class:CXYPDBAtom	access:public	signature:()
CXYPDBAtom::GetPoint	XYPDBAtom.cpp	/^CXYPoint3D<float> CXYPDBAtom::GetPoint() const$/;"	f	class:CXYPDBAtom	signature:() const
CXYPDBAtom::GetPoint	XYPDBAtom.h	/^	CXYPoint3D<float> GetPoint() const;$/;"	p	class:CXYPDBAtom	access:public	signature:() const
CXYPDBAtom::GetRecName	XYPDBAtom.cpp	/^char * CXYPDBAtom::GetRecName()$/;"	f	class:CXYPDBAtom	signature:()
CXYPDBAtom::GetRecName	XYPDBAtom.h	/^	char *GetRecName();$/;"	p	class:CXYPDBAtom	access:public	signature:()
CXYPDBAtom::GetRemoteInd	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetRemoteInd()$/;"	f	class:CXYPDBAtom	signature:()
CXYPDBAtom::GetRemoteInd	XYPDBAtom.h	/^	char *GetRemoteInd();$/;"	p	class:CXYPDBAtom	access:public	signature:()
CXYPDBAtom::GetResName	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetResName()$/;"	f	class:CXYPDBAtom	signature:()
CXYPDBAtom::GetResName	XYPDBAtom.h	/^	char *GetResName();$/;"	p	class:CXYPDBAtom	access:public	signature:()
CXYPDBAtom::GetResSeq	XYPDBAtom.cpp	/^int CXYPDBAtom::GetResSeq()$/;"	f	class:CXYPDBAtom	signature:()
CXYPDBAtom::GetResSeq	XYPDBAtom.h	/^	int GetResSeq();$/;"	p	class:CXYPDBAtom	access:public	signature:()
CXYPDBAtom::GetSegID	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetSegID()$/;"	f	class:CXYPDBAtom	signature:()
CXYPDBAtom::GetSegID	XYPDBAtom.h	/^	char *GetSegID();$/;"	p	class:CXYPDBAtom	access:public	signature:()
CXYPDBAtom::GetSerial	XYPDBAtom.cpp	/^int	CXYPDBAtom::GetSerial()$/;"	f	class:CXYPDBAtom	signature:()
CXYPDBAtom::GetSerial	XYPDBAtom.h	/^	int	GetSerial();$/;"	p	class:CXYPDBAtom	access:public	signature:()
CXYPDBAtom::GetTempFactor	XYPDBAtom.cpp	/^float CXYPDBAtom::GetTempFactor()$/;"	f	class:CXYPDBAtom	signature:()
CXYPDBAtom::GetTempFactor	XYPDBAtom.h	/^	float GetTempFactor();$/;"	p	class:CXYPDBAtom	access:public	signature:()
CXYPDBAtom::GetX	XYPDBAtom.cpp	/^float CXYPDBAtom::GetX()$/;"	f	class:CXYPDBAtom	signature:()
CXYPDBAtom::GetX	XYPDBAtom.h	/^	float GetX();$/;"	p	class:CXYPDBAtom	access:public	signature:()
CXYPDBAtom::GetY	XYPDBAtom.cpp	/^float CXYPDBAtom::GetY()$/;"	f	class:CXYPDBAtom	signature:()
CXYPDBAtom::GetY	XYPDBAtom.h	/^	float GetY();$/;"	p	class:CXYPDBAtom	access:public	signature:()
CXYPDBAtom::GetZ	XYPDBAtom.cpp	/^float CXYPDBAtom::GetZ()$/;"	f	class:CXYPDBAtom	signature:()
CXYPDBAtom::GetZ	XYPDBAtom.h	/^	float GetZ();$/;"	p	class:CXYPDBAtom	access:public	signature:()
CXYPDBAtom::Initialize	XYPDBAtom.cpp	/^void CXYPDBAtom::Initialize(void)$/;"	f	class:CXYPDBAtom	signature:(void)
CXYPDBAtom::Initialize	XYPDBAtom.h	/^	void Initialize(void);$/;"	p	class:CXYPDBAtom	access:public	signature:(void)
CXYPDBAtom::ReadLine	XYPDBAtom.cpp	/^void CXYPDBAtom::ReadLine(const char *acBuffLine)$/;"	f	class:CXYPDBAtom	signature:(const char *acBuffLine)
CXYPDBAtom::ReadLine	XYPDBAtom.h	/^	void ReadLine(const char *acBuffLine);$/;"	p	class:CXYPDBAtom	access:public	signature:(const char *acBuffLine)
CXYPDBAtom::SetAltLoc	XYPDBAtom.cpp	/^void CXYPDBAtom::SetAltLoc(char *acAltLoc)$/;"	f	class:CXYPDBAtom	signature:(char *acAltLoc)
CXYPDBAtom::SetAltLoc	XYPDBAtom.h	/^	void SetAltLoc(char *acAltLoc);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acAltLoc)
CXYPDBAtom::SetAtomicSym	XYPDBAtom.cpp	/^void CXYPDBAtom::SetAtomicSym(char *acAtomicSym)$/;"	f	class:CXYPDBAtom	signature:(char *acAtomicSym)
CXYPDBAtom::SetAtomicSym	XYPDBAtom.h	/^	void SetAtomicSym(char *acAtomicSym);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acAtomicSym)
CXYPDBAtom::SetBranchDes	XYPDBAtom.cpp	/^void CXYPDBAtom::SetBranchDes(char *acBranchDes)$/;"	f	class:CXYPDBAtom	signature:(char *acBranchDes)
CXYPDBAtom::SetBranchDes	XYPDBAtom.h	/^	void SetBranchDes(char *acBranchDes);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acBranchDes)
CXYPDBAtom::SetChainID	XYPDBAtom.cpp	/^void CXYPDBAtom::SetChainID(char *acChainID)$/;"	f	class:CXYPDBAtom	signature:(char *acChainID)
CXYPDBAtom::SetChainID	XYPDBAtom.h	/^	void SetChainID(char *acChainID);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acChainID)
CXYPDBAtom::SetCharge	XYPDBAtom.cpp	/^void CXYPDBAtom::SetCharge(char *acCharge)$/;"	f	class:CXYPDBAtom	signature:(char *acCharge)
CXYPDBAtom::SetCharge	XYPDBAtom.h	/^	void SetCharge(char *acCharge);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acCharge)
CXYPDBAtom::SetElement	XYPDBAtom.cpp	/^void CXYPDBAtom::SetElement(char *acElement)$/;"	f	class:CXYPDBAtom	signature:(char *acElement)
CXYPDBAtom::SetElement	XYPDBAtom.h	/^	void SetElement(char *acElement);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acElement)
CXYPDBAtom::SetICode	XYPDBAtom.cpp	/^void CXYPDBAtom::SetICode(char *acICode)$/;"	f	class:CXYPDBAtom	signature:(char *acICode)
CXYPDBAtom::SetICode	XYPDBAtom.h	/^	void SetICode(char *acICode);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acICode)
CXYPDBAtom::SetName	XYPDBAtom.cpp	/^void CXYPDBAtom::SetName(char *acAtom)$/;"	f	class:CXYPDBAtom	signature:(char *acAtom)
CXYPDBAtom::SetName	XYPDBAtom.h	/^	void SetName(char *acAtom);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acAtom)
CXYPDBAtom::SetOccupancy	XYPDBAtom.cpp	/^void CXYPDBAtom::SetOccupancy(float fOccupancy)$/;"	f	class:CXYPDBAtom	signature:(float fOccupancy)
CXYPDBAtom::SetOccupancy	XYPDBAtom.h	/^	void SetOccupancy(float fOccupancy);$/;"	p	class:CXYPDBAtom	access:public	signature:(float fOccupancy)
CXYPDBAtom::SetPoint	XYPDBAtom.cpp	/^void CXYPDBAtom::SetPoint(const CXYPoint3Df& rP)$/;"	f	class:CXYPDBAtom	signature:(const CXYPoint3Df& rP)
CXYPDBAtom::SetPoint	XYPDBAtom.h	/^	void SetPoint(const CXYPoint3Df& rP);$/;"	p	class:CXYPDBAtom	access:public	signature:(const CXYPoint3Df& rP)
CXYPDBAtom::SetRecName	XYPDBAtom.cpp	/^void CXYPDBAtom::SetRecName(char *acRecName)$/;"	f	class:CXYPDBAtom	signature:(char *acRecName)
CXYPDBAtom::SetRecName	XYPDBAtom.h	/^	void SetRecName(char *acRecName);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acRecName)
CXYPDBAtom::SetRemoteInd	XYPDBAtom.cpp	/^void CXYPDBAtom::SetRemoteInd(char *acRemoteInd)$/;"	f	class:CXYPDBAtom	signature:(char *acRemoteInd)
CXYPDBAtom::SetRemoteInd	XYPDBAtom.h	/^	void SetRemoteInd(char *acRemoteInd);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acRemoteInd)
CXYPDBAtom::SetResName	XYPDBAtom.cpp	/^void CXYPDBAtom::SetResName(char *acResName)$/;"	f	class:CXYPDBAtom	signature:(char *acResName)
CXYPDBAtom::SetResName	XYPDBAtom.h	/^	void SetResName(char *acResName);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acResName)
CXYPDBAtom::SetResSeq	XYPDBAtom.cpp	/^void CXYPDBAtom::SetResSeq(int iResSeq)$/;"	f	class:CXYPDBAtom	signature:(int iResSeq)
CXYPDBAtom::SetResSeq	XYPDBAtom.h	/^	void SetResSeq(int iResSeq);$/;"	p	class:CXYPDBAtom	access:public	signature:(int iResSeq)
CXYPDBAtom::SetSegID	XYPDBAtom.cpp	/^void CXYPDBAtom::SetSegID(char *acSegID)$/;"	f	class:CXYPDBAtom	signature:(char *acSegID)
CXYPDBAtom::SetSegID	XYPDBAtom.h	/^	void SetSegID(char *acSegID);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acSegID)
CXYPDBAtom::SetSerial	XYPDBAtom.cpp	/^void CXYPDBAtom::SetSerial(int iSerial)$/;"	f	class:CXYPDBAtom	signature:(int iSerial)
CXYPDBAtom::SetSerial	XYPDBAtom.h	/^	void SetSerial(int iSerial);$/;"	p	class:CXYPDBAtom	access:public	signature:(int iSerial)
CXYPDBAtom::SetTempFactor	XYPDBAtom.cpp	/^void CXYPDBAtom::SetTempFactor(float fTempFactor)$/;"	f	class:CXYPDBAtom	signature:(float fTempFactor)
CXYPDBAtom::SetTempFactor	XYPDBAtom.h	/^	void SetTempFactor(float fTempFactor);$/;"	p	class:CXYPDBAtom	access:public	signature:(float fTempFactor)
CXYPDBAtom::SetX	XYPDBAtom.cpp	/^void CXYPDBAtom::SetX(float fX)$/;"	f	class:CXYPDBAtom	signature:(float fX)
CXYPDBAtom::SetX	XYPDBAtom.h	/^	void SetX(float fX);$/;"	p	class:CXYPDBAtom	access:public	signature:(float fX)
CXYPDBAtom::SetY	XYPDBAtom.cpp	/^void CXYPDBAtom::SetY(float fY)$/;"	f	class:CXYPDBAtom	signature:(float fY)
CXYPDBAtom::SetY	XYPDBAtom.h	/^	void SetY(float fY);$/;"	p	class:CXYPDBAtom	access:public	signature:(float fY)
CXYPDBAtom::SetZ	XYPDBAtom.cpp	/^void CXYPDBAtom::SetZ(float fZ)$/;"	f	class:CXYPDBAtom	signature:(float fZ)
CXYPDBAtom::SetZ	XYPDBAtom.h	/^	void SetZ(float fZ);$/;"	p	class:CXYPDBAtom	access:public	signature:(float fZ)
CXYPDBAtom::m_acAltLoc	XYPDBAtom.h	/^	char	m_acAltLoc[2];	\/\/ 17           Character        altLoc     Alternate location indicator.$/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::m_acAtom	XYPDBAtom.h	/^	char	m_acAtom[5];		\/\/ 13 - 16      Atom             name       Atom name.$/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::m_acAtomicSym	XYPDBAtom.h	/^	char	m_acAtomicSym[3];	\/\/ 13-14  $/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::m_acBranchDes	XYPDBAtom.h	/^	char	m_acBranchDes[2]; \/\/ 16$/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::m_acChainID	XYPDBAtom.h	/^	char	m_acChainID[2];	\/\/ 22           Character        chainID    Chain identifier.$/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::m_acCharge	XYPDBAtom.h	/^	char	m_acCharge[3];	\/\/ 79 - 80      LString(2)       charge     Charge on the atom.$/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::m_acElement	XYPDBAtom.h	/^	char	m_acElement[3];	\/\/ 77 - 78      LString(2)       element    Element symbol, right-justified.$/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::m_acICode	XYPDBAtom.h	/^	char	m_acICode[2];		\/\/ 27           AChar            iCode      Code for insertion of residues.$/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::m_acRecName	XYPDBAtom.h	/^	char	m_acRecName[7];	\/\/ 1 -  6      Record name      "ATOM    "$/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::m_acRemoteInd	XYPDBAtom.h	/^	char	m_acRemoteInd[2]; \/\/ 15$/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::m_acResName	XYPDBAtom.h	/^	char	m_acResName[4];	\/\/ 18 - 20      Residue name     resName    Residue name.$/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::m_acSegID	XYPDBAtom.h	/^	char	m_acSegID[5];	\/\/ 73 - 76		LString(4)		segment identifier, left-justified. [format version 2.0 and later.]$/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::m_fOccupancy	XYPDBAtom.h	/^	float	m_fOccupancy;	\/\/ 55 - 60      Real(6.2)        occupancy  Occupancy.$/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::m_fTempFactor	XYPDBAtom.h	/^	float	m_fTempFactor;	\/\/ 61 - 66      Real(6.2)        tempFactor Temperature factor.$/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::m_fX	XYPDBAtom.h	/^	float	m_fX;			\/\/ 31 - 38      Real(8.3)        x          Orthogonal coordinates for X in Angstroms$/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::m_fY	XYPDBAtom.h	/^	float	m_fY;			\/\/ 39 - 46      Real(8.3)        y          Orthogonal coordinates for Y in Angstroms$/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::m_fZ	XYPDBAtom.h	/^	float	m_fZ;			\/\/ 47 - 54      Real(8.3)        z          Orthogonal coordinates for Z in Angstroms$/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::m_iResSeq	XYPDBAtom.h	/^	int		m_iResSeq;		\/\/ 23 - 26      Integer          resSeq     Residue sequence number.$/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::m_iSerial	XYPDBAtom.h	/^	int		m_iSerial;		\/\/ 7 - 11      Integer          serial     Atom serial number.$/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::m_point	XYPDBAtom.h	/^	CXYPoint3Df m_point;$/;"	m	class:CXYPDBAtom	access:private
CXYPDBAtom::~CXYPDBAtom	XYPDBAtom.cpp	/^CXYPDBAtom::~CXYPDBAtom(void)$/;"	f	class:CXYPDBAtom	signature:(void)
CXYPDBAtom::~CXYPDBAtom	XYPDBAtom.h	/^	~CXYPDBAtom(void);$/;"	p	class:CXYPDBAtom	access:public	signature:(void)
CXYPoint3D	XYPoint3D.h	/^	CXYPoint3D(Real fX, Real fY, Real fZ);$/;"	p	class:CXYPoint3D	access:public	signature:(Real fX, Real fY, Real fZ)
CXYPoint3D	XYPoint3D.h	/^	CXYPoint3D(void);$/;"	p	class:CXYPoint3D	access:public	signature:(void)
CXYPoint3D	XYPoint3D.h	/^class CXYPoint3D$/;"	c
CXYPoint3D	XYPoint3D.inl	/^CXYPoint3D<Real>::CXYPoint3D(Real fX, Real fY, Real fZ)$/;"	f	class:CXYPoint3D	signature:(Real fX, Real fY, Real fZ)
CXYPoint3D	XYPoint3D.inl	/^CXYPoint3D<Real>::CXYPoint3D(void)$/;"	f	class:CXYPoint3D	signature:(void)
CXYPoint3D::CXYPoint3D	XYPoint3D.h	/^	CXYPoint3D(Real fX, Real fY, Real fZ);$/;"	p	class:CXYPoint3D	access:public	signature:(Real fX, Real fY, Real fZ)
CXYPoint3D::CXYPoint3D	XYPoint3D.h	/^	CXYPoint3D(void);$/;"	p	class:CXYPoint3D	access:public	signature:(void)
CXYPoint3D::CXYPoint3D	XYPoint3D.inl	/^CXYPoint3D<Real>::CXYPoint3D(Real fX, Real fY, Real fZ)$/;"	f	class:CXYPoint3D	signature:(Real fX, Real fY, Real fZ)
CXYPoint3D::CXYPoint3D	XYPoint3D.inl	/^CXYPoint3D<Real>::CXYPoint3D(void)$/;"	f	class:CXYPoint3D	signature:(void)
CXYPoint3D::CompareArrays	XYPoint3D.h	/^	int CompareArrays (const CXYPoint3D& rP) const;$/;"	p	class:CXYPoint3D	access:private	signature:(const CXYPoint3D& rP) const
CXYPoint3D::CompareArrays	XYPoint3D.inl	/^int CXYPoint3D<Real>::CompareArrays (const CXYPoint3D& rP) const$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP) const
CXYPoint3D::Length	XYPoint3D.h	/^    Real Length () const;$/;"	p	class:CXYPoint3D	access:public	signature:() const
CXYPoint3D::Length	XYPoint3D.inl	/^Real CXYPoint3D<Real>::Length () const$/;"	f	class:CXYPoint3D	signature:() const
CXYPoint3D::SquaredLength	XYPoint3D.h	/^	Real SquaredLength () const;$/;"	p	class:CXYPoint3D	access:public	signature:() const
CXYPoint3D::SquaredLength	XYPoint3D.inl	/^Real CXYPoint3D<Real>::SquaredLength () const$/;"	f	class:CXYPoint3D	signature:() const
CXYPoint3D::X	XYPoint3D.h	/^	Real X () const;$/;"	p	class:CXYPoint3D	access:public	signature:() const
CXYPoint3D::X	XYPoint3D.h	/^	Real& X ();$/;"	p	class:CXYPoint3D	access:public	signature:()
CXYPoint3D::X	XYPoint3D.inl	/^Real CXYPoint3D<Real>::X () const$/;"	f	class:CXYPoint3D	signature:() const
CXYPoint3D::X	XYPoint3D.inl	/^Real& CXYPoint3D<Real>::X ()$/;"	f	class:CXYPoint3D	signature:()
CXYPoint3D::Y	XYPoint3D.h	/^	Real Y () const;$/;"	p	class:CXYPoint3D	access:public	signature:() const
CXYPoint3D::Y	XYPoint3D.h	/^	Real& Y ();$/;"	p	class:CXYPoint3D	access:public	signature:()
CXYPoint3D::Y	XYPoint3D.inl	/^Real CXYPoint3D<Real>::Y () const$/;"	f	class:CXYPoint3D	signature:() const
CXYPoint3D::Y	XYPoint3D.inl	/^Real& CXYPoint3D<Real>::Y ()$/;"	f	class:CXYPoint3D	signature:()
CXYPoint3D::Z	XYPoint3D.h	/^	Real Z () const;$/;"	p	class:CXYPoint3D	access:public	signature:() const
CXYPoint3D::Z	XYPoint3D.h	/^	Real& Z ();$/;"	p	class:CXYPoint3D	access:public	signature:()
CXYPoint3D::Z	XYPoint3D.inl	/^Real CXYPoint3D<Real>::Z () const$/;"	f	class:CXYPoint3D	signature:() const
CXYPoint3D::Z	XYPoint3D.inl	/^Real& CXYPoint3D<Real>::Z ()$/;"	f	class:CXYPoint3D	signature:()
CXYPoint3D::operator !=	XYPoint3D.h	/^    bool operator!= (const CXYPoint3D& rP) const;$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP) const
CXYPoint3D::operator !=	XYPoint3D.inl	/^bool CXYPoint3D<Real>::operator!= (const CXYPoint3D& rP) const$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP) const
CXYPoint3D::operator *	XYPoint3D.h	/^    CXYPoint3D operator* (Real fScalar) const;$/;"	p	class:CXYPoint3D	access:public	signature:(Real fScalar) const
CXYPoint3D::operator *	XYPoint3D.inl	/^CXYPoint3D<Real> CXYPoint3D<Real>::operator* (Real fScalar) const$/;"	f	class:CXYPoint3D	signature:(Real fScalar) const
CXYPoint3D::operator *=	XYPoint3D.h	/^	CXYPoint3D& operator*= (Real fScalar);$/;"	p	class:CXYPoint3D	access:public	signature:(Real fScalar)
CXYPoint3D::operator *=	XYPoint3D.inl	/^CXYPoint3D<Real>& CXYPoint3D<Real>::operator*= (Real fScalar)$/;"	f	class:CXYPoint3D	signature:(Real fScalar)
CXYPoint3D::operator +	XYPoint3D.h	/^    CXYPoint3D operator+ (const CXYPoint3D& rP) const;$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP) const
CXYPoint3D::operator +	XYPoint3D.inl	/^CXYPoint3D<Real> CXYPoint3D<Real>::operator+ (const CXYPoint3D& rP) const$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP) const
CXYPoint3D::operator +=	XYPoint3D.h	/^	CXYPoint3D& operator+= (const CXYPoint3D& rP);$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP)
CXYPoint3D::operator +=	XYPoint3D.inl	/^CXYPoint3D<Real>& CXYPoint3D<Real>::operator+= (const CXYPoint3D& rP)$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP)
CXYPoint3D::operator -	XYPoint3D.h	/^    CXYPoint3D operator- () const;$/;"	p	class:CXYPoint3D	access:public	signature:() const
CXYPoint3D::operator -	XYPoint3D.h	/^    CXYPoint3D operator- (const CXYPoint3D& rP) const;$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP) const
CXYPoint3D::operator -	XYPoint3D.inl	/^CXYPoint3D<Real> CXYPoint3D<Real>::operator- () const$/;"	f	class:CXYPoint3D	signature:() const
CXYPoint3D::operator -	XYPoint3D.inl	/^CXYPoint3D<Real> CXYPoint3D<Real>::operator- (const CXYPoint3D& rP) const$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP) const
CXYPoint3D::operator -=	XYPoint3D.h	/^	CXYPoint3D& operator-= (const CXYPoint3D& rP);$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP)
CXYPoint3D::operator -=	XYPoint3D.inl	/^CXYPoint3D<Real>& CXYPoint3D<Real>::operator-= (const CXYPoint3D& rP)$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP)
CXYPoint3D::operator /	XYPoint3D.h	/^    CXYPoint3D operator\/ (Real fScalar) const;$/;"	p	class:CXYPoint3D	access:public	signature:(Real fScalar) const
CXYPoint3D::operator /	XYPoint3D.inl	/^CXYPoint3D<Real> CXYPoint3D<Real>::operator\/ (Real fScalar) const$/;"	f	class:CXYPoint3D	signature:(Real fScalar) const
CXYPoint3D::operator /=	XYPoint3D.h	/^	CXYPoint3D& operator\/= (Real fScalar);$/;"	p	class:CXYPoint3D	access:public	signature:(Real fScalar)
CXYPoint3D::operator /=	XYPoint3D.inl	/^CXYPoint3D<Real>& CXYPoint3D<Real>::operator\/= (Real fScalar)$/;"	f	class:CXYPoint3D	signature:(Real fScalar)
CXYPoint3D::operator <	XYPoint3D.h	/^    bool operator<  (const CXYPoint3D& rP) const;$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP) const
CXYPoint3D::operator <	XYPoint3D.inl	/^bool CXYPoint3D<Real>::operator< (const CXYPoint3D& rP) const$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP) const
CXYPoint3D::operator <=	XYPoint3D.h	/^    bool operator<= (const CXYPoint3D& rP) const;$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP) const
CXYPoint3D::operator <=	XYPoint3D.inl	/^bool CXYPoint3D<Real>::operator<= (const CXYPoint3D& rP) const$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP) const
CXYPoint3D::operator =	XYPoint3D.h	/^    CXYPoint3D& operator= (const CXYPoint3D& rP);$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP)
CXYPoint3D::operator =	XYPoint3D.inl	/^CXYPoint3D<Real>& CXYPoint3D<Real>::operator= (const CXYPoint3D& rP)$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP)
CXYPoint3D::operator ==	XYPoint3D.h	/^    bool operator== (const CXYPoint3D& rP) const;$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP) const
CXYPoint3D::operator ==	XYPoint3D.inl	/^bool CXYPoint3D<Real>::operator== (const CXYPoint3D& rP) const$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP) const
CXYPoint3D::operator >	XYPoint3D.h	/^    bool operator>  (const CXYPoint3D& rP) const;$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP) const
CXYPoint3D::operator >	XYPoint3D.inl	/^bool CXYPoint3D<Real>::operator> (const CXYPoint3D& rP) const$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP) const
CXYPoint3D::operator >=	XYPoint3D.h	/^    bool operator>= (const CXYPoint3D& rP) const;$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP) const
CXYPoint3D::operator >=	XYPoint3D.inl	/^bool CXYPoint3D<Real>::operator>= (const CXYPoint3D& rP) const$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP) const
CXYPoint3D::operator Real*	XYPoint3D.h	/^	operator Real* ();$/;"	p	class:CXYPoint3D	access:public	signature:()
CXYPoint3D::operator Real*	XYPoint3D.inl	/^CXYPoint3D<Real>::operator Real* ()$/;"	f	class:CXYPoint3D	signature:()
CXYPoint3D::operator []	XYPoint3D.h	/^	Real operator[] (int i) const;$/;"	p	class:CXYPoint3D	access:public	signature:(int i) const
CXYPoint3D::operator []	XYPoint3D.h	/^	Real& operator[] (int i);$/;"	p	class:CXYPoint3D	access:public	signature:(int i)
CXYPoint3D::operator []	XYPoint3D.inl	/^Real CXYPoint3D<Real>::operator[] (int i) const$/;"	f	class:CXYPoint3D	signature:(int i) const
CXYPoint3D::operator []	XYPoint3D.inl	/^Real& CXYPoint3D<Real>::operator[] (int i)$/;"	f	class:CXYPoint3D	signature:(int i)
CXYPoint3D::operator const Real*	XYPoint3D.h	/^	operator const Real* () const;$/;"	p	class:CXYPoint3D	access:public	signature:() const
CXYPoint3D::operator const Real*	XYPoint3D.inl	/^CXYPoint3D<Real>::operator const Real* () const$/;"	f	class:CXYPoint3D	signature:() const
CXYPoint3D::point_	XYPoint3D.h	/^	Real point_[3];$/;"	m	class:CXYPoint3D	access:private
CXYPoint3D::~CXYPoint3D	XYPoint3D.h	/^	~CXYPoint3D(void);$/;"	p	class:CXYPoint3D	access:public	signature:(void)
CXYPoint3D::~CXYPoint3D	XYPoint3D.inl	/^CXYPoint3D<Real>::~CXYPoint3D(void)$/;"	f	class:CXYPoint3D	signature:(void)
CXYPoint3Dd	XYPoint3D.h	/^typedef CXYPoint3D<double> CXYPoint3Dd;$/;"	t
CXYPoint3Df	XYPoint3D.h	/^typedef CXYPoint3D<float> CXYPoint3Df;$/;"	t
CXYSIS	XYSIS.cpp	/^CXYSIS::CXYSIS($/;"	f	class:CXYSIS	signature:( char* cOutPath, float fPersistenLength, float fCollisionLength, float fCutoff, float fPackingDensity, float fNucleusSphereDiameter, int iNumNodes, int iNumSamplePoints, char* cStartEndFile, int iMmax, float fRho_1, float fRho_2, float fRho_3, float fTau_t, float fAdjust, char* cPvalFile, char* cContIndFile, char* cDistQuantFile)
CXYSIS	XYSIS.cpp	/^CXYSIS::CXYSIS()$/;"	f	class:CXYSIS	signature:()
CXYSIS	XYSIS.h	/^  CXYSIS($/;"	p	class:CXYSIS	access:public	signature:( char* cOutPath, float fPersistenLength, float fCollisionLength, float fCutoff, float fPackingDensity, float fNucleusSphereDiameter, int iNumNodes, int iNumSamplePoints, char* cStartEndFile, int iMmax, float fRho_1, float fRho_2, float fRho_3, float fTau_t, float fAdjust, char* cPvalFile, char* cContIndFile, char* cDistQuantFile)
CXYSIS	XYSIS.h	/^  CXYSIS();$/;"	p	class:CXYSIS	access:public	signature:()
CXYSIS	XYSIS.h	/^class CXYSIS{$/;"	c
CXYSIS::BinSearchConstC	XYSIS.cpp	/^float CXYSIS::BinSearchConstC(vector<float>& vfBeta_t)$/;"	f	class:CXYSIS	signature:(vector<float>& vfBeta_t)
CXYSIS::BinSearchConstC	XYSIS.h	/^  float BinSearchConstC(vector<float>& vfBeta_t);$/;"	p	class:CXYSIS	access:public	signature:(vector<float>& vfBeta_t)
CXYSIS::CXYSIS	XYSIS.cpp	/^CXYSIS::CXYSIS($/;"	f	class:CXYSIS	signature:( char* cOutPath, float fPersistenLength, float fCollisionLength, float fCutoff, float fPackingDensity, float fNucleusSphereDiameter, int iNumNodes, int iNumSamplePoints, char* cStartEndFile, int iMmax, float fRho_1, float fRho_2, float fRho_3, float fTau_t, float fAdjust, char* cPvalFile, char* cContIndFile, char* cDistQuantFile)
CXYSIS::CXYSIS	XYSIS.cpp	/^CXYSIS::CXYSIS()$/;"	f	class:CXYSIS	signature:()
CXYSIS::CXYSIS	XYSIS.h	/^  CXYSIS($/;"	p	class:CXYSIS	access:public	signature:( char* cOutPath, float fPersistenLength, float fCollisionLength, float fCutoff, float fPackingDensity, float fNucleusSphereDiameter, int iNumNodes, int iNumSamplePoints, char* cStartEndFile, int iMmax, float fRho_1, float fRho_2, float fRho_3, float fTau_t, float fAdjust, char* cPvalFile, char* cContIndFile, char* cDistQuantFile)
CXYSIS::CXYSIS	XYSIS.h	/^  CXYSIS();$/;"	p	class:CXYSIS	access:public	signature:()
CXYSIS::CalBeta_t	XYSIS.cpp	/^float CXYSIS::CalBeta_t(CXYMatrix<float> &kM)$/;"	f	class:CXYSIS	signature:(CXYMatrix<float> &kM)
CXYSIS::CalBeta_t	XYSIS.h	/^  float CalBeta_t(CXYMatrix<float> &kM);$/;"	p	class:CXYSIS	access:public	signature:(CXYMatrix<float> &kM)
CXYSIS::CalBeta_t_ByVector	XYSIS.cpp	/^void CXYSIS::CalBeta_t_ByVector(vector< vector<tree<CXYVector<float> >::iterator >* >& rvvChains, int iSegInd, vector<float>& rvfBeta_t){$/;"	f	class:CXYSIS	signature:(vector< vector<tree<CXYVector<float> >::iterator >* >& rvvChains, int iSegInd, vector<float>& rvfBeta_t)
CXYSIS::CalBeta_t_ByVector	XYSIS.h	/^  void CalBeta_t_ByVector(vector< vector<tree<CXYVector<float> >::iterator >* >& rvvChains,  int iSegInd, vector<float>& rvfBeta_t);$/;"	p	class:CXYSIS	access:public	signature:(vector< vector<tree<CXYVector<float> >::iterator >* >& rvvChains, int iSegInd, vector<float>& rvfBeta_t)
CXYSIS::FindContactStartEndSegIndFromSegInd	XYSIS.cpp	/^void CXYSIS::FindContactStartEndSegIndFromSegInd(int iSegInd, vector<vector<int> > & vStartEndInd){$/;"	f	class:CXYSIS	signature:(int iSegInd, vector<vector<int> > & vStartEndInd)
CXYSIS::FindContactStartEndSegIndFromSegInd	XYSIS.h	/^  void FindContactStartEndSegIndFromSegInd(int iSegInd, vector<vector<int> > & vStartEndInd);$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd, vector<vector<int> > & vStartEndInd)
CXYSIS::FindContactStartEndSegIndFromSegInd_2	XYSIS.cpp	/^void CXYSIS::FindContactStartEndSegIndFromSegInd_2(int iSegInd, vector<vector<int> > & vStartEndInd){$/;"	f	class:CXYSIS	signature:(int iSegInd, vector<vector<int> > & vStartEndInd)
CXYSIS::FindContactStartEndSegIndFromSegInd_2	XYSIS.h	/^  void FindContactStartEndSegIndFromSegInd_2(int iSegInd, vector<vector<int> > & vStartEndInd);$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd, vector<vector<int> > & vStartEndInd)
CXYSIS::FindContactionTypeFromSegSegInd	XYSIS.cpp	/^int CXYSIS::FindContactionTypeFromSegSegInd(int iSegInd1, int iSegInd2){$/;"	f	class:CXYSIS	signature:(int iSegInd1, int iSegInd2)
CXYSIS::FindContactionTypeFromSegSegInd	XYSIS.h	/^  int FindContactionTypeFromSegSegInd(int iSegInd1, int iSegInd2);$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd1, int iSegInd2)
CXYSIS::FindNodeStartEndIndFromSegInd	XYSIS.cpp	/^void CXYSIS::FindNodeStartEndIndFromSegInd($/;"	f	class:CXYSIS	signature:( int iSegInd, int& iNodeStartInd, int& iNodeEndInd)
CXYSIS::FindNodeStartEndIndFromSegInd	XYSIS.h	/^  void FindNodeStartEndIndFromSegInd(int iSegInd, $/;"	p	class:CXYSIS	access:public	signature:(int iSegInd, int& iNodeStartInd, int& iNodeEndInd)
CXYSIS::FindSegIndFromNodeInd	XYSIS.cpp	/^int CXYSIS::FindSegIndFromNodeInd(int iNodeInd){$/;"	f	class:CXYSIS	signature:(int iNodeInd)
CXYSIS::FindSegIndFromNodeInd	XYSIS.h	/^  int FindSegIndFromNodeInd(int iNodeInd);$/;"	p	class:CXYSIS	access:public	signature:(int iNodeInd)
CXYSIS::GetAjust	XYSIS.cpp	/^float CXYSIS::GetAjust(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GetAjust	XYSIS.h	/^  float GetAjust(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetBendingAngleBeg	XYSIS.h	/^  float GetBendingAngleBeg(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetBendingAngleEnd	XYSIS.h	/^  float GetBendingAngleEnd(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetCollisionLength	XYSIS.cpp	/^float CXYSIS::GetCollisionLength(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GetCollisionLength	XYSIS.h	/^  float GetCollisionLength(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetContactMap	XYSIS.cpp	/^map<int, float> CXYSIS::GetContactMap(int iNode){$/;"	f	class:CXYSIS	signature:(int iNode)
CXYSIS::GetContactMap	XYSIS.h	/^  map<int,float> GetContactMap(int iNode);$/;"	p	class:CXYSIS	access:public	signature:(int iNode)
CXYSIS::GetCountContactNode	XYSIS.h	/^  int GetCountContactNode(int iNode);$/;"	p	class:CXYSIS	access:public	signature:(int iNode)
CXYSIS::GetCountContactNode_All	XYSIS.h	/^  int GetCountContactNode_All(int iNode);$/;"	p	class:CXYSIS	access:public	signature:(int iNode)
CXYSIS::GetCountContactNodesFromMap	XYSIS.cpp	/^int CXYSIS::GetCountContactNodesFromMap(int ind){$/;"	f	class:CXYSIS	signature:(int ind)
CXYSIS::GetCountContactNodesFromMap	XYSIS.h	/^  int GetCountContactNodesFromMap(int ind);$/;"	p	class:CXYSIS	access:public	signature:(int ind)
CXYSIS::GetDistFileName	XYSIS.cpp	/^char* CXYSIS::GetDistFileName(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GetDistFileName	XYSIS.h	/^  char* GetDistFileName(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetDistMatrix	XYSIS.cpp	/^CXYMatrix<float>& CXYSIS::GetDistMatrix(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GetDistMatrix	XYSIS.h	/^  CXYMatrix<float>& GetDistMatrix(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetMiddlePoints	XYSIS.cpp	/^void CXYSIS::GetMiddlePoints(CXYVector<float>& StartPoint, CXYVector<float>& EndPoint, CXYMatrix<float> & MiddleEndPoints){$/;"	f	class:CXYSIS	signature:(CXYVector<float>& StartPoint, CXYVector<float>& EndPoint, CXYMatrix<float> & MiddleEndPoints)
CXYSIS::GetMiddlePoints	XYSIS.h	/^  void GetMiddlePoints(CXYVector<float>& StartPoint, CXYVector<float>& EndPoint, CXYMatrix<float> & MiddleEndPoints);$/;"	p	class:CXYSIS	access:public	signature:(CXYVector<float>& StartPoint, CXYVector<float>& EndPoint, CXYMatrix<float> & MiddleEndPoints)
CXYSIS::GetMmax	XYSIS.cpp	/^int CXYSIS::GetMmax(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GetMmax	XYSIS.h	/^  int GetMmax(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetNoConMaxDist	XYSIS.cpp	/^float CXYSIS::GetNoConMaxDist(int iSegInd){$/;"	f	class:CXYSIS	signature:(int iSegInd)
CXYSIS::GetNoConMaxDist	XYSIS.h	/^  float GetNoConMaxDist(int iSegInd);$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd)
CXYSIS::GetNodeNextPosition	XYSIS.cpp	/^CXYVector<float> CXYSIS::GetNodeNextPosition(tree<CXYVector<float> >::iterator  &ritNode, int iSegInd, int ind){$/;"	f	class:CXYSIS	signature:(tree<CXYVector<float> >::iterator &ritNode, int iSegInd, int ind)
CXYSIS::GetNodeNextPosition	XYSIS.h	/^  CXYVector<float> GetNodeNextPosition(tree<CXYVector<float> >::iterator  &ritNode, int iSegInd, int ind);$/;"	p	class:CXYSIS	access:public	signature:(tree<CXYVector<float> >::iterator &ritNode, int iSegInd, int ind)
CXYSIS::GetNodeSamples	XYSIS.cpp	/^CXYMatrix<float> CXYSIS::GetNodeSamples(tree<CXYVector<float> >::iterator  &ritNode, int iSegInd)$/;"	f	class:CXYSIS	signature:(tree<CXYVector<float> >::iterator &ritNode, int iSegInd)
CXYSIS::GetNodeSamples	XYSIS.h	/^  CXYMatrix<float> GetNodeSamples(tree<CXYVector<float> >::iterator  &itNode, int iSegInd);$/;"	p	class:CXYSIS	access:public	signature:(tree<CXYVector<float> >::iterator &itNode, int iSegInd)
CXYSIS::GetNodeSet	XYSIS.cpp	/^vector<tree<CXYVector<float> >::iterator > CXYSIS::GetNodeSet(int iLevel)$/;"	f	class:CXYSIS	signature:(int iLevel)
CXYSIS::GetNodeSet	XYSIS.h	/^  vector<tree<CXYVector<float> >::iterator > GetNodeSet(int iLevel);  $/;"	p	class:CXYSIS	access:public	signature:(int iLevel)
CXYSIS::GetNucleusSphereDiameter	XYSIS.cpp	/^float CXYSIS::GetNucleusSphereDiameter(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GetNucleusSphereDiameter	XYSIS.h	/^  float GetNucleusSphereDiameter(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetNumBendingAngle	XYSIS.h	/^  int GetNumBendingAngle(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetNumNodes	XYSIS.cpp	/^int CXYSIS::GetNumNodes(void){$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GetNumNodes	XYSIS.h	/^  int GetNumNodes(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetNumTorsionAngle	XYSIS.h	/^  int GetNumTorsionAngle(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetOneChain	XYSIS.cpp	/^void CXYSIS::GetOneChain(CXYMatrix<float>& rkM,$/;"	f	class:CXYSIS	signature:(CXYMatrix<float>& rkM, tree<CXYVector<float > >::iterator itNode)
CXYSIS::GetOneChain	XYSIS.h	/^  void GetOneChain(CXYMatrix<float>& rkM,$/;"	p	class:CXYSIS	access:public	signature:(CXYMatrix<float>& rkM, tree<CXYVector<float > >::iterator itNode)
CXYSIS::GetOutPath	XYSIS.cpp	/^char* CXYSIS::GetOutPath(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GetOutPath	XYSIS.h	/^  char* GetOutPath(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetPackingDensity	XYSIS.cpp	/^float CXYSIS::GetPackingDensity(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GetPackingDensity	XYSIS.h	/^  float GetPackingDensity(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetPersistenceLength	XYSIS.cpp	/^float CXYSIS::GetPersistenceLength(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GetPersistenceLength	XYSIS.h	/^  float GetPersistenceLength(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetPrvConPosition	XYSIS.cpp	/^CXYVector<float> CXYSIS::GetPrvConPosition(tree<CXYVector<float> >::iterator  &ritNode, int iSegInd){$/;"	f	class:CXYSIS	signature:(tree<CXYVector<float> >::iterator &ritNode, int iSegInd)
CXYSIS::GetPrvConPosition	XYSIS.h	/^  CXYVector<float> GetPrvConPosition(tree<CXYVector<float> >::iterator  &ritNode, int iSegInd);$/;"	p	class:CXYSIS	access:public	signature:(tree<CXYVector<float> >::iterator &ritNode, int iSegInd)
CXYSIS::GetPrvContactNumberFromSegInd	XYSIS.cpp	/^int CXYSIS::GetPrvContactNumberFromSegInd(int iSegInd){$/;"	f	class:CXYSIS	signature:(int iSegInd)
CXYSIS::GetPrvContactNumberFromSegInd	XYSIS.h	/^  int GetPrvContactNumberFromSegInd(int iSegInd);$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd)
CXYSIS::GetPrvContactNumberFromSegInd_2	XYSIS.cpp	/^int CXYSIS::GetPrvContactNumberFromSegInd_2(int iSegInd){$/;"	f	class:CXYSIS	signature:(int iSegInd)
CXYSIS::GetPrvContactNumberFromSegInd_2	XYSIS.h	/^  int GetPrvContactNumberFromSegInd_2(int iSegInd);$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd)
CXYSIS::GetPrvContactSegIndsFromSegInd	XYSIS.cpp	/^vector<int> CXYSIS::GetPrvContactSegIndsFromSegInd(int iSegInd){$/;"	f	class:CXYSIS	signature:(int iSegInd)
CXYSIS::GetPrvContactSegIndsFromSegInd	XYSIS.h	/^  vector<int> GetPrvContactSegIndsFromSegInd(int iSegInd);$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd)
CXYSIS::GetPrvContactSegIndsFromSegInd_2	XYSIS.cpp	/^vector<int> CXYSIS::GetPrvContactSegIndsFromSegInd_2(int iSegInd){$/;"	f	class:CXYSIS	signature:(int iSegInd)
CXYSIS::GetPrvContactSegIndsFromSegInd_2	XYSIS.h	/^  vector<int> GetPrvContactSegIndsFromSegInd_2(int iSegInd);$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd)
CXYSIS::GetPrvContactsDistFromMap	XYSIS.cpp	/^CXYVector<float> CXYSIS::GetPrvContactsDistFromMap(int ind){$/;"	f	class:CXYSIS	signature:(int ind)
CXYSIS::GetPrvContactsDistFromMap	XYSIS.h	/^  CXYVector<float> GetPrvContactsDistFromMap(int ind);$/;"	p	class:CXYSIS	access:public	signature:(int ind)
CXYSIS::GetPrvContactsDist_2	XYSIS.cpp	/^CXYVector<float> CXYSIS::GetPrvContactsDist_2(int iSegInd){$/;"	f	class:CXYSIS	signature:(int iSegInd)
CXYSIS::GetPrvContactsDist_2	XYSIS.h	/^  CXYVector<float> GetPrvContactsDist_2(int iSegInd) ;$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd)
CXYSIS::GetPrvContactsListFromMap	XYSIS.cpp	/^vector<int> CXYSIS::GetPrvContactsListFromMap(int ind){ $/;"	f	class:CXYSIS	signature:(int ind)
CXYSIS::GetPrvContactsListFromMap	XYSIS.h	/^  vector<int> GetPrvContactsListFromMap(int ind);$/;"	p	class:CXYSIS	access:public	signature:(int ind)
CXYSIS::GetRho_1	XYSIS.cpp	/^float CXYSIS::GetRho_1(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GetRho_1	XYSIS.h	/^  float GetRho_1(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetRho_2	XYSIS.cpp	/^float CXYSIS::GetRho_2(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GetRho_2	XYSIS.h	/^  float GetRho_2(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetRho_3	XYSIS.cpp	/^float CXYSIS::GetRho_3(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GetRho_3	XYSIS.h	/^  float GetRho_3(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetRotMatrix	XYSIS.h	/^  CXYMatrix<float> GetRotMatrix(CXYMatrix<float> &rkMXYZ);$/;"	p	class:CXYSIS	access:public	signature:(CXYMatrix<float> &rkMXYZ)
CXYSIS::GetSamplesOrg	XYSIS.cpp	/^CXYMatrix<float> CXYSIS::GetSamplesOrg()$/;"	f	class:CXYSIS	signature:()
CXYSIS::GetSamplesOrg	XYSIS.h	/^  CXYMatrix<float> GetSamplesOrg();$/;"	p	class:CXYSIS	access:public	signature:()
CXYSIS::GetSegLength	XYSIS.cpp	/^float CXYSIS::GetSegLength(int ind){$/;"	f	class:CXYSIS	signature:(int ind)
CXYSIS::GetSegLength	XYSIS.h	/^  float GetSegLength(int ind);$/;"	p	class:CXYSIS	access:public	signature:(int ind)
CXYSIS::GetSegLengths	XYSIS.cpp	/^vector<float> & CXYSIS::GetSegLengths(void){$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GetSegLengths	XYSIS.h	/^  vector<float> & GetSegLengths(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetTargetDistribution	XYSIS.cpp	/^void CXYSIS::GetTargetDistribution(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GetTargetDistribution	XYSIS.h	/^  void GetTargetDistribution(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetTau_t	XYSIS.cpp	/^float CXYSIS::GetTau_t(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GetTau_t	XYSIS.h	/^  float GetTau_t(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetTorsionAngleBeg	XYSIS.h	/^  float GetTorsionAngleBeg(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetTorsionAngleEnd	XYSIS.h	/^  float GetTorsionAngleEnd(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GetTree	XYSIS.cpp	/^tree< CXYVector<float> >* CXYSIS::GetTree()$/;"	f	class:CXYSIS	signature:()
CXYSIS::GetTree	XYSIS.h	/^  tree< CXYVector<float> >* GetTree();$/;"	p	class:CXYSIS	access:public	signature:()
CXYSIS::GrowChainSegment_AllSelect	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_AllSelect($/;"	f	class:CXYSIS	signature:( vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
CXYSIS::GrowChainSegment_AllSelect	XYSIS.h	/^  void GrowChainSegment_AllSelect(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains,$/;"	p	class:CXYSIS	access:public	signature:(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
CXYSIS::GrowChainSegment_BinSearchConstC	XYSIS.cpp	/^float CXYSIS::GrowChainSegment_BinSearchConstC(vector<FloatIntPair>& vfBeta_t)$/;"	f	class:CXYSIS	signature:(vector<FloatIntPair>& vfBeta_t)
CXYSIS::GrowChainSegment_BinSearchConstC	XYSIS.h	/^  float GrowChainSegment_BinSearchConstC(vector<FloatIntPair>& vfBeta_t);$/;"	p	class:CXYSIS	access:public	signature:(vector<FloatIntPair>& vfBeta_t)
CXYSIS::GrowChainSegment_CalBeta_t	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_CalBeta_t($/;"	f	class:CXYSIS	signature:( vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, vector<FloatIntPair>& vBeta_t)
CXYSIS::GrowChainSegment_CalBeta_t	XYSIS.h	/^  void GrowChainSegment_CalBeta_t(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains,$/;"	p	class:CXYSIS	access:public	signature:(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, vector<FloatIntPair>& vBeta_t)
CXYSIS::GrowChainSegment_CalBeta_t_2	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_CalBeta_t_2($/;"	f	class:CXYSIS	signature:( vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, vector<FloatIntPair>& vBeta_t)
CXYSIS::GrowChainSegment_CalBeta_t_2	XYSIS.h	/^  void GrowChainSegment_CalBeta_t_2(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains,$/;"	p	class:CXYSIS	access:public	signature:(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, vector<FloatIntPair>& vBeta_t)
CXYSIS::GrowChainSegment_GeneratePotentialPoints	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_GeneratePotentialPoints($/;"	f	class:CXYSIS	signature:( tree<CXYVector<float> >& tree_LV, tree<CXYVector<float> >::iterator & pos_LV, vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iNodeInd)
CXYSIS::GrowChainSegment_GeneratePotentialPoints	XYSIS.h	/^  void GrowChainSegment_GeneratePotentialPoints(tree<CXYVector<float> >& tree_LV,$/;"	p	class:CXYSIS	access:public	signature:(tree<CXYVector<float> >& tree_LV, tree<CXYVector<float> >::iterator & pos_LV, vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iNodeInd)
CXYSIS::GrowChainSegment_GetErr	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_GetErr(void){$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GrowChainSegment_GetErr	XYSIS.h	/^  void GrowChainSegment_GetErr(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GrowChainSegment_GetErr_2	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_GetErr_2(void){$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GrowChainSegment_GetErr_2	XYSIS.h	/^  void GrowChainSegment_GetErr_2(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GrowChainSegment_GetWeight	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_GetWeight(void){$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GrowChainSegment_GetWeight	XYSIS.h	/^  void GrowChainSegment_GetWeight(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GrowChainSegment_InitRoot	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_InitRoot(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GrowChainSegment_InitRoot	XYSIS.h	/^  void GrowChainSegment_InitRoot(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GrowChainSegment_NoRestriction	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_NoRestriction(int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd){$/;"	f	class:CXYSIS	signature:(int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
CXYSIS::GrowChainSegment_NoRestriction	XYSIS.h	/^  void GrowChainSegment_NoRestriction(int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd);$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
CXYSIS::GrowChainSegment_RandSelect	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_RandSelect($/;"	f	class:CXYSIS	signature:( vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
CXYSIS::GrowChainSegment_RandSelect	XYSIS.h	/^  void GrowChainSegment_RandSelect(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains,$/;"	p	class:CXYSIS	access:public	signature:(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
CXYSIS::GrowChainSegment_RandSelect_2	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_RandSelect_2($/;"	f	class:CXYSIS	signature:( vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
CXYSIS::GrowChainSegment_RandSelect_2	XYSIS.h	/^  void GrowChainSegment_RandSelect_2(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains,$/;"	p	class:CXYSIS	access:public	signature:(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
CXYSIS::GrowChainSegment_SISAlgorithm	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_SISAlgorithm(void){$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GrowChainSegment_SISAlgorithm	XYSIS.h	/^  void GrowChainSegment_SISAlgorithm(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GrowChainSegment_SISAlgorithm_2	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_SISAlgorithm_2(void){$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GrowChainSegment_SISAlgorithm_2	XYSIS.h	/^  void GrowChainSegment_SISAlgorithm_2(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GrowChainSegment_SavePosInd	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_SavePosInd(void){$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GrowChainSegment_SavePosInd	XYSIS.h	/^  void GrowChainSegment_SavePosInd(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GrowChainSegment_WritePtsArr	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_WritePtsArr(void){$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::GrowChainSegment_WritePtsArr	XYSIS.h	/^  void GrowChainSegment_WritePtsArr(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::GrowChainSegment_h1Function	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_h1Function(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	f	class:CXYSIS	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd)
CXYSIS::GrowChainSegment_h1Function	XYSIS.h	/^  void GrowChainSegment_h1Function(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd)
CXYSIS::GrowChainSegment_h1Function_2	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_h1Function_2(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	f	class:CXYSIS	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd)
CXYSIS::GrowChainSegment_h1Function_2	XYSIS.h	/^  void GrowChainSegment_h1Function_2(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd)
CXYSIS::GrowChainSegment_h2Function	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_h2Function(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	f	class:CXYSIS	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd)
CXYSIS::GrowChainSegment_h2Function	XYSIS.h	/^  void GrowChainSegment_h2Function(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd)
CXYSIS::GrowChainSegment_h2Function_2	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_h2Function_2(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	f	class:CXYSIS	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd, vector<int>& rvConInd, CXYVector<float>& rKV_Dist)
CXYSIS::GrowChainSegment_h2Function_2	XYSIS.h	/^  void GrowChainSegment_h2Function_2(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd, vector<int> & rvConInd, CXYVector<float> & rKV_PrvDist)
CXYSIS::GrowChainSegment_h3Function	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_h3Function(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	f	class:CXYSIS	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd, vector<vector<int > >& vStartEndInd)
CXYSIS::GrowChainSegment_h3Function	XYSIS.h	/^  void GrowChainSegment_h3Function(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd, vector<vector<int > > & vStartEndInd)
CXYSIS::GrowChainSegment_h3Function_2	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_h3Function_2(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	f	class:CXYSIS	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd, vector<vector<int > >& vStartEndInd)
CXYSIS::GrowChainSegment_h3Function_2	XYSIS.h	/^  void GrowChainSegment_h3Function_2(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd, vector<vector<int > > & vStartEndInd)
CXYSIS::GrowOneChain_ByVector	XYSIS.cpp	/^void CXYSIS::GrowOneChain_ByVector($/;"	f	class:CXYSIS	signature:( tree< CXYVector<float> >::iterator &ritCurNode, tree< CXYVector<float> >::iterator &ritSurfNode, int SegInd, vector<tree<CXYVector<float> >::iterator>* pvChain)
CXYSIS::GrowOneChain_ByVector	XYSIS.h	/^  void GrowOneChain_ByVector(  tree< CXYVector<float> >::iterator &ritCurNode, $/;"	p	class:CXYSIS	access:public	signature:( tree< CXYVector<float> >::iterator &ritCurNode, tree< CXYVector<float> >::iterator &ritSurfNode, int SegInd, vector<tree<CXYVector<float> >::iterator>* pvCahin)
CXYSIS::GrowOneNode_Segment	XYSIS.h	/^  void GrowOneNode_Segment(tree< CXYVector<float> >::iterator &ritCurNode, $/;"	p	class:CXYSIS	access:public	signature:(tree< CXYVector<float> >::iterator &ritCurNode, tree< CXYVector<float> >::iterator &ritSurfNode, int SegInd, vector<tree<CXYVector<float> >::iterator>* pvChain)
CXYSIS::GrowthChain	XYSIS.cpp	/^CXYMatrix<float> CXYSIS::GrowthChain(tree< CXYVector<float> >::iterator &ritNode, $/;"	f	class:CXYSIS	signature:(tree< CXYVector<float> >::iterator &ritNode, CXYVector<float> &rkVPoint)
CXYSIS::GrowthChain	XYSIS.h	/^  CXYMatrix<float> GrowthChain(tree< CXYVector<float> >::iterator &ritNode, $/;"	p	class:CXYSIS	access:public	signature:(tree< CXYVector<float> >::iterator &ritNode, CXYVector<float> &rkVPoint)
CXYSIS::GrowthChain_NoCon	XYSIS.cpp	/^CXYMatrix<float> CXYSIS::GrowthChain_NoCon(tree< CXYVector<float> >::iterator &ritNode,  CXYVector<float> &rkVPoint)$/;"	f	class:CXYSIS	signature:(tree< CXYVector<float> >::iterator &ritNode, CXYVector<float> &rkVPoint)
CXYSIS::GrowthChain_NoCon	XYSIS.h	/^  CXYMatrix<float> GrowthChain_NoCon(tree< CXYVector<float> >::iterator &ritNode, $/;"	p	class:CXYSIS	access:public	signature:(tree< CXYVector<float> >::iterator &ritNode, CXYVector<float> &rkVPoint)
CXYSIS::GrowthOneChain	XYSIS.cpp	/^bool CXYSIS::GrowthOneChain()$/;"	f	class:CXYSIS	signature:()
CXYSIS::GrowthOneChain	XYSIS.h	/^  bool GrowthOneChain();$/;"	p	class:CXYSIS	access:public	signature:()
CXYSIS::InitializeChain	XYSIS.cpp	/^void CXYSIS::InitializeChain()$/;"	f	class:CXYSIS	signature:()
CXYSIS::InitializeChain	XYSIS.h	/^  void InitializeChain();$/;"	p	class:CXYSIS	access:public	signature:()
CXYSIS::InitializeChain_SISRoot	XYSIS.cpp	/^void CXYSIS::InitializeChain_SISRoot()$/;"	f	class:CXYSIS	signature:()
CXYSIS::InitializeChain_SISRoot	XYSIS.h	/^  void InitializeChain_SISRoot();$/;"	p	class:CXYSIS	access:public	signature:()
CXYSIS::IsCollision	XYSIS.cpp	/^bool CXYSIS::IsCollision(OcTree<float,int>* octree_, CXYVector<float>& kV_point){$/;"	f	class:CXYSIS	signature:(OcTree<float,int>* octree_, CXYVector<float>& kV_point)
CXYSIS::IsCollision	XYSIS.cpp	/^bool CXYSIS::IsCollision(OcTree<float,int>* pOctree_, float x_, float y_, float z_){$/;"	f	class:CXYSIS	signature:(OcTree<float,int>* pOctree_, float x_, float y_, float z_)
CXYSIS::IsCollision	XYSIS.cpp	/^bool CXYSIS::IsCollision(tree<CXYVector<float> >::iterator  &ritNode, CXYVector<float> kV_point)$/;"	f	class:CXYSIS	signature:(tree<CXYVector<float> >::iterator &ritNode, CXYVector<float> kV_point)
CXYSIS::IsCollision	XYSIS.h	/^  bool IsCollision(OcTree<float,int>* pOctree_, CXYVector<float>& kV_point);$/;"	p	class:CXYSIS	access:public	signature:(OcTree<float,int>* pOctree_, CXYVector<float>& kV_point)
CXYSIS::IsCollision	XYSIS.h	/^  bool IsCollision(OcTree<float,int>* pOctree_, float x_, float y_, float z_);$/;"	p	class:CXYSIS	access:public	signature:(OcTree<float,int>* pOctree_, float x_, float y_, float z_)
CXYSIS::IsCollision	XYSIS.h	/^  bool IsCollision(tree<CXYVector<float> >::iterator  &ritNode, CXYVector<float> kV_point);$/;"	p	class:CXYSIS	access:public	signature:(tree<CXYVector<float> >::iterator &ritNode, CXYVector<float> kV_point)
CXYSIS::IsInsideSphere	XYSIS.cpp	/^bool CXYSIS::IsInsideSphere(CXYVector<float> kV_point)$/;"	f	class:CXYSIS	signature:(CXYVector<float> kV_point)
CXYSIS::IsInsideSphere	XYSIS.cpp	/^bool CXYSIS::IsInsideSphere(float* fCoord)$/;"	f	class:CXYSIS	signature:(float* fCoord)
CXYSIS::IsInsideSphere	XYSIS.h	/^  bool IsInsideSphere(CXYVector<float> kV_point);$/;"	p	class:CXYSIS	access:public	signature:(CXYVector<float> kV_point)
CXYSIS::IsInsideSphere	XYSIS.h	/^  bool IsInsideSphere(float* fCoord);$/;"	p	class:CXYSIS	access:public	signature:(float* fCoord)
CXYSIS::IsOverlap	XYSIS.cpp	/^bool CXYSIS::IsOverlap(OcTree<float,int>* octree_, CXYVector<float>& kV_point, float dr_){$/;"	f	class:CXYSIS	signature:(OcTree<float,int>* octree_, CXYVector<float>& kV_point, float dr_)
CXYSIS::IsOverlap	XYSIS.cpp	/^bool CXYSIS::IsOverlap(OcTree<float,int>* pOctree_, float x_, float y_, float z_, float dr_){$/;"	f	class:CXYSIS	signature:(OcTree<float,int>* pOctree_, float x_, float y_, float z_, float dr_)
CXYSIS::IsOverlap	XYSIS.h	/^  bool IsOverlap(OcTree<float,int>* pOctree_, CXYVector<float>& kV_point, float dr_);$/;"	p	class:CXYSIS	access:public	signature:(OcTree<float,int>* pOctree_, CXYVector<float>& kV_point, float dr_)
CXYSIS::IsOverlap	XYSIS.h	/^  bool IsOverlap(OcTree<float,int>* pOctree_, float x_, float y_, float z_, float dr_);$/;"	p	class:CXYSIS	access:public	signature:(OcTree<float,int>* pOctree_, float x_, float y_, float z_, float dr_)
CXYSIS::NewXYZ	XYSIS.h	/^  CXYMatrix<float> NewXYZ(CXYVector<float> kV_0, CXYVector<float> kV_1, CXYVector<float> kV_2);$/;"	p	class:CXYSIS	access:public	signature:(CXYVector<float> kV_0, CXYVector<float> kV_1, CXYVector<float> kV_2)
CXYSIS::NewXYZ	XYSIS.h	/^  CXYMatrix<float> NewXYZ(CXYVector<float> kV_1, CXYVector<float> kV_2);$/;"	p	class:CXYSIS	access:public	signature:(CXYVector<float> kV_1, CXYVector<float> kV_2)
CXYSIS::RandomPermutation	XYSIS.cpp	/^void CXYSIS::RandomPermutation(int ArrN[], int n, int ArrM[], int m){ \/\/ m <= n$/;"	f	class:CXYSIS	signature:(int ArrN[], int n, int ArrM[], int m)
CXYSIS::RandomPermutation	XYSIS.h	/^  void RandomPermutation(int ArrN[], int n, int ArrM[], int m); \/\/ N > M$/;"	p	class:CXYSIS	access:public	signature:(int ArrN[], int n, int ArrM[], int m)
CXYSIS::RndSetStartPoint	XYSIS.cpp	/^CXYVector<float> CXYSIS::RndSetStartPoint(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::RndSetStartPoint	XYSIS.h	/^  CXYVector<float> RndSetStartPoint(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::SIS_Algorithm	XYSIS.cpp	/^void CXYSIS::SIS_Algorithm(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::SIS_Algorithm	XYSIS.h	/^  void SIS_Algorithm(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::SetAjust	XYSIS.cpp	/^void CXYSIS::SetAjust(float fAjust)$/;"	f	class:CXYSIS	signature:(float fAjust)
CXYSIS::SetAjust	XYSIS.h	/^  void SetAjust(float fAjust);$/;"	p	class:CXYSIS	access:public	signature:(float fAjust)
CXYSIS::SetBendingAngleBeg	XYSIS.h	/^  void SetBendingAngleBeg(float fAng);$/;"	p	class:CXYSIS	access:public	signature:(float fAng)
CXYSIS::SetBendingAngleEnd	XYSIS.h	/^  void SetBendingAngleEnd(float fAng);$/;"	p	class:CXYSIS	access:public	signature:(float fAng)
CXYSIS::SetCollisionLength	XYSIS.cpp	/^void CXYSIS::SetCollisionLength(float fCollision)$/;"	f	class:CXYSIS	signature:(float fCollision)
CXYSIS::SetCollisionLength	XYSIS.h	/^  void SetCollisionLength(float fCollision);$/;"	p	class:CXYSIS	access:public	signature:(float fCollision)
CXYSIS::SetContIndex	XYSIS.cpp	/^void CXYSIS::SetContIndex(char* cContIndFile){$/;"	f	class:CXYSIS	signature:(char* cContIndFile)
CXYSIS::SetContIndex	XYSIS.cpp	/^void CXYSIS::SetContIndex(void){$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::SetContIndex	XYSIS.h	/^  void SetContIndex(char* cContIndFile);$/;"	p	class:CXYSIS	access:public	signature:(char* cContIndFile)
CXYSIS::SetContIndex	XYSIS.h	/^  void SetContIndex(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::SetDistFileName	XYSIS.cpp	/^void CXYSIS::SetDistFileName(char* cFileName)$/;"	f	class:CXYSIS	signature:(char* cFileName)
CXYSIS::SetDistFileName	XYSIS.h	/^  void SetDistFileName(char* cFileName);$/;"	p	class:CXYSIS	access:public	signature:(char* cFileName)
CXYSIS::SetDistMatrix	XYSIS.cpp	/^void CXYSIS::SetDistMatrix(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::SetDistMatrix	XYSIS.h	/^  void SetDistMatrix(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::SetDistQuantile	XYSIS.cpp	/^void CXYSIS::SetDistQuantile(char* cFN){$/;"	f	class:CXYSIS	signature:(char* cFN)
CXYSIS::SetDistQuantile	XYSIS.h	/^  void SetDistQuantile(char* cFN);$/;"	p	class:CXYSIS	access:public	signature:(char* cFN)
CXYSIS::SetMmax	XYSIS.cpp	/^void CXYSIS::SetMmax(int iMmax)$/;"	f	class:CXYSIS	signature:(int iMmax)
CXYSIS::SetMmax	XYSIS.h	/^  void SetMmax(int iMmax);$/;"	p	class:CXYSIS	access:public	signature:(int iMmax)
CXYSIS::SetNucleusSphereDiameter	XYSIS.cpp	/^void CXYSIS::SetNucleusSphereDiameter(float fNucleusSphereDiameter)$/;"	f	class:CXYSIS	signature:(float fNucleusSphereDiameter)
CXYSIS::SetNucleusSphereDiameter	XYSIS.h	/^  void SetNucleusSphereDiameter(float fNucleusSphereDiameter);$/;"	p	class:CXYSIS	access:public	signature:(float fNucleusSphereDiameter)
CXYSIS::SetNumBendingAngle	XYSIS.h	/^  void SetNumBendingAngle(int iNum);$/;"	p	class:CXYSIS	access:public	signature:(int iNum)
CXYSIS::SetNumNodes	XYSIS.cpp	/^void CXYSIS::SetNumNodes(int iNumNodes){$/;"	f	class:CXYSIS	signature:(int iNumNodes)
CXYSIS::SetNumNodes	XYSIS.h	/^  void SetNumNodes(int iNumNodes);$/;"	p	class:CXYSIS	access:public	signature:(int iNumNodes)
CXYSIS::SetNumTorsionAngle	XYSIS.h	/^  void SetNumTorsionAngle(int iNum);$/;"	p	class:CXYSIS	access:public	signature:(int iNum)
CXYSIS::SetOutPath	XYSIS.cpp	/^void CXYSIS::SetOutPath(char* cPathName)$/;"	f	class:CXYSIS	signature:(char* cPathName)
CXYSIS::SetOutPath	XYSIS.h	/^  void SetOutPath(char* cPathName);$/;"	p	class:CXYSIS	access:public	signature:(char* cPathName)
CXYSIS::SetPackingDensity	XYSIS.cpp	/^void CXYSIS::SetPackingDensity(float fPackingDensity)$/;"	f	class:CXYSIS	signature:(float fPackingDensity)
CXYSIS::SetPackingDensity	XYSIS.h	/^  void SetPackingDensity(float fPackingDensity);$/;"	p	class:CXYSIS	access:public	signature:(float fPackingDensity)
CXYSIS::SetPersistenceLength	XYSIS.cpp	/^void CXYSIS::SetPersistenceLength(float fPL)$/;"	f	class:CXYSIS	signature:(float fPL)
CXYSIS::SetPersistenceLength	XYSIS.h	/^  void SetPersistenceLength(float fPL);$/;"	p	class:CXYSIS	access:public	signature:(float fPL)
CXYSIS::SetRho_1	XYSIS.cpp	/^void CXYSIS::SetRho_1(float fRho_1)$/;"	f	class:CXYSIS	signature:(float fRho_1)
CXYSIS::SetRho_1	XYSIS.h	/^  void SetRho_1(float fRho_1);$/;"	p	class:CXYSIS	access:public	signature:(float fRho_1)
CXYSIS::SetRho_2	XYSIS.cpp	/^void CXYSIS::SetRho_2(float fRho_2)$/;"	f	class:CXYSIS	signature:(float fRho_2)
CXYSIS::SetRho_2	XYSIS.h	/^  void SetRho_2(float fRho_2);$/;"	p	class:CXYSIS	access:public	signature:(float fRho_2)
CXYSIS::SetRho_3	XYSIS.cpp	/^void CXYSIS::SetRho_3(float fRho_3)$/;"	f	class:CXYSIS	signature:(float fRho_3)
CXYSIS::SetRho_3	XYSIS.h	/^  void SetRho_3(float fRho_3);$/;"	p	class:CXYSIS	access:public	signature:(float fRho_3)
CXYSIS::SetSamplesOrg	XYSIS.cpp	/^void CXYSIS::SetSamplesOrg(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::SetSamplesOrg	XYSIS.h	/^  void SetSamplesOrg();$/;"	p	class:CXYSIS	access:public	signature:()
CXYSIS::SetSegLengths	XYSIS.cpp	/^void CXYSIS::SetSegLengths(char* cStartEndFile,const char* cMethod){$/;"	f	class:CXYSIS	signature:(char* cStartEndFile,const char* cMethod)
CXYSIS::SetSegLengths	XYSIS.cpp	/^void CXYSIS::SetSegLengths(void){$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::SetSegLengths	XYSIS.h	/^  void SetSegLengths(char* cStartEndFile,const char* cMethod);$/;"	p	class:CXYSIS	access:public	signature:(char* cStartEndFile,const char* cMethod)
CXYSIS::SetSegLengths	XYSIS.h	/^  void SetSegLengths(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::SetSegSegPval	XYSIS.cpp	/^void CXYSIS::SetSegSegPval(char* cPvalFile){$/;"	f	class:CXYSIS	signature:(char* cPvalFile)
CXYSIS::SetSegSegPval	XYSIS.h	/^  void SetSegSegPval(char* cPvalFile);$/;"	p	class:CXYSIS	access:public	signature:(char* cPvalFile)
CXYSIS::SetSegSegPval_2	XYSIS.cpp	/^void CXYSIS::SetSegSegPval_2(char* cPvalFile){$/;"	f	class:CXYSIS	signature:(char* cPvalFile)
CXYSIS::SetSegSegPval_2	XYSIS.h	/^  void SetSegSegPval_2(char* cPvalFile);$/;"	p	class:CXYSIS	access:public	signature:(char* cPvalFile)
CXYSIS::SetTau_t	XYSIS.cpp	/^void CXYSIS::SetTau_t(float fTau_t)$/;"	f	class:CXYSIS	signature:(float fTau_t)
CXYSIS::SetTau_t	XYSIS.h	/^  void SetTau_t(float fTau_t);$/;"	p	class:CXYSIS	access:public	signature:(float fTau_t)
CXYSIS::SetTorsionAngleBeg	XYSIS.h	/^  void SetTorsionAngleBeg(float fAng);$/;"	p	class:CXYSIS	access:public	signature:(float fAng)
CXYSIS::SetTorsionAngleEnd	XYSIS.h	/^  void SetTorsionAngleEnd(float fAng);$/;"	p	class:CXYSIS	access:public	signature:(float fAng)
CXYSIS::UpdateMap_TreeIt_Vec_Append	XYSIS.cpp	/^void CXYSIS::UpdateMap_TreeIt_Vec_Append($/;"	f	class:CXYSIS	signature:( tree<CXYVector<float> >::iterator oldpos, tree<CXYVector<float> >::iterator newpos, int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
CXYSIS::UpdateMap_TreeIt_Vec_Append	XYSIS.h	/^  void UpdateMap_TreeIt_Vec_Append(tree<CXYVector<float> >::iterator oldpos, $/;"	p	class:CXYSIS	access:public	signature:(tree<CXYVector<float> >::iterator oldpos, tree<CXYVector<float> >::iterator newpos, int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
CXYSIS::UpdateMap_TreeIt_Vec_Clean	XYSIS.cpp	/^void CXYSIS::UpdateMap_TreeIt_Vec_Clean(void){$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::UpdateMap_TreeIt_Vec_Clean	XYSIS.h	/^  void UpdateMap_TreeIt_Vec_Clean(void); $/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::UpdateOctreeMap_Del	XYSIS.h	/^  void UpdateOctreeMap_Del(vector<tree<CXYVector<float> >::iterator>& v_octreemap_prvkey);$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator>& v_octreemap_prvkey)
CXYSIS::UpdateOctreeMap_New	XYSIS.h	/^  void UpdateOctreeMap_New(tree<CXYVector<float> >::iterator oldpos, $/;"	p	class:CXYSIS	access:public	signature:(tree<CXYVector<float> >::iterator oldpos, tree<CXYVector<float> >::iterator newpos, vector<tree<CXYVector<float> >::iterator>& v_octreemap_prvkey)
CXYSIS::WriteChain	XYSIS.cpp	/^void CXYSIS::WriteChain(char* fn)$/;"	f	class:CXYSIS	signature:(char* fn)
CXYSIS::WriteChain	XYSIS.h	/^  void WriteChain(char* fn);$/;"	p	class:CXYSIS	access:public	signature:(char* fn)
CXYSIS::WriteDistance	XYSIS.cpp	/^void CXYSIS::WriteDistance(char* fn)$/;"	f	class:CXYSIS	signature:(char* fn)
CXYSIS::WriteDistance	XYSIS.h	/^  void WriteDistance(char* fn); $/;"	p	class:CXYSIS	access:public	signature:(char* fn)
CXYSIS::WritePDB	XYSIS.cpp	/^void CXYSIS::WritePDB(char* cFN, CXYMatrix<float>& kM, int iInd)$/;"	f	class:CXYSIS	signature:(char* cFN, CXYMatrix<float>& kM, int iInd)
CXYSIS::WritePDB	XYSIS.h	/^  void WritePDB(char* cFN, CXYMatrix<float>& kM, int iInd);$/;"	p	class:CXYSIS	access:public	signature:(char* cFN, CXYMatrix<float>& kM, int iInd)
CXYSIS::WritePDBArr	XYSIS.cpp	/^void CXYSIS::WritePDBArr(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::WritePDBArr	XYSIS.h	/^  void WritePDBArr(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::WritePtsArr	XYSIS.cpp	/^void CXYSIS::WritePtsArr(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::WritePtsArr	XYSIS.h	/^  void WritePtsArr(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSIS::h1Function	XYSIS.cpp	/^float CXYSIS::h1Function(CXYMatrix<float>& kM)$/;"	f	class:CXYSIS	signature:(CXYMatrix<float>& kM)
CXYSIS::h1Function	XYSIS.h	/^  float h1Function(CXYMatrix<float>& kM);$/;"	p	class:CXYSIS	access:public	signature:(CXYMatrix<float>& kM)
CXYSIS::h1Function_ByVector	XYSIS.cpp	/^void CXYSIS::h1Function_ByVector(vector<tree<CXYVector<float> >::iterator >& rvOneChain){$/;"	f	class:CXYSIS	signature:(vector<tree<CXYVector<float> >::iterator >& rvOneChain)
CXYSIS::h1Function_ByVector	XYSIS.h	/^  void h1Function_ByVector(vector<tree<CXYVector<float> >::iterator >& rvOneChain);$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator >& rvOneChain)
CXYSIS::h2Function	XYSIS.cpp	/^float CXYSIS::h2Function(CXYMatrix<float>& kM)$/;"	f	class:CXYSIS	signature:(CXYMatrix<float>& kM)
CXYSIS::h2Function	XYSIS.h	/^  float h2Function(CXYMatrix<float>& kM);$/;"	p	class:CXYSIS	access:public	signature:(CXYMatrix<float>& kM)
CXYSIS::h2Function_ByVector	XYSIS.cpp	/^void CXYSIS::h2Function_ByVector(vector<tree<CXYVector<float> >::iterator >& rvOneChain, CXYVector<float>& rKV_Dist){$/;"	f	class:CXYSIS	signature:(vector<tree<CXYVector<float> >::iterator >& rvOneChain, CXYVector<float>& rKV_Dist)
CXYSIS::h2Function_ByVector	XYSIS.h	/^  void h2Function_ByVector(vector<tree<CXYVector<float> >::iterator >& rvOneChain, CXYVector<float>& rKV_Dist);$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator >& rvOneChain, CXYVector<float>& rKV_Dist)
CXYSIS::h3Function_ByVector	XYSIS.cpp	/^void CXYSIS::h3Function_ByVector($/;"	f	class:CXYSIS	signature:( vector<tree<CXYVector<float> >::iterator >& rvOneChain, CXYVector<float>& rKV_Dist)
CXYSIS::h3Function_ByVector	XYSIS.h	/^  void h3Function_ByVector(vector<tree<CXYVector<float> >::iterator >& rvOneChain, CXYVector<float>& rKV_Dist);$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator >& rvOneChain, CXYVector<float>& rKV_Dist)
CXYSIS::m_Dr	XYSIS.h	/^  float m_dr, m_Dr;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_Err_Ind	XYSIS.h	/^  vector<pair<float,int> >  m_Err_Ind;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_Err_map	XYSIS.h	/^  map<tree<CXYVector<float> >::iterator, float,tree<CXYVector<float> >::iterator_base_less> m_Err_map;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_MContInd	XYSIS.h	/^  CXYMatrix<int> m_MContInd;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_MSegSegPval	XYSIS.h	/^  CXYMatrix<int> m_MSegSegPval;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_MSegSegPval_2	XYSIS.h	/^  CXYMatrix<float> m_MSegSegPval_2;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_MapOctree	XYSIS.h	/^  Iterator_OcTree_Map m_MapOctree;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_PrvSegmentLastTreeit_Vec	XYSIS.h	/^  vector<tree<CXYVector<float> >::iterator> m_PrvSegmentLastTreeit_Vec;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_PrvTreeit_Vec	XYSIS.h	/^  vector<tree<CXYVector<float> >::iterator> m_PrvTreeit_Vec;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_Treeit_VecpOctree_Map	XYSIS.h	/^  TreeIterator_VecpOcTree_Map m_Treeit_VecpOctree_Map;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_Weight_Ind	XYSIS.h	/^  vector<pair<float,int> >  m_Weight_Ind;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_cDistFileName	XYSIS.h	/^  char* m_cDistFileName;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_cOutPath	XYSIS.h	/^  char* m_cOutPath;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_center	XYSIS.h	/^  Eigen::Matrix<float, 4, 1> m_center;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_dr	XYSIS.h	/^  float m_dr, m_Dr;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_fAdjust	XYSIS.h	/^  float m_fAdjust; \/\/ adjust gamma matrix$/;"	m	class:CXYSIS	access:private
CXYSIS::m_fCollisionLength	XYSIS.h	/^  float m_fCollisionLength;   \/\/ collision length$/;"	m	class:CXYSIS	access:private
CXYSIS::m_fInvNumber	XYSIS.h	/^  float m_fInvNumber;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_fNucleusSphereDiameter	XYSIS.h	/^  float m_fNucleusSphereDiameter; $/;"	m	class:CXYSIS	access:private
CXYSIS::m_fPackingDensity	XYSIS.h	/^  float m_fPackingDensity;   \/\/ packing density$/;"	m	class:CXYSIS	access:private
CXYSIS::m_fPersistenceLength	XYSIS.h	/^  float m_fPersistenceLength; \/\/ persistence length$/;"	m	class:CXYSIS	access:private
CXYSIS::m_fRho_1	XYSIS.h	/^  float m_fRho_1, m_fRho_2, m_fRho_3, m_fTau_t; \/\/ function parameter$/;"	m	class:CXYSIS	access:private
CXYSIS::m_fRho_2	XYSIS.h	/^  float m_fRho_1, m_fRho_2, m_fRho_3, m_fTau_t; \/\/ function parameter$/;"	m	class:CXYSIS	access:private
CXYSIS::m_fRho_3	XYSIS.h	/^  float m_fRho_1, m_fRho_2, m_fRho_3, m_fTau_t; \/\/ function parameter$/;"	m	class:CXYSIS	access:private
CXYSIS::m_fTau_t	XYSIS.h	/^  float m_fRho_1, m_fRho_2, m_fRho_3, m_fTau_t; \/\/ function parameter$/;"	m	class:CXYSIS	access:private
CXYSIS::m_iMmax	XYSIS.h	/^  int m_iMmax; \/\/ number of samples selected$/;"	m	class:CXYSIS	access:private
CXYSIS::m_iNumMiddleEndPoints	XYSIS.h	/^  int m_iNumMiddleEndPoints;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_iNumNodes	XYSIS.h	/^  int   m_iNumNodes;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_iNumSamplePoints	XYSIS.h	/^  int   m_iNumSamplePoints;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_maxDepth	XYSIS.h	/^  int m_maxDepth;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_minimumVolumeSize	XYSIS.h	/^  float m_minimumVolumeSize;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_pMDist	XYSIS.h	/^  CXYMatrix<float>* m_pMDist;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_pMSamplesOrg	XYSIS.h	/^  CXYMatrix<float>* m_pMSamplesOrg;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_pTChain	XYSIS.h	/^  tree< CXYVector<float> >* m_pTChain; \/\/ tree stored coordinates$/;"	m	class:CXYSIS	access:private
CXYSIS::m_pVEColl	XYSIS.h	/^  CXYVector<float>* m_pVEColl;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_pVErr	XYSIS.h	/^  CXYVector<float>* m_pVErr;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_posInd_Vec	XYSIS.h	/^  vector<tree<CXYVector<float> >::iterator> m_posInd_Vec;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_qPrvNodes	XYSIS.h	/^  deque<tree<CXYVector<float> >::iterator> m_qPrvNodes;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_vConNodeInd	XYSIS.h	/^  vector<int> m_vConNodeInd; \/\/ unique sorted connection node index$/;"	m	class:CXYSIS	access:private
CXYSIS::m_vDistQuantile	XYSIS.h	/^  vector<float> m_vDistQuantile;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_vPvalTriple	XYSIS.h	/^  vector<CXYTriple<int,int,int> > m_vPvalTriple;$/;"	m	class:CXYSIS	access:private
CXYSIS::m_vfSegLength	XYSIS.h	/^  vector<float> m_vfSegLength; \/\/ vector of segment length (may different)$/;"	m	class:CXYSIS	access:private
CXYSIS::m_vtriple	XYSIS.h	/^  vector<CXYTriple<int,int,float> > m_vtriple;$/;"	m	class:CXYSIS	access:private
CXYSIS::~CXYSIS	XYSIS.cpp	/^CXYSIS::~CXYSIS(void)$/;"	f	class:CXYSIS	signature:(void)
CXYSIS::~CXYSIS	XYSIS.h	/^  ~CXYSIS(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
CXYSO3Sequence	XYSO3Sequence.cpp	/^CXYSO3Sequence::CXYSO3Sequence(){$/;"	f	class:CXYSO3Sequence	signature:()
CXYSO3Sequence	XYSO3Sequence.cpp	/^CXYSO3Sequence::CXYSO3Sequence(int iNumPoints){$/;"	f	class:CXYSO3Sequence	signature:(int iNumPoints)
CXYSO3Sequence	XYSO3Sequence.h	/^	CXYSO3Sequence();$/;"	p	class:CXYSO3Sequence	access:public	signature:()
CXYSO3Sequence	XYSO3Sequence.h	/^	CXYSO3Sequence(int iNumPoints);$/;"	p	class:CXYSO3Sequence	access:public	signature:(int iNumPoints)
CXYSO3Sequence	XYSO3Sequence.h	/^class CXYSO3Sequence {$/;"	c
CXYSO3Sequence::CXYSO3Sequence	XYSO3Sequence.cpp	/^CXYSO3Sequence::CXYSO3Sequence(){$/;"	f	class:CXYSO3Sequence	signature:()
CXYSO3Sequence::CXYSO3Sequence	XYSO3Sequence.cpp	/^CXYSO3Sequence::CXYSO3Sequence(int iNumPoints){$/;"	f	class:CXYSO3Sequence	signature:(int iNumPoints)
CXYSO3Sequence::CXYSO3Sequence	XYSO3Sequence.h	/^	CXYSO3Sequence();$/;"	p	class:CXYSO3Sequence	access:public	signature:()
CXYSO3Sequence::CXYSO3Sequence	XYSO3Sequence.h	/^	CXYSO3Sequence(int iNumPoints);$/;"	p	class:CXYSO3Sequence	access:public	signature:(int iNumPoints)
CXYSO3Sequence::GetNumPoints	XYSO3Sequence.cpp	/^int CXYSO3Sequence::GetNumPoints(){$/;"	f	class:CXYSO3Sequence	signature:()
CXYSO3Sequence::GetNumPoints	XYSO3Sequence.h	/^	int GetNumPoints();$/;"	p	class:CXYSO3Sequence	access:public	signature:()
CXYSO3Sequence::GetSO3Sequence	XYSO3Sequence.cpp	/^CXYMatrix<float>& CXYSO3Sequence::GetSO3Sequence(){$/;"	f	class:CXYSO3Sequence	signature:()
CXYSO3Sequence::GetSO3Sequence	XYSO3Sequence.h	/^	CXYMatrix<float>& GetSO3Sequence();$/;"	p	class:CXYSO3Sequence	access:public	signature:()
CXYSO3Sequence::GetSequenceBase	XYSO3Sequence.cpp	/^vector<int >& CXYSO3Sequence::GetSequenceBase(){$/;"	f	class:CXYSO3Sequence	signature:()
CXYSO3Sequence::GetSequenceBase	XYSO3Sequence.h	/^	vector< int >& GetSequenceBase();$/;"	p	class:CXYSO3Sequence	access:public	signature:()
CXYSO3Sequence::SetSO3Sequence	XYSO3Sequence.cpp	/^int CXYSO3Sequence::SetSO3Sequence(){$/;"	f	class:CXYSO3Sequence	signature:()
CXYSO3Sequence::SetSO3Sequence	XYSO3Sequence.h	/^	int SetSO3Sequence();$/;"	p	class:CXYSO3Sequence	access:public	signature:()
CXYSO3Sequence::SetSequenceBase	XYSO3Sequence.cpp	/^void	CXYSO3Sequence:: SetSequenceBase(){$/;"	f	class:CXYSO3Sequence	signature:()
CXYSO3Sequence::SetSequenceBase	XYSO3Sequence.h	/^	void	SetSequenceBase();$/;"	p	class:CXYSO3Sequence	access:public	signature:()
CXYSO3Sequence::ang2vec	XYSO3Sequence.cpp	/^void CXYSO3Sequence::ang2vec(double theta, double phi, double *vec) {$/;"	f	class:CXYSO3Sequence	signature:(double theta, double phi, double *vec)
CXYSO3Sequence::ang2vec	XYSO3Sequence.h	/^	void ang2vec(double theta, double phi, double *vec);$/;"	p	class:CXYSO3Sequence	access:public	signature:(double theta, double phi, double *vec)
CXYSO3Sequence::eulerangle2vector	XYSO3Sequence.h	/^	void eulerangle2vector(EulerAngle ea, double oldpoint_xyz[], double newpoint_xyz[]);$/;"	p	class:CXYSO3Sequence	access:public	signature:(EulerAngle ea, double oldpoint_xyz[], double newpoint_xyz[])
CXYSO3Sequence::find_point	XYSO3Sequence.cpp	/^vector<double> CXYSO3Sequence::find_point(int base_grid, long int point,long int level,long int healpix_point)$/;"	f	class:CXYSO3Sequence	signature:(int base_grid, long int point,long int level,long int healpix_point)
CXYSO3Sequence::find_point	XYSO3Sequence.h	/^	vector<double> find_point(int base_grid, long int point,long int level,long int healpix_point);$/;"	p	class:CXYSO3Sequence	access:public	signature:(int base_grid, long int point,long int level,long int healpix_point)
CXYSO3Sequence::hopf2quat	XYSO3Sequence.h	/^	bool hopf2quat(vector < vector <double> > Points);$/;"	p	class:CXYSO3Sequence	access:public	signature:(vector < vector <double> > Points)
CXYSO3Sequence::m_iNumPoints	XYSO3Sequence.h	/^	int m_iNumPoints;$/;"	m	class:CXYSO3Sequence	access:private
CXYSO3Sequence::m_pMSpherepoints	XYSO3Sequence.h	/^	CXYMatrix<float> *m_pMSpherepoints;$/;"	m	class:CXYSO3Sequence	access:private
CXYSO3Sequence::m_vPoints	XYSO3Sequence.h	/^	vector< vector<double > > m_vPoints;$/;"	m	class:CXYSO3Sequence	access:private
CXYSO3Sequence::m_vSequence_base	XYSO3Sequence.h	/^	vector < int > m_vSequence_base;$/;"	m	class:CXYSO3Sequence	access:private
CXYSO3Sequence::mk_pix2xy	XYSO3Sequence.cpp	/^void CXYSO3Sequence::mk_pix2xy(int *pix2x, int *pix2y){$/;"	f	class:CXYSO3Sequence	signature:(int *pix2x, int *pix2y)
CXYSO3Sequence::mk_pix2xy	XYSO3Sequence.h	/^	void mk_pix2xy(int *pix2x, int *pix2y);$/;"	p	class:CXYSO3Sequence	access:public	signature:(int *pix2x, int *pix2y)
CXYSO3Sequence::pix2ang_nest	XYSO3Sequence.cpp	/^void CXYSO3Sequence::pix2ang_nest(long nside, long ipix, double *theta, double *phi){$/;"	f	class:CXYSO3Sequence	signature:(long nside, long ipix, double *theta, double *phi)
CXYSO3Sequence::pix2ang_nest	XYSO3Sequence.h	/^	void pix2ang_nest(long nside, long ipix, double *theta, double *phi);$/;"	p	class:CXYSO3Sequence	access:public	signature:(long nside, long ipix, double *theta, double *phi)
CXYSO3Sequence::printSO3Sequence	XYSO3Sequence.cpp	/^void CXYSO3Sequence::printSO3Sequence(){$/;"	f	class:CXYSO3Sequence	signature:()
CXYSO3Sequence::printSO3Sequence	XYSO3Sequence.h	/^	void printSO3Sequence();$/;"	p	class:CXYSO3Sequence	access:public	signature:()
CXYSO3Sequence::quat2vector	XYSO3Sequence.h	/^	void quat2vector(Quaternion quat, double oldpoint_xyz[], double newpoint_xyz[]);$/;"	p	class:CXYSO3Sequence	access:public	signature:(Quaternion quat, double oldpoint_xyz[], double newpoint_xyz[])
CXYSO3Sequence::~CXYSO3Sequence	XYSO3Sequence.cpp	/^CXYSO3Sequence::~CXYSO3Sequence(){$/;"	f	class:CXYSO3Sequence	signature:()
CXYSO3Sequence::~CXYSO3Sequence	XYSO3Sequence.h	/^	~CXYSO3Sequence(void);$/;"	p	class:CXYSO3Sequence	access:public	signature:(void)
CXYStringTokenizer	XYFile.h	/^   CXYStringTokenizer( ) {};$/;"	f	class:CXYStringTokenizer	access:private	signature:( )
CXYStringTokenizer	XYFile.h	/^   CXYStringTokenizer(const string& s, const char* delim = NULL) :$/;"	f	class:CXYStringTokenizer	access:public	signature:(const string& s, const char* delim = NULL)
CXYStringTokenizer	XYFile.h	/^class CXYStringTokenizer {$/;"	c
CXYStringTokenizer::CXYStringTokenizer	XYFile.h	/^   CXYStringTokenizer( ) {};$/;"	f	class:CXYStringTokenizer	access:private	signature:( )
CXYStringTokenizer::CXYStringTokenizer	XYFile.h	/^   CXYStringTokenizer(const string& s, const char* delim = NULL) :$/;"	f	class:CXYStringTokenizer	access:public	signature:(const string& s, const char* delim = NULL)
CXYStringTokenizer::begin_	XYFile.h	/^   int begin_;$/;"	m	class:CXYStringTokenizer	access:private
CXYStringTokenizer::countTokens	XYFile.h	/^   size_t countTokens( ) {$/;"	f	class:CXYStringTokenizer	access:public	signature:( )
CXYStringTokenizer::count_	XYFile.h	/^   int count_;$/;"	m	class:CXYStringTokenizer	access:private
CXYStringTokenizer::delim_	XYFile.h	/^   string delim_;$/;"	m	class:CXYStringTokenizer	access:private
CXYStringTokenizer::end_	XYFile.h	/^   int end_;$/;"	m	class:CXYStringTokenizer	access:private
CXYStringTokenizer::hasMoreTokens	XYFile.h	/^   bool hasMoreTokens( ) {return(begin_ != end_);}$/;"	f	class:CXYStringTokenizer	access:public	signature:( )
CXYStringTokenizer::nextToken	XYFile.h	/^   void nextToken(string& s) {$/;"	f	class:CXYStringTokenizer	access:public	signature:(string& s)
CXYStringTokenizer::str_	XYFile.h	/^   string str_;$/;"	m	class:CXYStringTokenizer	access:private
CXYTriple	XYUtility.h	/^	CXYTriple(const T1 &t1,const T2 &t2,const T3 &t3):$/;"	f	class:CXYTriple	access:public	signature:(const T1 &t1,const T2 &t2,const T3 &t3)
CXYTriple	XYUtility.h	/^class CXYTriple$/;"	c
CXYTriple::CXYTriple	XYUtility.h	/^	CXYTriple(const T1 &t1,const T2 &t2,const T3 &t3):$/;"	f	class:CXYTriple	access:public	signature:(const T1 &t1,const T2 &t2,const T3 &t3)
CXYTriple::first	XYUtility.h	/^	T1 first;$/;"	m	class:CXYTriple	access:public
CXYTriple::second	XYUtility.h	/^	T2 second;$/;"	m	class:CXYTriple	access:public
CXYTriple::third	XYUtility.h	/^	T3 third;$/;"	m	class:CXYTriple	access:public
CXYUtility	XYUtility.cpp	/^CXYUtility::CXYUtility(void)$/;"	f	class:CXYUtility	signature:(void)
CXYUtility	XYUtility.h	/^	CXYUtility(void);$/;"	p	class:CXYUtility	access:public	signature:(void)
CXYUtility	XYUtility.h	/^class CXYUtility{$/;"	c
CXYUtility::BaseName	XYUtility.cpp	/^char* CXYUtility::BaseName(char *name, int with_suffix)$/;"	f	class:CXYUtility	signature:(char *name, int with_suffix)
CXYUtility::BaseName	XYUtility.h	/^	static char *BaseName(char *name, int with_suffix);$/;"	p	class:CXYUtility	access:public	signature:(char *name, int with_suffix)
CXYUtility::CXYUtility	XYUtility.cpp	/^CXYUtility::CXYUtility(void)$/;"	f	class:CXYUtility	signature:(void)
CXYUtility::CXYUtility	XYUtility.h	/^	CXYUtility(void);$/;"	p	class:CXYUtility	access:public	signature:(void)
CXYUtility::Distance	XYUtility.cpp	/^float CXYUtility::Distance(CXYPoint3D<float> P1,CXYPoint3D<float> P2)$/;"	f	class:CXYUtility	signature:(CXYPoint3D<float> P1,CXYPoint3D<float> P2)
CXYUtility::Distance	XYUtility.h	/^	static float Distance(CXYPoint3D<float> P1,CXYPoint3D<float> P2);$/;"	p	class:CXYUtility	access:public	signature:(CXYPoint3D<float> P1,CXYPoint3D<float> P2)
CXYUtility::RandPerm	XYUtility.cpp	/^vector<int> CXYUtility::RandPerm( vector<int>& kV )$/;"	f	class:CXYUtility	signature:( vector<int>& kV )
CXYUtility::RandPerm	XYUtility.h	/^	static vector<int> RandPerm(vector<int>& kV);$/;"	p	class:CXYUtility	access:public	signature:(vector<int>& kV)
CXYUtility::SquareLength	XYUtility.cpp	/^float CXYUtility::SquareLength(CXYPoint3D<float> P1,CXYPoint3D<float> P2)$/;"	f	class:CXYUtility	signature:(CXYPoint3D<float> P1,CXYPoint3D<float> P2)
CXYUtility::SquareLength	XYUtility.h	/^	static float SquareLength(CXYPoint3D<float> P1,CXYPoint3D<float> P2);$/;"	p	class:CXYUtility	access:public	signature:(CXYPoint3D<float> P1,CXYPoint3D<float> P2)
CXYUtility::TrimChar	XYUtility.cpp	/^char *CXYUtility::TrimChar(char *pszSource)$/;"	f	class:CXYUtility	signature:(char *pszSource)
CXYUtility::TrimChar	XYUtility.h	/^	static char *TrimChar( char *szSource );$/;"	p	class:CXYUtility	access:public	signature:( char *szSource )
CXYUtility::trim_left	XYUtility.h	/^	static char *trim_left( char *szSource );$/;"	p	class:CXYUtility	access:public	signature:( char *szSource )
CXYUtility::trim_right	XYUtility.h	/^	static char *trim_right( char *szSource );$/;"	p	class:CXYUtility	access:public	signature:( char *szSource )
CXYUtility::~CXYUtility	XYUtility.cpp	/^CXYUtility::~CXYUtility(void)$/;"	f	class:CXYUtility	signature:(void)
CXYUtility::~CXYUtility	XYUtility.h	/^	~CXYUtility(void);$/;"	p	class:CXYUtility	access:public	signature:(void)
CXYVector	XYVector.h	/^	CXYVector (const CXYVector& rkV);$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV)
CXYVector	XYVector.h	/^	CXYVector (int iSize, const Real* afTuple);$/;"	p	class:CXYVector	access:public	signature:(int iSize, const Real* afTuple)
CXYVector	XYVector.h	/^	CXYVector(int iSize = 0);$/;"	p	class:CXYVector	access:public	signature:(int iSize = 0)
CXYVector	XYVector.h	/^class CXYVector$/;"	c
CXYVector	XYVector.inl	/^CXYVector<Real>::CXYVector (int iSize)$/;"	f	class:CXYVector	signature:(int iSize)
CXYVector	XYVector.inl	/^CXYVector<Real>::CXYVector (int iSize, const Real* afTuple)$/;"	f	class:CXYVector	signature:(int iSize, const Real* afTuple)
CXYVector	XYVector.inl	/^CXYVector<Real>::CXYVector(const CXYVector& rkV)$/;"	f	class:CXYVector	signature:(const CXYVector& rkV)
CXYVector::Avg	XYVector.h	/^	Real Avg() const;$/;"	p	class:CXYVector	access:public	signature:() const
CXYVector::Avg	XYVector.inl	/^Real CXYVector<Real>::Avg () const$/;"	f	class:CXYVector	signature:() const
CXYVector::CXYVector	XYVector.h	/^	CXYVector (const CXYVector& rkV);$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV)
CXYVector::CXYVector	XYVector.h	/^	CXYVector (int iSize, const Real* afTuple);$/;"	p	class:CXYVector	access:public	signature:(int iSize, const Real* afTuple)
CXYVector::CXYVector	XYVector.h	/^	CXYVector(int iSize = 0);$/;"	p	class:CXYVector	access:public	signature:(int iSize = 0)
CXYVector::CXYVector	XYVector.inl	/^CXYVector<Real>::CXYVector (int iSize)$/;"	f	class:CXYVector	signature:(int iSize)
CXYVector::CXYVector	XYVector.inl	/^CXYVector<Real>::CXYVector (int iSize, const Real* afTuple)$/;"	f	class:CXYVector	signature:(int iSize, const Real* afTuple)
CXYVector::CXYVector	XYVector.inl	/^CXYVector<Real>::CXYVector(const CXYVector& rkV)$/;"	f	class:CXYVector	signature:(const CXYVector& rkV)
CXYVector::CompareArrays	XYVector.h	/^    int CompareArrays (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:private	signature:(const CXYVector& rkV) const
CXYVector::CompareArrays	XYVector.inl	/^int CXYVector<Real>::CompareArrays (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
CXYVector::Dot	XYVector.h	/^    Real Dot (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV) const
CXYVector::Dot	XYVector.inl	/^Real CXYVector<Real>::Dot (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
CXYVector::GetSize	XYVector.h	/^    int GetSize () const;$/;"	p	class:CXYVector	access:public	signature:() const
CXYVector::GetSize	XYVector.inl	/^int CXYVector<Real>::GetSize() const$/;"	f	class:CXYVector	signature:() const
CXYVector::Length	XYVector.h	/^    Real Length () const;$/;"	p	class:CXYVector	access:public	signature:() const
CXYVector::Length	XYVector.inl	/^Real CXYVector<Real>::Length () const$/;"	f	class:CXYVector	signature:() const
CXYVector::Normalize	XYVector.h	/^    Real Normalize ();$/;"	p	class:CXYVector	access:public	signature:()
CXYVector::Normalize	XYVector.inl	/^Real CXYVector<Real>::Normalize ()$/;"	f	class:CXYVector	signature:()
CXYVector::SetSize	XYVector.h	/^    void SetSize (int iSize);$/;"	p	class:CXYVector	access:public	signature:(int iSize)
CXYVector::SetSize	XYVector.inl	/^void CXYVector<Real>::SetSize(int iSize)$/;"	f	class:CXYVector	signature:(int iSize)
CXYVector::SquaredLength	XYVector.h	/^    Real SquaredLength () const;$/;"	p	class:CXYVector	access:public	signature:() const
CXYVector::SquaredLength	XYVector.inl	/^Real CXYVector<Real>::SquaredLength () const$/;"	f	class:CXYVector	signature:() const
CXYVector::Sum	XYVector.h	/^	Real Sum() const;$/;"	p	class:CXYVector	access:public	signature:() const
CXYVector::Sum	XYVector.inl	/^Real CXYVector<Real>::Sum () const$/;"	f	class:CXYVector	signature:() const
CXYVector::m_afTuple	XYVector.h	/^    Real* m_afTuple;$/;"	m	class:CXYVector	access:private
CXYVector::m_iSize	XYVector.h	/^	int m_iSize;$/;"	m	class:CXYVector	access:private
CXYVector::operator !=	XYVector.h	/^    bool operator!= (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV) const
CXYVector::operator !=	XYVector.inl	/^bool CXYVector<Real>::operator!= (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
CXYVector::operator *	XYVector.h	/^    CXYVector operator* (Real fScalar) const;$/;"	p	class:CXYVector	access:public	signature:(Real fScalar) const
CXYVector::operator *	XYVector.inl	/^CXYVector<Real> CXYVector<Real>::operator* (Real fScalar) const$/;"	f	class:CXYVector	signature:(Real fScalar) const
CXYVector::operator *=	XYVector.h	/^    CXYVector& operator*= (Real fScalar);$/;"	p	class:CXYVector	access:public	signature:(Real fScalar)
CXYVector::operator *=	XYVector.inl	/^CXYVector<Real>& CXYVector<Real>::operator *= (Real fScalar)$/;"	f	class:CXYVector	signature:(Real fScalar)
CXYVector::operator +	XYVector.h	/^    CXYVector operator+ (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV) const
CXYVector::operator +	XYVector.inl	/^CXYVector<Real> CXYVector<Real>::operator+ (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
CXYVector::operator +=	XYVector.h	/^    CXYVector& operator+= (const CXYVector& rkV);$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV)
CXYVector::operator +=	XYVector.inl	/^CXYVector<Real>& CXYVector<Real>::operator += (const CXYVector& rkV)$/;"	f	class:CXYVector	signature:(const CXYVector& rkV)
CXYVector::operator -	XYVector.h	/^    CXYVector operator- () const;$/;"	p	class:CXYVector	access:public	signature:() const
CXYVector::operator -	XYVector.h	/^    CXYVector operator- (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV) const
CXYVector::operator -	XYVector.inl	/^CXYVector<Real> CXYVector<Real>::operator -() const$/;"	f	class:CXYVector	signature:() const
CXYVector::operator -	XYVector.inl	/^CXYVector<Real> CXYVector<Real>::operator- (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
CXYVector::operator -=	XYVector.h	/^    CXYVector& operator-= (const CXYVector& rkV);$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV)
CXYVector::operator -=	XYVector.inl	/^CXYVector<Real>& CXYVector<Real>::operator -= (const CXYVector& rkV)$/;"	f	class:CXYVector	signature:(const CXYVector& rkV)
CXYVector::operator /	XYVector.h	/^    CXYVector operator\/ (Real fScalar) const;$/;"	p	class:CXYVector	access:public	signature:(Real fScalar) const
CXYVector::operator /	XYVector.inl	/^CXYVector<Real> CXYVector<Real>::operator\/ (Real fScalar) const$/;"	f	class:CXYVector	signature:(Real fScalar) const
CXYVector::operator /=	XYVector.h	/^    CXYVector& operator\/= (Real fScalar);$/;"	p	class:CXYVector	access:public	signature:(Real fScalar)
CXYVector::operator /=	XYVector.inl	/^CXYVector<Real>& CXYVector<Real>::operator \/= (Real fScalar)$/;"	f	class:CXYVector	signature:(Real fScalar)
CXYVector::operator <	XYVector.h	/^    bool operator<  (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV) const
CXYVector::operator <	XYVector.inl	/^bool CXYVector<Real>::operator< (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
CXYVector::operator <=	XYVector.h	/^    bool operator<= (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV) const
CXYVector::operator <=	XYVector.inl	/^bool CXYVector<Real>::operator<= (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
CXYVector::operator =	XYVector.h	/^    CXYVector& operator= (const CXYVector& rkV);$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV)
CXYVector::operator =	XYVector.inl	/^CXYVector<Real>& CXYVector<Real>::operator= (const CXYVector& rkV)$/;"	f	class:CXYVector	signature:(const CXYVector& rkV)
CXYVector::operator ==	XYVector.h	/^    bool operator== (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV) const
CXYVector::operator ==	XYVector.inl	/^bool CXYVector<Real>::operator== (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
CXYVector::operator >	XYVector.h	/^    bool operator>  (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV) const
CXYVector::operator >	XYVector.inl	/^bool CXYVector<Real>::operator> (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
CXYVector::operator >=	XYVector.h	/^    bool operator>= (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV) const
CXYVector::operator >=	XYVector.inl	/^bool CXYVector<Real>::operator>= (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
CXYVector::operator Real*	XYVector.h	/^    operator Real* ();$/;"	p	class:CXYVector	access:public	signature:()
CXYVector::operator Real*	XYVector.inl	/^CXYVector<Real>::operator Real* ()$/;"	f	class:CXYVector	signature:()
CXYVector::operator []	XYVector.h	/^    Real operator[] (int i) const;$/;"	p	class:CXYVector	access:public	signature:(int i) const
CXYVector::operator []	XYVector.h	/^    Real& operator[] (int i);$/;"	p	class:CXYVector	access:public	signature:(int i)
CXYVector::operator []	XYVector.inl	/^Real CXYVector<Real>::operator[] (int i) const$/;"	f	class:CXYVector	signature:(int i) const
CXYVector::operator []	XYVector.inl	/^Real& CXYVector<Real>::operator[] (int i)$/;"	f	class:CXYVector	signature:(int i)
CXYVector::operator const Real*	XYVector.h	/^    operator const Real* () const;$/;"	p	class:CXYVector	access:public	signature:() const
CXYVector::operator const Real*	XYVector.inl	/^CXYVector<Real>::operator const Real* () const$/;"	f	class:CXYVector	signature:() const
CXYVector::~CXYVector	XYVector.h	/^	~CXYVector(void);$/;"	p	class:CXYVector	access:public	signature:(void)
CXYVector::~CXYVector	XYVector.inl	/^CXYVector<Real>::~CXYVector(void)$/;"	f	class:CXYVector	signature:(void)
CXYVectord	XYVector.h	/^typedef CXYVector<double> CXYVectord;$/;"	t
CXYVectorf	XYVector.h	/^typedef CXYVector<float> CXYVectorf;$/;"	t
CalBeta_t	XYSIS.cpp	/^float CXYSIS::CalBeta_t(CXYMatrix<float> &kM)$/;"	f	class:CXYSIS	signature:(CXYMatrix<float> &kM)
CalBeta_t	XYSIS.h	/^  float CalBeta_t(CXYMatrix<float> &kM);$/;"	p	class:CXYSIS	access:public	signature:(CXYMatrix<float> &kM)
CalBeta_t_ByVector	XYSIS.cpp	/^void CXYSIS::CalBeta_t_ByVector(vector< vector<tree<CXYVector<float> >::iterator >* >& rvvChains, int iSegInd, vector<float>& rvfBeta_t){$/;"	f	class:CXYSIS	signature:(vector< vector<tree<CXYVector<float> >::iterator >* >& rvvChains, int iSegInd, vector<float>& rvfBeta_t)
CalBeta_t_ByVector	XYSIS.h	/^  void CalBeta_t_ByVector(vector< vector<tree<CXYVector<float> >::iterator >* >& rvvChains,  int iSegInd, vector<float>& rvfBeta_t);$/;"	p	class:CXYSIS	access:public	signature:(vector< vector<tree<CXYVector<float> >::iterator >* >& rvvChains, int iSegInd, vector<float>& rvfBeta_t)
CompareArrays	XYMatrix.h	/^    int CompareArrays (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:private	signature:(const CXYMatrix& rkM) const
CompareArrays	XYMatrix.inl	/^int CXYMatrix<Real>::CompareArrays (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
CompareArrays	XYPoint3D.h	/^	int CompareArrays (const CXYPoint3D& rP) const;$/;"	p	class:CXYPoint3D	access:private	signature:(const CXYPoint3D& rP) const
CompareArrays	XYPoint3D.inl	/^int CXYPoint3D<Real>::CompareArrays (const CXYPoint3D& rP) const$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP) const
CompareArrays	XYVector.h	/^    int CompareArrays (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:private	signature:(const CXYVector& rkV) const
CompareArrays	XYVector.inl	/^int CXYVector<Real>::CompareArrays (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
ConfigFile	ConfigFile.cpp	/^ConfigFile::ConfigFile( string filename, string delimiter,$/;"	f	class:ConfigFile	signature:( string filename, string delimiter, string comment, string sentry )
ConfigFile	ConfigFile.cpp	/^ConfigFile::ConfigFile()$/;"	f	class:ConfigFile	signature:()
ConfigFile	ConfigFile.h	/^	ConfigFile( string filename,$/;"	p	class:ConfigFile	access:public	signature:( string filename, string delimiter = , string comment = , string sentry =  )
ConfigFile	ConfigFile.h	/^	ConfigFile();$/;"	p	class:ConfigFile	access:public	signature:()
ConfigFile	ConfigFile.h	/^class ConfigFile {$/;"	c
ConfigFile::ConfigFile	ConfigFile.cpp	/^ConfigFile::ConfigFile( string filename, string delimiter,$/;"	f	class:ConfigFile	signature:( string filename, string delimiter, string comment, string sentry )
ConfigFile::ConfigFile	ConfigFile.cpp	/^ConfigFile::ConfigFile()$/;"	f	class:ConfigFile	signature:()
ConfigFile::ConfigFile	ConfigFile.h	/^	ConfigFile( string filename,$/;"	p	class:ConfigFile	access:public	signature:( string filename, string delimiter = , string comment = , string sentry =  )
ConfigFile::ConfigFile	ConfigFile.h	/^	ConfigFile();$/;"	p	class:ConfigFile	access:public	signature:()
ConfigFile::T_as_string	ConfigFile.h	/^	template<class T> static string T_as_string( const T& t );$/;"	p	class:ConfigFile	access:protected	signature:( const T& t )
ConfigFile::T_as_string	ConfigFile.h	/^string ConfigFile::T_as_string( const T& t )$/;"	f	class:ConfigFile	signature:( const T& t )
ConfigFile::add	ConfigFile.h	/^	template<class T> void add( string key, const T& value );$/;"	p	class:ConfigFile	access:public	signature:( string key, const T& value )
ConfigFile::add	ConfigFile.h	/^void ConfigFile::add( string key, const T& value )$/;"	f	class:ConfigFile	signature:( string key, const T& value )
ConfigFile::file_not_found	ConfigFile.h	/^	struct file_not_found {$/;"	s	class:ConfigFile	access:public
ConfigFile::file_not_found::file_not_found	ConfigFile.h	/^		file_not_found( const string& filename_ = string() )$/;"	f	struct:ConfigFile::file_not_found	access:public	signature:( const string& filename_ = string() )
ConfigFile::file_not_found::filename	ConfigFile.h	/^		string filename;$/;"	m	struct:ConfigFile::file_not_found	access:public
ConfigFile::getComment	ConfigFile.h	/^	string getComment() const { return myComment; }$/;"	f	class:ConfigFile	access:public	signature:() const
ConfigFile::getDelimiter	ConfigFile.h	/^	string getDelimiter() const { return myDelimiter; }$/;"	f	class:ConfigFile	access:public	signature:() const
ConfigFile::getSentry	ConfigFile.h	/^	string getSentry() const { return mySentry; }$/;"	f	class:ConfigFile	access:public	signature:() const
ConfigFile::keyExists	ConfigFile.cpp	/^bool ConfigFile::keyExists( const string& key ) const$/;"	f	class:ConfigFile	signature:( const string& key ) const
ConfigFile::keyExists	ConfigFile.h	/^	bool keyExists( const string& key ) const;$/;"	p	class:ConfigFile	access:public	signature:( const string& key ) const
ConfigFile::key_not_found	ConfigFile.h	/^	struct key_not_found {  \/\/ thrown only by T read(key) variant of read()$/;"	s	class:ConfigFile	access:public
ConfigFile::key_not_found::key	ConfigFile.h	/^		string key;$/;"	m	struct:ConfigFile::key_not_found	access:public
ConfigFile::key_not_found::key_not_found	ConfigFile.h	/^		key_not_found( const string& key_ = string() )$/;"	f	struct:ConfigFile::key_not_found	access:public	signature:( const string& key_ = string() )
ConfigFile::mapci	ConfigFile.h	/^	typedef std::map<string,string>::const_iterator mapci;$/;"	t	class:ConfigFile	access:protected
ConfigFile::mapi	ConfigFile.h	/^	typedef std::map<string,string>::iterator mapi;$/;"	t	class:ConfigFile	access:protected
ConfigFile::myComment	ConfigFile.h	/^	string myComment;    \/\/ separator between value and comments$/;"	m	class:ConfigFile	access:protected
ConfigFile::myContents	ConfigFile.h	/^	std::map<string,string> myContents;  \/\/ extracted keys and values$/;"	m	class:ConfigFile	access:protected
ConfigFile::myDelimiter	ConfigFile.h	/^	string myDelimiter;  \/\/ separator between key and value$/;"	m	class:ConfigFile	access:protected
ConfigFile::mySentry	ConfigFile.h	/^	string mySentry;     \/\/ optional string to signal end of file$/;"	m	class:ConfigFile	access:protected
ConfigFile::operator <<	ConfigFile.h	/^	friend std::ostream& operator<<( std::ostream& os, const ConfigFile& cf );$/;"	p	class:ConfigFile	access:friend	signature:( std::ostream& os, const ConfigFile& cf )
ConfigFile::operator >>	ConfigFile.h	/^	friend std::istream& operator>>( std::istream& is, ConfigFile& cf );$/;"	p	class:ConfigFile	access:friend	signature:( std::istream& is, ConfigFile& cf )
ConfigFile::read	ConfigFile.h	/^	template<class T> T read( const string& key ) const;  \/\/ call as read<T>$/;"	p	class:ConfigFile	access:public	signature:( const string& key ) const
ConfigFile::read	ConfigFile.h	/^	template<class T> T read( const string& key, const T& value ) const;$/;"	p	class:ConfigFile	access:public	signature:( const string& key, const T& value ) const
ConfigFile::read	ConfigFile.h	/^T ConfigFile::read( const string& key ) const$/;"	f	class:ConfigFile	signature:( const string& key ) const
ConfigFile::read	ConfigFile.h	/^T ConfigFile::read( const string& key, const T& value ) const$/;"	f	class:ConfigFile	signature:( const string& key, const T& value ) const
ConfigFile::readInto	ConfigFile.h	/^	bool readInto( T& var, const string& key, const T& value ) const;$/;"	p	class:ConfigFile	access:public	signature:( T& var, const string& key, const T& value ) const
ConfigFile::readInto	ConfigFile.h	/^	template<class T> bool readInto( T& var, const string& key ) const;$/;"	p	class:ConfigFile	access:public	signature:( T& var, const string& key ) const
ConfigFile::readInto	ConfigFile.h	/^bool ConfigFile::readInto( T& var, const string& key ) const$/;"	f	class:ConfigFile	signature:( T& var, const string& key ) const
ConfigFile::readInto	ConfigFile.h	/^bool ConfigFile::readInto( T& var, const string& key, const T& value ) const$/;"	f	class:ConfigFile	signature:( T& var, const string& key, const T& value ) const
ConfigFile::remove	ConfigFile.cpp	/^void ConfigFile::remove( const string& key )$/;"	f	class:ConfigFile	signature:( const string& key )
ConfigFile::remove	ConfigFile.h	/^	void remove( const string& key );$/;"	p	class:ConfigFile	access:public	signature:( const string& key )
ConfigFile::setComment	ConfigFile.h	/^	string setComment( const string& s )$/;"	f	class:ConfigFile	access:public	signature:( const string& s )
ConfigFile::setDelimiter	ConfigFile.h	/^	string setDelimiter( const string& s )$/;"	f	class:ConfigFile	access:public	signature:( const string& s )
ConfigFile::string_as_T	ConfigFile.h	/^	template<class T> static T string_as_T( const string& s );$/;"	p	class:ConfigFile	access:protected	signature:( const string& s )
ConfigFile::string_as_T	ConfigFile.h	/^T ConfigFile::string_as_T( const string& s )$/;"	f	class:ConfigFile	signature:( const string& s )
ConfigFile::string_as_T	ConfigFile.h	/^inline bool ConfigFile::string_as_T<bool>( const string& s )$/;"	f	class:ConfigFile	signature:( const string& s )
ConfigFile::string_as_T	ConfigFile.h	/^inline string ConfigFile::string_as_T<string>( const string& s )$/;"	f	class:ConfigFile	signature:( const string& s )
ConfigFile::trim	ConfigFile.cpp	/^void ConfigFile::trim( string& s )$/;"	f	class:ConfigFile	signature:( string& s )
ConfigFile::trim	ConfigFile.h	/^	static void trim( string& s );$/;"	p	class:ConfigFile	access:protected	signature:( string& s )
Deallocate	XYMatrix.h	/^    void Deallocate ();$/;"	p	class:CXYMatrix	access:private	signature:()
Deallocate	XYMatrix.inl	/^void CXYMatrix<Real>::Deallocate ()$/;"	f	class:CXYMatrix	signature:()
DecrSortEigenStuffN	XYEigen.cpp	/^void CXYEigen<Real>::DecrSortEigenStuffN ()$/;"	f	class:CXYEigen	signature:()
DecrSortEigenStuffN	XYEigen.h	/^    void DecrSortEigenStuffN ();$/;"	p	class:CXYEigen	access:public	signature:()
DecreasingSort	XYEigen.cpp	/^void CXYEigen<Real>::DecreasingSort ()$/;"	f	class:CXYEigen	signature:()
DecreasingSort	XYEigen.h	/^    void DecreasingSort ();$/;"	p	class:CXYEigen	access:private	signature:()
DirExists	XYFile.cpp	/^bool CXYFile::DirExists(const char* cDirName){$/;"	f	class:CXYFile	signature:(const char* cDirName)
DirExists	XYFile.h	/^	static bool DirExists(const char* cDirName);$/;"	p	class:CXYFile	access:public	signature:(const char* cDirName)
Distance	XYUtility.cpp	/^float CXYUtility::Distance(CXYPoint3D<float> P1,CXYPoint3D<float> P2)$/;"	f	class:CXYUtility	signature:(CXYPoint3D<float> P1,CXYPoint3D<float> P2)
Distance	XYUtility.h	/^	static float Distance(CXYPoint3D<float> P1,CXYPoint3D<float> P2);$/;"	p	class:CXYUtility	access:public	signature:(CXYPoint3D<float> P1,CXYPoint3D<float> P2)
Dot	XYVector.h	/^    Real Dot (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV) const
Dot	XYVector.inl	/^Real CXYVector<Real>::Dot (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
DynamicAllocator	octree.h	/^    DynamicAllocator( int block_size ) {$/;"	f	class:spatialaggregate::DynamicAllocator	access:public	signature:( int block_size )
DynamicAllocator	octree.h	/^  class DynamicAllocator {$/;"	c	namespace:spatialaggregate
EIGEN_MAKE_ALIGNED_OPERATOR_NEW	octree.h	/^        EIGEN_MAKE_ALIGNED_OPERATOR_NEW;$/;"	m	class:spatialaggregate::OcTree	access:public
EIGEN_MAKE_ALIGNED_OPERATOR_NEW	octree.h	/^        EIGEN_MAKE_ALIGNED_OPERATOR_NEW;$/;"	m	class:spatialaggregate::OcTreeKey	access:public
EIGEN_MAKE_ALIGNED_OPERATOR_NEW	octree.h	/^        EIGEN_MAKE_ALIGNED_OPERATOR_NEW;$/;"	m	class:spatialaggregate::OcTreeNode	access:public
EIGEN_MAKE_ALIGNED_OPERATOR_NEW	octree.h	/^        EIGEN_MAKE_ALIGNED_OPERATOR_NEW;$/;"	m	class:spatialaggregate::OcTreeNodeAllocator	access:public
EIGEN_MAKE_ALIGNED_OPERATOR_NEW	octree.h	/^        EIGEN_MAKE_ALIGNED_OPERATOR_NEW;$/;"	m	class:spatialaggregate::OcTreeNodeDynamicAllocator	access:public
EIGEN_MAKE_ALIGNED_OPERATOR_NEW	octree.h	/^        EIGEN_MAKE_ALIGNED_OPERATOR_NEW;$/;"	m	class:spatialaggregate::OcTreeNodeFixedCountAllocator	access:public
EigenStuffN	XYEigen.cpp	/^void CXYEigen<Real>::EigenStuffN ()$/;"	f	class:CXYEigen	signature:()
EigenStuffN	XYEigen.h	/^    void EigenStuffN ();$/;"	p	class:CXYEigen	access:public	signature:()
Eigend	XYEigen.h	/^typedef CXYEigen<double> Eigend;$/;"	t
Eigenf	XYEigen.h	/^typedef CXYEigen<float> Eigenf;$/;"	t
EulerAngle	XYSO3Sequence.h	/^typedef struct EulerAngle{$/;"	s
EulerAngle	XYSO3Sequence.h	/^} EulerAngle;$/;"	t	typeref:struct:EulerAngle
EulerAngle::phi	XYSO3Sequence.h	/^	double phi;		\/\/ yaw$/;"	m	struct:EulerAngle	access:public
EulerAngle::psi	XYSO3Sequence.h	/^	double psi;		\/\/ roll$/;"	m	struct:EulerAngle	access:public
EulerAngle::theta	XYSO3Sequence.h	/^	double theta; \/\/ pitch$/;"	m	struct:EulerAngle	access:public
FAbs	XYMath.h	/^	static Real FAbs (Real fValue);$/;"	p	class:CXYMath	access:public	signature:(Real fValue)
FAbs	XYMath.inl	/^Real CXYMath<Real>::FAbs (Real fValue)$/;"	f	class:CXYMath	signature:(Real fValue)
FastInvSqrt	XYMath.cpp	/^double CXYMath<double>::FastInvSqrt (double dValue)$/;"	f	class:CXYMath	signature:(double dValue)
FastInvSqrt	XYMath.cpp	/^float CXYMath<float>::FastInvSqrt (float fValue)$/;"	f	class:CXYMath	signature:(float fValue)
FastInvSqrt	XYMath.h	/^	static Real FastInvSqrt (Real fValue);$/;"	p	class:CXYMath	access:public	signature:(Real fValue)
FastInvSqrt	XYMath.h	/^template<> double CXYMath<double>::FastInvSqrt (double dValue);$/;"	p	class:CXYMath	signature:(double dValue)
FastInvSqrt	XYMath.h	/^template<> float CXYMath<float>::FastInvSqrt (float fValue);$/;"	p	class:CXYMath	signature:(float fValue)
FileExists	XYFile.cpp	/^bool CXYFile::FileExists(const char* cFileName){$/;"	f	class:CXYFile	signature:(const char* cFileName)
FileExists	XYFile.h	/^	static bool FileExists(const char* cFileName);$/;"	p	class:CXYFile	access:public	signature:(const char* cFileName)
FindContactStartEndSegIndFromSegInd	XYSIS.cpp	/^void CXYSIS::FindContactStartEndSegIndFromSegInd(int iSegInd, vector<vector<int> > & vStartEndInd){$/;"	f	class:CXYSIS	signature:(int iSegInd, vector<vector<int> > & vStartEndInd)
FindContactStartEndSegIndFromSegInd	XYSIS.h	/^  void FindContactStartEndSegIndFromSegInd(int iSegInd, vector<vector<int> > & vStartEndInd);$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd, vector<vector<int> > & vStartEndInd)
FindContactStartEndSegIndFromSegInd_2	XYSIS.cpp	/^void CXYSIS::FindContactStartEndSegIndFromSegInd_2(int iSegInd, vector<vector<int> > & vStartEndInd){$/;"	f	class:CXYSIS	signature:(int iSegInd, vector<vector<int> > & vStartEndInd)
FindContactStartEndSegIndFromSegInd_2	XYSIS.h	/^  void FindContactStartEndSegIndFromSegInd_2(int iSegInd, vector<vector<int> > & vStartEndInd);$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd, vector<vector<int> > & vStartEndInd)
FindContactionTypeFromSegSegInd	XYSIS.cpp	/^int CXYSIS::FindContactionTypeFromSegSegInd(int iSegInd1, int iSegInd2){$/;"	f	class:CXYSIS	signature:(int iSegInd1, int iSegInd2)
FindContactionTypeFromSegSegInd	XYSIS.h	/^  int FindContactionTypeFromSegSegInd(int iSegInd1, int iSegInd2);$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd1, int iSegInd2)
FindNodeStartEndIndFromSegInd	XYSIS.cpp	/^void CXYSIS::FindNodeStartEndIndFromSegInd($/;"	f	class:CXYSIS	signature:( int iSegInd, int& iNodeStartInd, int& iNodeEndInd)
FindNodeStartEndIndFromSegInd	XYSIS.h	/^  void FindNodeStartEndIndFromSegInd(int iSegInd, $/;"	p	class:CXYSIS	access:public	signature:(int iSegInd, int& iNodeStartInd, int& iNodeEndInd)
FindSegIndFromNodeInd	XYSIS.cpp	/^int CXYSIS::FindSegIndFromNodeInd(int iNodeInd){$/;"	f	class:CXYSIS	signature:(int iNodeInd)
FindSegIndFromNodeInd	XYSIS.h	/^  int FindSegIndFromNodeInd(int iNodeInd);$/;"	p	class:CXYSIS	access:public	signature:(int iNodeInd)
FloatIntPair	XYSIS.h	/^typedef pair<float,int> FloatIntPair;$/;"	t
FloatIntPairCompare	XYSIS.h	/^struct FloatIntPairCompare{$/;"	s
FloatIntPairCompare::operator ()	XYSIS.h	/^  bool operator () ( const FloatIntPair& left, const FloatIntPair& right)$/;"	f	struct:FloatIntPairCompare	access:public	signature:( const FloatIntPair& left, const FloatIntPair& right)
GetAjust	XYSIS.cpp	/^float CXYSIS::GetAjust(void)$/;"	f	class:CXYSIS	signature:(void)
GetAjust	XYSIS.h	/^  float GetAjust(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetAltLoc	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetAltLoc()$/;"	f	class:CXYPDBAtom	signature:()
GetAltLoc	XYPDBAtom.h	/^	char *GetAltLoc();$/;"	p	class:CXYPDBAtom	access:public	signature:()
GetAtomicSym	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetAtomicSym()$/;"	f	class:CXYPDBAtom	signature:()
GetAtomicSym	XYPDBAtom.h	/^	char *GetAtomicSym();$/;"	p	class:CXYPDBAtom	access:public	signature:()
GetBendingAngleBeg	XYEnsemble.h	/^	float GetBendingAngleBeg(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
GetBendingAngleBeg	XYSIS.h	/^  float GetBendingAngleBeg(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetBendingAngleEnd	XYEnsemble.h	/^	float GetBendingAngleEnd(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
GetBendingAngleEnd	XYSIS.h	/^  float GetBendingAngleEnd(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetBranchDes	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetBranchDes()$/;"	f	class:CXYPDBAtom	signature:()
GetBranchDes	XYPDBAtom.h	/^	char *GetBranchDes();$/;"	p	class:CXYPDBAtom	access:public	signature:()
GetChainID	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetChainID()$/;"	f	class:CXYPDBAtom	signature:()
GetChainID	XYPDBAtom.h	/^	char *GetChainID();$/;"	p	class:CXYPDBAtom	access:public	signature:()
GetCharge	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetCharge()$/;"	f	class:CXYPDBAtom	signature:()
GetCharge	XYPDBAtom.h	/^	char *GetCharge();$/;"	p	class:CXYPDBAtom	access:public	signature:()
GetCollisionLength	XYEnsemble.cpp	/^float CXYEnsemble::GetCollisionLength(void)$/;"	f	class:CXYEnsemble	signature:(void)
GetCollisionLength	XYEnsemble.h	/^	float GetCollisionLength(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
GetCollisionLength	XYSIS.cpp	/^float CXYSIS::GetCollisionLength(void)$/;"	f	class:CXYSIS	signature:(void)
GetCollisionLength	XYSIS.h	/^  float GetCollisionLength(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetColumn	XYMatrix.h	/^    CXYVector<Real> GetColumn (int iCol) const;$/;"	p	class:CXYMatrix	access:public	signature:(int iCol) const
GetColumn	XYMatrix.inl	/^CXYVector<Real> CXYMatrix<Real>::GetColumn (int iCol) const$/;"	f	class:CXYMatrix	signature:(int iCol) const
GetColumnMajor	XYMatrix.h	/^	void GetColumnMajor (Real* afCMajor) const;$/;"	p	class:CXYMatrix	access:public	signature:(Real* afCMajor) const
GetColumnMajor	XYMatrix.inl	/^void CXYMatrix<Real>::GetColumnMajor (Real* afCMajor) const$/;"	f	class:CXYMatrix	signature:(Real* afCMajor) const
GetColumns	XYMatrix.h	/^    int GetColumns () const;$/;"	p	class:CXYMatrix	access:public	signature:() const
GetColumns	XYMatrix.inl	/^int CXYMatrix<Real>::GetColumns () const$/;"	f	class:CXYMatrix	signature:() const
GetContactMap	XYSIS.cpp	/^map<int, float> CXYSIS::GetContactMap(int iNode){$/;"	f	class:CXYSIS	signature:(int iNode)
GetContactMap	XYSIS.h	/^  map<int,float> GetContactMap(int iNode);$/;"	p	class:CXYSIS	access:public	signature:(int iNode)
GetCountContactNode	XYSIS.h	/^  int GetCountContactNode(int iNode);$/;"	p	class:CXYSIS	access:public	signature:(int iNode)
GetCountContactNode_All	XYSIS.h	/^  int GetCountContactNode_All(int iNode);$/;"	p	class:CXYSIS	access:public	signature:(int iNode)
GetCountContactNodesFromMap	XYSIS.cpp	/^int CXYSIS::GetCountContactNodesFromMap(int ind){$/;"	f	class:CXYSIS	signature:(int ind)
GetCountContactNodesFromMap	XYSIS.h	/^  int GetCountContactNodesFromMap(int ind);$/;"	p	class:CXYSIS	access:public	signature:(int ind)
GetDistFileName	XYSIS.cpp	/^char* CXYSIS::GetDistFileName(void)$/;"	f	class:CXYSIS	signature:(void)
GetDistFileName	XYSIS.h	/^  char* GetDistFileName(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetDistMatrix	XYSIS.cpp	/^CXYMatrix<float>& CXYSIS::GetDistMatrix(void)$/;"	f	class:CXYSIS	signature:(void)
GetDistMatrix	XYSIS.h	/^  CXYMatrix<float>& GetDistMatrix(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetEigenValue	XYLapack.cpp	/^Real CXYLapackEigen<Real>::GetEigenValue (int i) const$/;"	f	class:CXYLapackEigen	signature:(int i) const
GetEigenValue	XYLapack.h	/^	Real GetEigenValue (int i) const;$/;"	p	class:CXYLapackEigen	access:public	signature:(int i) const
GetEigenValues	XYLapack.cpp	/^CXYVector<Real> CXYLapackEigen<Real>::GetEigenValues() const$/;"	f	class:CXYLapackEigen	signature:() const
GetEigenValues	XYLapack.h	/^	CXYVector<Real> GetEigenValues() const;$/;"	p	class:CXYLapackEigen	access:public	signature:() const
GetEigenVector	XYLapack.cpp	/^CXYVector<Real> CXYLapackEigen<Real>::GetEigenVector (int i) const$/;"	f	class:CXYLapackEigen	signature:(int i) const
GetEigenVector	XYLapack.h	/^	CXYVector<Real> GetEigenVector (int i) const;$/;"	p	class:CXYLapackEigen	access:public	signature:(int i) const
GetEigenVectors	XYLapack.cpp	/^const CXYMatrix<Real>& CXYLapackEigen<Real>::GetEigenVectors () const$/;"	f	class:CXYLapackEigen	signature:() const
GetEigenVectors	XYLapack.h	/^	const CXYMatrix<Real>& GetEigenVectors () const;$/;"	p	class:CXYLapackEigen	access:public	signature:() const
GetEigenvalue	XYEigen.cpp	/^Real CXYEigen<Real>::GetEigenvalue (int i) const$/;"	f	class:CXYEigen	signature:(int i) const
GetEigenvalue	XYEigen.h	/^    Real GetEigenvalue (int i) const;$/;"	p	class:CXYEigen	access:public	signature:(int i) const
GetEigenvalues	XYEigen.cpp	/^const Real* CXYEigen<Real>::GetEigenvalues () const$/;"	f	class:CXYEigen	signature:() const
GetEigenvalues	XYEigen.h	/^    const Real* GetEigenvalues () const;$/;"	p	class:CXYEigen	access:public	signature:() const
GetEigenvector	XYEigen.cpp	/^CXYVector<Real> CXYEigen<Real>::GetEigenvector (int i) const$/;"	f	class:CXYEigen	signature:(int i) const
GetEigenvector	XYEigen.h	/^    CXYVector<Real> GetEigenvector (int i) const;$/;"	p	class:CXYEigen	access:public	signature:(int i) const
GetEigenvectors	XYEigen.cpp	/^const CXYMatrix<Real>& CXYEigen<Real>::GetEigenvectors () const$/;"	f	class:CXYEigen	signature:() const
GetEigenvectors	XYEigen.h	/^    const CXYMatrix<Real>& GetEigenvectors () const;$/;"	p	class:CXYEigen	access:public	signature:() const
GetElement	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetElement()$/;"	f	class:CXYPDBAtom	signature:()
GetElement	XYPDBAtom.h	/^	char *GetElement();$/;"	p	class:CXYPDBAtom	access:public	signature:()
GetGoodPoints	XYEnsemble.cpp	/^void CXYEnsemble::GetGoodPoints( CXYVector<float>& prvnode, CXYMatrix<float>& kMSamplesPoints,vector<int>& GoodPointInd, vector<int>& NoCollisionPointInd){$/;"	f	class:CXYEnsemble	signature:( CXYVector<float>& prvnode, CXYMatrix<float>& kMSamplesPoints,vector<int>& GoodPointInd, vector<int>& NoCollisionPointInd)
GetGoodPoints	XYEnsemble.h	/^  void GetGoodPoints( CXYVector<float>& prvnode, CXYMatrix<float>& kMSamplesPoints,vector<int>& GoodPointInd, vector<int>& NoCollisionPointInd);$/;"	p	class:CXYEnsemble	access:public	signature:( CXYVector<float>& prvnode, CXYMatrix<float>& kMSamplesPoints,vector<int>& GoodPointInd, vector<int>& NoCollisionPointInd)
GetICode	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetICode()$/;"	f	class:CXYPDBAtom	signature:()
GetICode	XYPDBAtom.h	/^	char *GetICode();$/;"	p	class:CXYPDBAtom	access:public	signature:()
GetInverse	XYMatrix.h	/^    bool GetInverse (CXYMatrix<Real>& rkInverse) const;$/;"	p	class:CXYMatrix	access:public	signature:(CXYMatrix<Real>& rkInverse) const
GetInverse	XYMatrix.inl	/^bool CXYMatrix<Real>::GetInverse (CXYMatrix<Real>& rkInverse) const$/;"	f	class:CXYMatrix	signature:(CXYMatrix<Real>& rkInverse) const
GetMiddlePoints	XYEnsemble.cpp	/^void CXYEnsemble::GetMiddlePoints(CXYVector<float>& StartPoint, CXYVector<float>& EndPoint, CXYMatrix<float> & MiddleEndPoints){$/;"	f	class:CXYEnsemble	signature:(CXYVector<float>& StartPoint, CXYVector<float>& EndPoint, CXYMatrix<float> & MiddleEndPoints)
GetMiddlePoints	XYEnsemble.h	/^  void GetMiddlePoints(CXYVector<float>& StartPoint, CXYVector<float>& EndPoint, CXYMatrix<float> & MiddleEndPoints);$/;"	p	class:CXYEnsemble	access:public	signature:(CXYVector<float>& StartPoint, CXYVector<float>& EndPoint, CXYMatrix<float> & MiddleEndPoints)
GetMiddlePoints	XYSIS.cpp	/^void CXYSIS::GetMiddlePoints(CXYVector<float>& StartPoint, CXYVector<float>& EndPoint, CXYMatrix<float> & MiddleEndPoints){$/;"	f	class:CXYSIS	signature:(CXYVector<float>& StartPoint, CXYVector<float>& EndPoint, CXYMatrix<float> & MiddleEndPoints)
GetMiddlePoints	XYSIS.h	/^  void GetMiddlePoints(CXYVector<float>& StartPoint, CXYVector<float>& EndPoint, CXYMatrix<float> & MiddleEndPoints);$/;"	p	class:CXYSIS	access:public	signature:(CXYVector<float>& StartPoint, CXYVector<float>& EndPoint, CXYMatrix<float> & MiddleEndPoints)
GetMmax	XYSIS.cpp	/^int CXYSIS::GetMmax(void)$/;"	f	class:CXYSIS	signature:(void)
GetMmax	XYSIS.h	/^  int GetMmax(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetName	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetName()$/;"	f	class:CXYPDBAtom	signature:()
GetName	XYPDBAtom.h	/^	char *GetName();$/;"	p	class:CXYPDBAtom	access:public	signature:()
GetNoConMaxDist	XYSIS.cpp	/^float CXYSIS::GetNoConMaxDist(int iSegInd){$/;"	f	class:CXYSIS	signature:(int iSegInd)
GetNoConMaxDist	XYSIS.h	/^  float GetNoConMaxDist(int iSegInd);$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd)
GetNodeNextPosition	XYSIS.cpp	/^CXYVector<float> CXYSIS::GetNodeNextPosition(tree<CXYVector<float> >::iterator  &ritNode, int iSegInd, int ind){$/;"	f	class:CXYSIS	signature:(tree<CXYVector<float> >::iterator &ritNode, int iSegInd, int ind)
GetNodeNextPosition	XYSIS.h	/^  CXYVector<float> GetNodeNextPosition(tree<CXYVector<float> >::iterator  &ritNode, int iSegInd, int ind);$/;"	p	class:CXYSIS	access:public	signature:(tree<CXYVector<float> >::iterator &ritNode, int iSegInd, int ind)
GetNodeSamples	XYEnsemble.h	/^	CXYMatrix<float> GetNodeSamples(tree<CXYVector<float> >::iterator  &itNode, int iSegInd);$/;"	p	class:CXYEnsemble	access:public	signature:(tree<CXYVector<float> >::iterator &itNode, int iSegInd)
GetNodeSamples	XYSIS.cpp	/^CXYMatrix<float> CXYSIS::GetNodeSamples(tree<CXYVector<float> >::iterator  &ritNode, int iSegInd)$/;"	f	class:CXYSIS	signature:(tree<CXYVector<float> >::iterator &ritNode, int iSegInd)
GetNodeSamples	XYSIS.h	/^  CXYMatrix<float> GetNodeSamples(tree<CXYVector<float> >::iterator  &itNode, int iSegInd);$/;"	p	class:CXYSIS	access:public	signature:(tree<CXYVector<float> >::iterator &itNode, int iSegInd)
GetNodeSet	XYSIS.cpp	/^vector<tree<CXYVector<float> >::iterator > CXYSIS::GetNodeSet(int iLevel)$/;"	f	class:CXYSIS	signature:(int iLevel)
GetNodeSet	XYSIS.h	/^  vector<tree<CXYVector<float> >::iterator > GetNodeSet(int iLevel);  $/;"	p	class:CXYSIS	access:public	signature:(int iLevel)
GetNucleusSphereDiameter	XYEnsemble.cpp	/^float CXYEnsemble::GetNucleusSphereDiameter(void)$/;"	f	class:CXYEnsemble	signature:(void)
GetNucleusSphereDiameter	XYEnsemble.h	/^	float GetNucleusSphereDiameter(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
GetNucleusSphereDiameter	XYSIS.cpp	/^float CXYSIS::GetNucleusSphereDiameter(void)$/;"	f	class:CXYSIS	signature:(void)
GetNucleusSphereDiameter	XYSIS.h	/^  float GetNucleusSphereDiameter(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetNumBendingAngle	XYEnsemble.h	/^	int GetNumBendingAngle(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
GetNumBendingAngle	XYSIS.h	/^  int GetNumBendingAngle(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetNumNodes	XYEnsemble.cpp	/^int CXYEnsemble::GetNumNodes(void){$/;"	f	class:CXYEnsemble	signature:(void)
GetNumNodes	XYEnsemble.h	/^	int GetNumNodes(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
GetNumNodes	XYSIS.cpp	/^int CXYSIS::GetNumNodes(void){$/;"	f	class:CXYSIS	signature:(void)
GetNumNodes	XYSIS.h	/^  int GetNumNodes(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetNumPoints	XYSO3Sequence.cpp	/^int CXYSO3Sequence::GetNumPoints(){$/;"	f	class:CXYSO3Sequence	signature:()
GetNumPoints	XYSO3Sequence.h	/^	int GetNumPoints();$/;"	p	class:CXYSO3Sequence	access:public	signature:()
GetNumTorsionAngle	XYEnsemble.h	/^	int GetNumTorsionAngle(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
GetNumTorsionAngle	XYSIS.h	/^  int GetNumTorsionAngle(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetOccupancy	XYPDBAtom.cpp	/^float CXYPDBAtom::GetOccupancy()$/;"	f	class:CXYPDBAtom	signature:()
GetOccupancy	XYPDBAtom.h	/^	float GetOccupancy();$/;"	p	class:CXYPDBAtom	access:public	signature:()
GetOneChain	XYSIS.cpp	/^void CXYSIS::GetOneChain(CXYMatrix<float>& rkM,$/;"	f	class:CXYSIS	signature:(CXYMatrix<float>& rkM, tree<CXYVector<float > >::iterator itNode)
GetOneChain	XYSIS.h	/^  void GetOneChain(CXYMatrix<float>& rkM,$/;"	p	class:CXYSIS	access:public	signature:(CXYMatrix<float>& rkM, tree<CXYVector<float > >::iterator itNode)
GetOutPath	XYEnsemble.cpp	/^char* CXYEnsemble::GetOutPath(void)$/;"	f	class:CXYEnsemble	signature:(void)
GetOutPath	XYEnsemble.h	/^	char* GetOutPath(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
GetOutPath	XYSIS.cpp	/^char* CXYSIS::GetOutPath(void)$/;"	f	class:CXYSIS	signature:(void)
GetOutPath	XYSIS.h	/^  char* GetOutPath(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetPDBAtoms	XYPDB.cpp	/^const vector<CXYPDBAtom >* CXYPDB::GetPDBAtoms() const$/;"	f	class:CXYPDB	signature:() const
GetPDBAtoms	XYPDB.cpp	/^vector<CXYPDBAtom >* CXYPDB::GetPDBAtoms()$/;"	f	class:CXYPDB	signature:()
GetPDBAtoms	XYPDB.h	/^	const vector<CXYPDBAtom >* GetPDBAtoms() const;$/;"	p	class:CXYPDB	access:public	signature:() const
GetPDBAtoms	XYPDB.h	/^	vector<CXYPDBAtom >* GetPDBAtoms();$/;"	p	class:CXYPDB	access:public	signature:()
GetPDBIndex	XYPDB.cpp	/^int CXYPDB::GetPDBIndex(int iResSeq)$/;"	f	class:CXYPDB	signature:(int iResSeq)
GetPDBIndex	XYPDB.h	/^    int GetPDBIndex(int iResSeq);$/;"	p	class:CXYPDB	access:public	signature:(int iResSeq)
GetPackingDensity	XYEnsemble.cpp	/^float CXYEnsemble::GetPackingDensity(void)$/;"	f	class:CXYEnsemble	signature:(void)
GetPackingDensity	XYEnsemble.h	/^	float GetPackingDensity(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
GetPackingDensity	XYSIS.cpp	/^float CXYSIS::GetPackingDensity(void)$/;"	f	class:CXYSIS	signature:(void)
GetPackingDensity	XYSIS.h	/^  float GetPackingDensity(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetPersistenceLength	XYEnsemble.cpp	/^float CXYEnsemble::GetPersistenceLength(void)$/;"	f	class:CXYEnsemble	signature:(void)
GetPersistenceLength	XYEnsemble.h	/^	float GetPersistenceLength(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
GetPersistenceLength	XYSIS.cpp	/^float CXYSIS::GetPersistenceLength(void)$/;"	f	class:CXYSIS	signature:(void)
GetPersistenceLength	XYSIS.h	/^  float GetPersistenceLength(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetPoint	XYPDBAtom.cpp	/^CXYPoint3D<float> CXYPDBAtom::GetPoint() const$/;"	f	class:CXYPDBAtom	signature:() const
GetPoint	XYPDBAtom.h	/^	CXYPoint3D<float> GetPoint() const;$/;"	p	class:CXYPDBAtom	access:public	signature:() const
GetPrvConPosition	XYSIS.cpp	/^CXYVector<float> CXYSIS::GetPrvConPosition(tree<CXYVector<float> >::iterator  &ritNode, int iSegInd){$/;"	f	class:CXYSIS	signature:(tree<CXYVector<float> >::iterator &ritNode, int iSegInd)
GetPrvConPosition	XYSIS.h	/^  CXYVector<float> GetPrvConPosition(tree<CXYVector<float> >::iterator  &ritNode, int iSegInd);$/;"	p	class:CXYSIS	access:public	signature:(tree<CXYVector<float> >::iterator &ritNode, int iSegInd)
GetPrvContactNumberFromSegInd	XYSIS.cpp	/^int CXYSIS::GetPrvContactNumberFromSegInd(int iSegInd){$/;"	f	class:CXYSIS	signature:(int iSegInd)
GetPrvContactNumberFromSegInd	XYSIS.h	/^  int GetPrvContactNumberFromSegInd(int iSegInd);$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd)
GetPrvContactNumberFromSegInd_2	XYSIS.cpp	/^int CXYSIS::GetPrvContactNumberFromSegInd_2(int iSegInd){$/;"	f	class:CXYSIS	signature:(int iSegInd)
GetPrvContactNumberFromSegInd_2	XYSIS.h	/^  int GetPrvContactNumberFromSegInd_2(int iSegInd);$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd)
GetPrvContactSegIndsFromSegInd	XYSIS.cpp	/^vector<int> CXYSIS::GetPrvContactSegIndsFromSegInd(int iSegInd){$/;"	f	class:CXYSIS	signature:(int iSegInd)
GetPrvContactSegIndsFromSegInd	XYSIS.h	/^  vector<int> GetPrvContactSegIndsFromSegInd(int iSegInd);$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd)
GetPrvContactSegIndsFromSegInd_2	XYSIS.cpp	/^vector<int> CXYSIS::GetPrvContactSegIndsFromSegInd_2(int iSegInd){$/;"	f	class:CXYSIS	signature:(int iSegInd)
GetPrvContactSegIndsFromSegInd_2	XYSIS.h	/^  vector<int> GetPrvContactSegIndsFromSegInd_2(int iSegInd);$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd)
GetPrvContactsDistFromMap	XYSIS.cpp	/^CXYVector<float> CXYSIS::GetPrvContactsDistFromMap(int ind){$/;"	f	class:CXYSIS	signature:(int ind)
GetPrvContactsDistFromMap	XYSIS.h	/^  CXYVector<float> GetPrvContactsDistFromMap(int ind);$/;"	p	class:CXYSIS	access:public	signature:(int ind)
GetPrvContactsDist_2	XYSIS.cpp	/^CXYVector<float> CXYSIS::GetPrvContactsDist_2(int iSegInd){$/;"	f	class:CXYSIS	signature:(int iSegInd)
GetPrvContactsDist_2	XYSIS.h	/^  CXYVector<float> GetPrvContactsDist_2(int iSegInd) ;$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd)
GetPrvContactsListFromMap	XYSIS.cpp	/^vector<int> CXYSIS::GetPrvContactsListFromMap(int ind){ $/;"	f	class:CXYSIS	signature:(int ind)
GetPrvContactsListFromMap	XYSIS.h	/^  vector<int> GetPrvContactsListFromMap(int ind);$/;"	p	class:CXYSIS	access:public	signature:(int ind)
GetQuantity	XYMatrix.h	/^    int GetQuantity () const;$/;"	p	class:CXYMatrix	access:public	signature:() const
GetQuantity	XYMatrix.inl	/^int CXYMatrix<Real>::GetQuantity () const$/;"	f	class:CXYMatrix	signature:() const
GetRecName	XYPDBAtom.cpp	/^char * CXYPDBAtom::GetRecName()$/;"	f	class:CXYPDBAtom	signature:()
GetRecName	XYPDBAtom.h	/^	char *GetRecName();$/;"	p	class:CXYPDBAtom	access:public	signature:()
GetRemoteInd	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetRemoteInd()$/;"	f	class:CXYPDBAtom	signature:()
GetRemoteInd	XYPDBAtom.h	/^	char *GetRemoteInd();$/;"	p	class:CXYPDBAtom	access:public	signature:()
GetResName	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetResName()$/;"	f	class:CXYPDBAtom	signature:()
GetResName	XYPDBAtom.h	/^	char *GetResName();$/;"	p	class:CXYPDBAtom	access:public	signature:()
GetResSeq	XYPDBAtom.cpp	/^int CXYPDBAtom::GetResSeq()$/;"	f	class:CXYPDBAtom	signature:()
GetResSeq	XYPDBAtom.h	/^	int GetResSeq();$/;"	p	class:CXYPDBAtom	access:public	signature:()
GetRho_1	XYSIS.cpp	/^float CXYSIS::GetRho_1(void)$/;"	f	class:CXYSIS	signature:(void)
GetRho_1	XYSIS.h	/^  float GetRho_1(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetRho_2	XYSIS.cpp	/^float CXYSIS::GetRho_2(void)$/;"	f	class:CXYSIS	signature:(void)
GetRho_2	XYSIS.h	/^  float GetRho_2(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetRho_3	XYSIS.cpp	/^float CXYSIS::GetRho_3(void)$/;"	f	class:CXYSIS	signature:(void)
GetRho_3	XYSIS.h	/^  float GetRho_3(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetRotMatrix	XYEnsemble.h	/^	CXYMatrix<float> GetRotMatrix(CXYMatrix<float> &rkMXYZ);$/;"	p	class:CXYEnsemble	access:public	signature:(CXYMatrix<float> &rkMXYZ)
GetRotMatrix	XYSIS.h	/^  CXYMatrix<float> GetRotMatrix(CXYMatrix<float> &rkMXYZ);$/;"	p	class:CXYSIS	access:public	signature:(CXYMatrix<float> &rkMXYZ)
GetRow	XYMatrix.h	/^    CXYVector<Real> GetRow (int iRow) const;$/;"	p	class:CXYMatrix	access:public	signature:(int iRow) const
GetRow	XYMatrix.inl	/^CXYVector<Real> CXYMatrix<Real>::GetRow (int iRow) const$/;"	f	class:CXYMatrix	signature:(int iRow) const
GetRows	XYMatrix.h	/^    int GetRows () const;$/;"	p	class:CXYMatrix	access:public	signature:() const
GetRows	XYMatrix.inl	/^int CXYMatrix<Real>::GetRows () const$/;"	f	class:CXYMatrix	signature:() const
GetSO3Sequence	XYSO3Sequence.cpp	/^CXYMatrix<float>& CXYSO3Sequence::GetSO3Sequence(){$/;"	f	class:CXYSO3Sequence	signature:()
GetSO3Sequence	XYSO3Sequence.h	/^	CXYMatrix<float>& GetSO3Sequence();$/;"	p	class:CXYSO3Sequence	access:public	signature:()
GetSamplesOrg	XYEnsemble.cpp	/^CXYMatrix<float> CXYEnsemble::GetSamplesOrg()$/;"	f	class:CXYEnsemble	signature:()
GetSamplesOrg	XYEnsemble.h	/^	CXYMatrix<float> GetSamplesOrg();$/;"	p	class:CXYEnsemble	access:public	signature:()
GetSamplesOrg	XYSIS.cpp	/^CXYMatrix<float> CXYSIS::GetSamplesOrg()$/;"	f	class:CXYSIS	signature:()
GetSamplesOrg	XYSIS.h	/^  CXYMatrix<float> GetSamplesOrg();$/;"	p	class:CXYSIS	access:public	signature:()
GetSegID	XYPDBAtom.cpp	/^char *CXYPDBAtom::GetSegID()$/;"	f	class:CXYPDBAtom	signature:()
GetSegID	XYPDBAtom.h	/^	char *GetSegID();$/;"	p	class:CXYPDBAtom	access:public	signature:()
GetSegLength	XYEnsemble.cpp	/^float CXYEnsemble::GetSegLength(int ind){$/;"	f	class:CXYEnsemble	signature:(int ind)
GetSegLength	XYEnsemble.h	/^	float GetSegLength(int ind);$/;"	p	class:CXYEnsemble	access:public	signature:(int ind)
GetSegLength	XYSIS.cpp	/^float CXYSIS::GetSegLength(int ind){$/;"	f	class:CXYSIS	signature:(int ind)
GetSegLength	XYSIS.h	/^  float GetSegLength(int ind);$/;"	p	class:CXYSIS	access:public	signature:(int ind)
GetSegLengths	XYEnsemble.cpp	/^vector<float> & CXYEnsemble::GetSegLengths(void){$/;"	f	class:CXYEnsemble	signature:(void)
GetSegLengths	XYEnsemble.h	/^	vector<float> & GetSegLengths(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
GetSegLengths	XYSIS.cpp	/^vector<float> & CXYSIS::GetSegLengths(void){$/;"	f	class:CXYSIS	signature:(void)
GetSegLengths	XYSIS.h	/^  vector<float> & GetSegLengths(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetSequenceBase	XYSO3Sequence.cpp	/^vector<int >& CXYSO3Sequence::GetSequenceBase(){$/;"	f	class:CXYSO3Sequence	signature:()
GetSequenceBase	XYSO3Sequence.h	/^	vector< int >& GetSequenceBase();$/;"	p	class:CXYSO3Sequence	access:public	signature:()
GetSerial	XYPDBAtom.cpp	/^int	CXYPDBAtom::GetSerial()$/;"	f	class:CXYPDBAtom	signature:()
GetSerial	XYPDBAtom.h	/^	int	GetSerial();$/;"	p	class:CXYPDBAtom	access:public	signature:()
GetSize	XYMatrix.h	/^    void GetSize (int& riRows, int& riCols) const;$/;"	p	class:CXYMatrix	access:public	signature:(int& riRows, int& riCols) const
GetSize	XYMatrix.inl	/^void CXYMatrix<Real>::GetSize (int& riRows, int& riCols) const$/;"	f	class:CXYMatrix	signature:(int& riRows, int& riCols) const
GetSize	XYVector.h	/^    int GetSize () const;$/;"	p	class:CXYVector	access:public	signature:() const
GetSize	XYVector.inl	/^int CXYVector<Real>::GetSize() const$/;"	f	class:CXYVector	signature:() const
GetTargetDistribution	XYSIS.cpp	/^void CXYSIS::GetTargetDistribution(void)$/;"	f	class:CXYSIS	signature:(void)
GetTargetDistribution	XYSIS.h	/^  void GetTargetDistribution(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetTau_t	XYSIS.cpp	/^float CXYSIS::GetTau_t(void)$/;"	f	class:CXYSIS	signature:(void)
GetTau_t	XYSIS.h	/^  float GetTau_t(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetTempFactor	XYPDBAtom.cpp	/^float CXYPDBAtom::GetTempFactor()$/;"	f	class:CXYPDBAtom	signature:()
GetTempFactor	XYPDBAtom.h	/^	float GetTempFactor();$/;"	p	class:CXYPDBAtom	access:public	signature:()
GetTorsionAngleBeg	XYEnsemble.h	/^	float GetTorsionAngleBeg(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
GetTorsionAngleBeg	XYSIS.h	/^  float GetTorsionAngleBeg(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetTorsionAngleEnd	XYEnsemble.h	/^	float GetTorsionAngleEnd(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
GetTorsionAngleEnd	XYSIS.h	/^  float GetTorsionAngleEnd(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GetTree	XYEnsemble.cpp	/^tree< CXYVector<float> >* CXYEnsemble::GetTree()$/;"	f	class:CXYEnsemble	signature:()
GetTree	XYEnsemble.h	/^	tree< CXYVector<float> >* GetTree();$/;"	p	class:CXYEnsemble	access:public	signature:()
GetTree	XYSIS.cpp	/^tree< CXYVector<float> >* CXYSIS::GetTree()$/;"	f	class:CXYSIS	signature:()
GetTree	XYSIS.h	/^  tree< CXYVector<float> >* GetTree();$/;"	p	class:CXYSIS	access:public	signature:()
GetX	XYPDBAtom.cpp	/^float CXYPDBAtom::GetX()$/;"	f	class:CXYPDBAtom	signature:()
GetX	XYPDBAtom.h	/^	float GetX();$/;"	p	class:CXYPDBAtom	access:public	signature:()
GetY	XYPDBAtom.cpp	/^float CXYPDBAtom::GetY()$/;"	f	class:CXYPDBAtom	signature:()
GetY	XYPDBAtom.h	/^	float GetY();$/;"	p	class:CXYPDBAtom	access:public	signature:()
GetZ	XYPDBAtom.cpp	/^float CXYPDBAtom::GetZ()$/;"	f	class:CXYPDBAtom	signature:()
GetZ	XYPDBAtom.h	/^	float GetZ();$/;"	p	class:CXYPDBAtom	access:public	signature:()
GrowChainSegment_AllSelect	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_AllSelect($/;"	f	class:CXYSIS	signature:( vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
GrowChainSegment_AllSelect	XYSIS.h	/^  void GrowChainSegment_AllSelect(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains,$/;"	p	class:CXYSIS	access:public	signature:(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
GrowChainSegment_BinSearchConstC	XYSIS.cpp	/^float CXYSIS::GrowChainSegment_BinSearchConstC(vector<FloatIntPair>& vfBeta_t)$/;"	f	class:CXYSIS	signature:(vector<FloatIntPair>& vfBeta_t)
GrowChainSegment_BinSearchConstC	XYSIS.h	/^  float GrowChainSegment_BinSearchConstC(vector<FloatIntPair>& vfBeta_t);$/;"	p	class:CXYSIS	access:public	signature:(vector<FloatIntPair>& vfBeta_t)
GrowChainSegment_CalBeta_t	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_CalBeta_t($/;"	f	class:CXYSIS	signature:( vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, vector<FloatIntPair>& vBeta_t)
GrowChainSegment_CalBeta_t	XYSIS.h	/^  void GrowChainSegment_CalBeta_t(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains,$/;"	p	class:CXYSIS	access:public	signature:(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, vector<FloatIntPair>& vBeta_t)
GrowChainSegment_CalBeta_t_2	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_CalBeta_t_2($/;"	f	class:CXYSIS	signature:( vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, vector<FloatIntPair>& vBeta_t)
GrowChainSegment_CalBeta_t_2	XYSIS.h	/^  void GrowChainSegment_CalBeta_t_2(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains,$/;"	p	class:CXYSIS	access:public	signature:(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, vector<FloatIntPair>& vBeta_t)
GrowChainSegment_GeneratePotentialPoints	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_GeneratePotentialPoints($/;"	f	class:CXYSIS	signature:( tree<CXYVector<float> >& tree_LV, tree<CXYVector<float> >::iterator & pos_LV, vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iNodeInd)
GrowChainSegment_GeneratePotentialPoints	XYSIS.h	/^  void GrowChainSegment_GeneratePotentialPoints(tree<CXYVector<float> >& tree_LV,$/;"	p	class:CXYSIS	access:public	signature:(tree<CXYVector<float> >& tree_LV, tree<CXYVector<float> >::iterator & pos_LV, vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iNodeInd)
GrowChainSegment_GetErr	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_GetErr(void){$/;"	f	class:CXYSIS	signature:(void)
GrowChainSegment_GetErr	XYSIS.h	/^  void GrowChainSegment_GetErr(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GrowChainSegment_GetErr_2	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_GetErr_2(void){$/;"	f	class:CXYSIS	signature:(void)
GrowChainSegment_GetErr_2	XYSIS.h	/^  void GrowChainSegment_GetErr_2(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GrowChainSegment_GetWeight	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_GetWeight(void){$/;"	f	class:CXYSIS	signature:(void)
GrowChainSegment_GetWeight	XYSIS.h	/^  void GrowChainSegment_GetWeight(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GrowChainSegment_InitRoot	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_InitRoot(void)$/;"	f	class:CXYSIS	signature:(void)
GrowChainSegment_InitRoot	XYSIS.h	/^  void GrowChainSegment_InitRoot(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GrowChainSegment_NoRestriction	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_NoRestriction(int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd){$/;"	f	class:CXYSIS	signature:(int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
GrowChainSegment_NoRestriction	XYSIS.h	/^  void GrowChainSegment_NoRestriction(int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd);$/;"	p	class:CXYSIS	access:public	signature:(int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
GrowChainSegment_RandSelect	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_RandSelect($/;"	f	class:CXYSIS	signature:( vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
GrowChainSegment_RandSelect	XYSIS.h	/^  void GrowChainSegment_RandSelect(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains,$/;"	p	class:CXYSIS	access:public	signature:(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
GrowChainSegment_RandSelect_2	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_RandSelect_2($/;"	f	class:CXYSIS	signature:( vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
GrowChainSegment_RandSelect_2	XYSIS.h	/^  void GrowChainSegment_RandSelect_2(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains,$/;"	p	class:CXYSIS	access:public	signature:(vector< vector<tree<CXYVector<float> >::iterator >* >& vvChains, vector< tree< CXYVector<float> >::iterator >& vitPrvNodes, int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
GrowChainSegment_SISAlgorithm	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_SISAlgorithm(void){$/;"	f	class:CXYSIS	signature:(void)
GrowChainSegment_SISAlgorithm	XYSIS.h	/^  void GrowChainSegment_SISAlgorithm(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GrowChainSegment_SISAlgorithm_2	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_SISAlgorithm_2(void){$/;"	f	class:CXYSIS	signature:(void)
GrowChainSegment_SISAlgorithm_2	XYSIS.h	/^  void GrowChainSegment_SISAlgorithm_2(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GrowChainSegment_SavePosInd	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_SavePosInd(void){$/;"	f	class:CXYSIS	signature:(void)
GrowChainSegment_SavePosInd	XYSIS.h	/^  void GrowChainSegment_SavePosInd(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GrowChainSegment_WritePtsArr	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_WritePtsArr(void){$/;"	f	class:CXYSIS	signature:(void)
GrowChainSegment_WritePtsArr	XYSIS.h	/^  void GrowChainSegment_WritePtsArr(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
GrowChainSegment_h1Function	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_h1Function(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	f	class:CXYSIS	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd)
GrowChainSegment_h1Function	XYSIS.h	/^  void GrowChainSegment_h1Function(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd)
GrowChainSegment_h1Function_2	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_h1Function_2(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	f	class:CXYSIS	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd)
GrowChainSegment_h1Function_2	XYSIS.h	/^  void GrowChainSegment_h1Function_2(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd)
GrowChainSegment_h2Function	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_h2Function(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	f	class:CXYSIS	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd)
GrowChainSegment_h2Function	XYSIS.h	/^  void GrowChainSegment_h2Function(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd)
GrowChainSegment_h2Function_2	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_h2Function_2(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	f	class:CXYSIS	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd, vector<int>& rvConInd, CXYVector<float>& rKV_Dist)
GrowChainSegment_h2Function_2	XYSIS.h	/^  void GrowChainSegment_h2Function_2(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd, vector<int> & rvConInd, CXYVector<float> & rKV_PrvDist)
GrowChainSegment_h3Function	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_h3Function(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	f	class:CXYSIS	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd, vector<vector<int > >& vStartEndInd)
GrowChainSegment_h3Function	XYSIS.h	/^  void GrowChainSegment_h3Function(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd, vector<vector<int > > & vStartEndInd)
GrowChainSegment_h3Function_2	XYSIS.cpp	/^void CXYSIS::GrowChainSegment_h3Function_2(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	f	class:CXYSIS	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd, vector<vector<int > >& vStartEndInd)
GrowChainSegment_h3Function_2	XYSIS.h	/^  void GrowChainSegment_h3Function_2(vector<tree<CXYVector<float> >::iterator >& vCurChain,$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator >& vCurChain, tree< CXYVector<float> >::iterator itPrvNode, int iSegInd, int iNodeInd, int iPrvNodeSegInd, vector<vector<int > > & vStartEndInd)
GrowOneChain	XYEnsemble.cpp	/^bool CXYEnsemble::GrowOneChain()$/;"	f	class:CXYEnsemble	signature:()
GrowOneChain	XYEnsemble.h	/^	bool GrowOneChain();$/;"	p	class:CXYEnsemble	access:public	signature:()
GrowOneChain_ByVector	XYSIS.cpp	/^void CXYSIS::GrowOneChain_ByVector($/;"	f	class:CXYSIS	signature:( tree< CXYVector<float> >::iterator &ritCurNode, tree< CXYVector<float> >::iterator &ritSurfNode, int SegInd, vector<tree<CXYVector<float> >::iterator>* pvChain)
GrowOneChain_ByVector	XYSIS.h	/^  void GrowOneChain_ByVector(  tree< CXYVector<float> >::iterator &ritCurNode, $/;"	p	class:CXYSIS	access:public	signature:( tree< CXYVector<float> >::iterator &ritCurNode, tree< CXYVector<float> >::iterator &ritSurfNode, int SegInd, vector<tree<CXYVector<float> >::iterator>* pvCahin)
GrowOneNode_Segment	XYSIS.h	/^  void GrowOneNode_Segment(tree< CXYVector<float> >::iterator &ritCurNode, $/;"	p	class:CXYSIS	access:public	signature:(tree< CXYVector<float> >::iterator &ritCurNode, tree< CXYVector<float> >::iterator &ritSurfNode, int SegInd, vector<tree<CXYVector<float> >::iterator>* pvChain)
GrowthChain	XYSIS.cpp	/^CXYMatrix<float> CXYSIS::GrowthChain(tree< CXYVector<float> >::iterator &ritNode, $/;"	f	class:CXYSIS	signature:(tree< CXYVector<float> >::iterator &ritNode, CXYVector<float> &rkVPoint)
GrowthChain	XYSIS.h	/^  CXYMatrix<float> GrowthChain(tree< CXYVector<float> >::iterator &ritNode, $/;"	p	class:CXYSIS	access:public	signature:(tree< CXYVector<float> >::iterator &ritNode, CXYVector<float> &rkVPoint)
GrowthChain_NoCon	XYSIS.cpp	/^CXYMatrix<float> CXYSIS::GrowthChain_NoCon(tree< CXYVector<float> >::iterator &ritNode,  CXYVector<float> &rkVPoint)$/;"	f	class:CXYSIS	signature:(tree< CXYVector<float> >::iterator &ritNode, CXYVector<float> &rkVPoint)
GrowthChain_NoCon	XYSIS.h	/^  CXYMatrix<float> GrowthChain_NoCon(tree< CXYVector<float> >::iterator &ritNode, $/;"	p	class:CXYSIS	access:public	signature:(tree< CXYVector<float> >::iterator &ritNode, CXYVector<float> &rkVPoint)
GrowthOneChain	XYSIS.cpp	/^bool CXYSIS::GrowthOneChain()$/;"	f	class:CXYSIS	signature:()
GrowthOneChain	XYSIS.h	/^  bool GrowthOneChain();$/;"	p	class:CXYSIS	access:public	signature:()
GuaranteeRotation	XYEigen.cpp	/^void CXYEigen<Real>::GuaranteeRotation ()$/;"	f	class:CXYEigen	signature:()
GuaranteeRotation	XYEigen.h	/^    void GuaranteeRotation ();$/;"	p	class:CXYEigen	access:private	signature:()
INFINITYCHECK	XYMath.h	7;"	d
IncrSortEigenStuffN	XYEigen.cpp	/^void CXYEigen<Real>::IncrSortEigenStuffN ()$/;"	f	class:CXYEigen	signature:()
IncrSortEigenStuffN	XYEigen.h	/^    void IncrSortEigenStuffN ();$/;"	p	class:CXYEigen	access:public	signature:()
IncreasingSort	XYEigen.cpp	/^void CXYEigen<Real>::IncreasingSort ()$/;"	f	class:CXYEigen	signature:()
IncreasingSort	XYEigen.h	/^    void IncreasingSort ();$/;"	p	class:CXYEigen	access:private	signature:()
Initialize	XYPDBAtom.cpp	/^void CXYPDBAtom::Initialize(void)$/;"	f	class:CXYPDBAtom	signature:(void)
Initialize	XYPDBAtom.h	/^	void Initialize(void);$/;"	p	class:CXYPDBAtom	access:public	signature:(void)
InitializeChain	XYEnsemble.cpp	/^void CXYEnsemble::InitializeChain()$/;"	f	class:CXYEnsemble	signature:()
InitializeChain	XYEnsemble.h	/^	void InitializeChain();$/;"	p	class:CXYEnsemble	access:public	signature:()
InitializeChain	XYSIS.cpp	/^void CXYSIS::InitializeChain()$/;"	f	class:CXYSIS	signature:()
InitializeChain	XYSIS.h	/^  void InitializeChain();$/;"	p	class:CXYSIS	access:public	signature:()
InitializeChain_SISRoot	XYSIS.cpp	/^void CXYSIS::InitializeChain_SISRoot()$/;"	f	class:CXYSIS	signature:()
InitializeChain_SISRoot	XYSIS.h	/^  void InitializeChain_SISRoot();$/;"	p	class:CXYSIS	access:public	signature:()
Integer64	XYMath.h	/^	typedef __int64 Integer64;$/;"	t
Integer64	XYMath.h	/^	typedef int64_t Integer64;$/;"	t
IsCollision	XYEnsemble.cpp	/^bool CXYEnsemble::IsCollision(CXYMatrix<float> & MiddleEndPoints){$/;"	f	class:CXYEnsemble	signature:(CXYMatrix<float> & MiddleEndPoints)
IsCollision	XYEnsemble.cpp	/^bool CXYEnsemble::IsCollision(CXYVector<float> kV_point)$/;"	f	class:CXYEnsemble	signature:(CXYVector<float> kV_point)
IsCollision	XYEnsemble.h	/^	bool IsCollision(CXYVector<float> kV_point);$/;"	p	class:CXYEnsemble	access:public	signature:(CXYVector<float> kV_point)
IsCollision	XYEnsemble.h	/^  bool IsCollision(CXYMatrix<float> & MiddleEndPoints);$/;"	p	class:CXYEnsemble	access:public	signature:(CXYMatrix<float> & MiddleEndPoints)
IsCollision	XYSIS.cpp	/^bool CXYSIS::IsCollision(OcTree<float,int>* octree_, CXYVector<float>& kV_point){$/;"	f	class:CXYSIS	signature:(OcTree<float,int>* octree_, CXYVector<float>& kV_point)
IsCollision	XYSIS.cpp	/^bool CXYSIS::IsCollision(OcTree<float,int>* pOctree_, float x_, float y_, float z_){$/;"	f	class:CXYSIS	signature:(OcTree<float,int>* pOctree_, float x_, float y_, float z_)
IsCollision	XYSIS.cpp	/^bool CXYSIS::IsCollision(tree<CXYVector<float> >::iterator  &ritNode, CXYVector<float> kV_point)$/;"	f	class:CXYSIS	signature:(tree<CXYVector<float> >::iterator &ritNode, CXYVector<float> kV_point)
IsCollision	XYSIS.h	/^  bool IsCollision(OcTree<float,int>* pOctree_, CXYVector<float>& kV_point);$/;"	p	class:CXYSIS	access:public	signature:(OcTree<float,int>* pOctree_, CXYVector<float>& kV_point)
IsCollision	XYSIS.h	/^  bool IsCollision(OcTree<float,int>* pOctree_, float x_, float y_, float z_);$/;"	p	class:CXYSIS	access:public	signature:(OcTree<float,int>* pOctree_, float x_, float y_, float z_)
IsCollision	XYSIS.h	/^  bool IsCollision(tree<CXYVector<float> >::iterator  &ritNode, CXYVector<float> kV_point);$/;"	p	class:CXYSIS	access:public	signature:(tree<CXYVector<float> >::iterator &ritNode, CXYVector<float> kV_point)
IsInsideSphere	XYEnsemble.cpp	/^bool CXYEnsemble::IsInsideSphere(CXYVector<float> kV_point)$/;"	f	class:CXYEnsemble	signature:(CXYVector<float> kV_point)
IsInsideSphere	XYEnsemble.cpp	/^bool CXYEnsemble::IsInsideSphere(float* fCoord)$/;"	f	class:CXYEnsemble	signature:(float* fCoord)
IsInsideSphere	XYEnsemble.h	/^	bool IsInsideSphere(CXYVector<float> kV_point);$/;"	p	class:CXYEnsemble	access:public	signature:(CXYVector<float> kV_point)
IsInsideSphere	XYEnsemble.h	/^	bool IsInsideSphere(float* fCoord);$/;"	p	class:CXYEnsemble	access:public	signature:(float* fCoord)
IsInsideSphere	XYSIS.cpp	/^bool CXYSIS::IsInsideSphere(CXYVector<float> kV_point)$/;"	f	class:CXYSIS	signature:(CXYVector<float> kV_point)
IsInsideSphere	XYSIS.cpp	/^bool CXYSIS::IsInsideSphere(float* fCoord)$/;"	f	class:CXYSIS	signature:(float* fCoord)
IsInsideSphere	XYSIS.h	/^  bool IsInsideSphere(CXYVector<float> kV_point);$/;"	p	class:CXYSIS	access:public	signature:(CXYVector<float> kV_point)
IsInsideSphere	XYSIS.h	/^  bool IsInsideSphere(float* fCoord);$/;"	p	class:CXYSIS	access:public	signature:(float* fCoord)
IsOverlap	XYSIS.cpp	/^bool CXYSIS::IsOverlap(OcTree<float,int>* octree_, CXYVector<float>& kV_point, float dr_){$/;"	f	class:CXYSIS	signature:(OcTree<float,int>* octree_, CXYVector<float>& kV_point, float dr_)
IsOverlap	XYSIS.cpp	/^bool CXYSIS::IsOverlap(OcTree<float,int>* pOctree_, float x_, float y_, float z_, float dr_){$/;"	f	class:CXYSIS	signature:(OcTree<float,int>* pOctree_, float x_, float y_, float z_, float dr_)
IsOverlap	XYSIS.h	/^  bool IsOverlap(OcTree<float,int>* pOctree_, CXYVector<float>& kV_point, float dr_);$/;"	p	class:CXYSIS	access:public	signature:(OcTree<float,int>* pOctree_, CXYVector<float>& kV_point, float dr_)
IsOverlap	XYSIS.h	/^  bool IsOverlap(OcTree<float,int>* pOctree_, float x_, float y_, float z_, float dr_);$/;"	p	class:CXYSIS	access:public	signature:(OcTree<float,int>* pOctree_, float x_, float y_, float z_, float dr_)
IsSatisfyCondition	XYEnsemble.cpp	/^bool CXYEnsemble::IsSatisfyCondition(CXYMatrix<float> & MiddleEndPoints){$/;"	f	class:CXYEnsemble	signature:(CXYMatrix<float> & MiddleEndPoints)
IsSatisfyCondition	XYEnsemble.h	/^  bool IsSatisfyCondition(CXYMatrix<float> & MiddleEndPoints);$/;"	p	class:CXYEnsemble	access:public	signature:(CXYMatrix<float> & MiddleEndPoints)
Iterator_Int_Map	XYSIS.h	/^  tree<CXYVector<float> >::iterator_base_less>  Iterator_Int_Map;$/;"	t
Iterator_OcTree_Map	XYSIS.h	/^  tree<CXYVector<float> >::iterator_base_less>  Iterator_OcTree_Map;$/;"	t
LapackEigenf	XYLapack.h	/^typedef CXYLapackEigen<float> LapackEigenf;$/;"	t
Lapack_SSYEV	XYLapack.cpp	/^void CXYLapackEigen<Real>::Lapack_SSYEV()$/;"	f	class:CXYLapackEigen	signature:()
Lapack_SSYEV	XYLapack.h	/^	void Lapack_SSYEV();$/;"	p	class:CXYLapackEigen	access:public	signature:()
Length	XYPoint3D.h	/^    Real Length () const;$/;"	p	class:CXYPoint3D	access:public	signature:() const
Length	XYPoint3D.inl	/^Real CXYPoint3D<Real>::Length () const$/;"	f	class:CXYPoint3D	signature:() const
Length	XYVector.h	/^    Real Length () const;$/;"	p	class:CXYVector	access:public	signature:() const
Length	XYVector.inl	/^Real CXYVector<Real>::Length () const$/;"	f	class:CXYVector	signature:() const
M	MersenneTwister.h	/^	enum { M = 397 };  \/\/ period parameter$/;"	e	enum:MTRand::__anon3
MAX_REAL	XYMath.cpp	/^	template<> const double CXYMath<double>::MAX_REAL = LLONG_MAX;$/;"	m	class:CXYMath	file:
MAX_REAL	XYMath.cpp	/^	template<> const double CXYMath<double>::MAX_REAL = _I64_MAX;$/;"	m	class:CXYMath	file:
MAX_REAL	XYMath.cpp	/^	template<> const float CXYMath<float>::MAX_REAL = LONG_MAX;$/;"	m	class:CXYMath	file:
MAX_REAL	XYMath.h	/^	static const Real MAX_REAL;$/;"	m	class:CXYMath	access:public
MAX_REPRESENTABLE_DEPTH	octree.h	55;"	d
MERSENNETWISTER_H	MersenneTwister.h	59;"	d
MTRand	MersenneTwister.h	/^	MTRand( const MTRand& o );  \/\/ copy$/;"	p	class:MTRand	access:public	signature:( const MTRand& o )
MTRand	MersenneTwister.h	/^	MTRand( const uint32 oneSeed );  \/\/ initialize with a simple uint32$/;"	p	class:MTRand	access:public	signature:( const uint32 oneSeed )
MTRand	MersenneTwister.h	/^	MTRand( uint32 *const bigSeed, uint32 const seedLength = N );  \/\/ or array$/;"	p	class:MTRand	access:public	signature:( uint32 *const bigSeed, uint32 const seedLength = N )
MTRand	MersenneTwister.h	/^	MTRand();  \/\/ auto-initialize with \/dev\/urandom or time() and clock()$/;"	p	class:MTRand	access:public	signature:()
MTRand	MersenneTwister.h	/^class MTRand {$/;"	c
MTRand	MersenneTwister.h	/^inline MTRand::MTRand( const MTRand& o )$/;"	f	class:MTRand	signature:( const MTRand& o )
MTRand	MersenneTwister.h	/^inline MTRand::MTRand( const uint32 oneSeed )$/;"	f	class:MTRand	signature:( const uint32 oneSeed )
MTRand	MersenneTwister.h	/^inline MTRand::MTRand( uint32 *const bigSeed, const uint32 seedLength )$/;"	f	class:MTRand	signature:( uint32 *const bigSeed, const uint32 seedLength )
MTRand	MersenneTwister.h	/^inline MTRand::MTRand()$/;"	f	class:MTRand	signature:()
MTRand::M	MersenneTwister.h	/^	enum { M = 397 };  \/\/ period parameter$/;"	e	enum:MTRand::__anon3
MTRand::MTRand	MersenneTwister.h	/^	MTRand( const MTRand& o );  \/\/ copy$/;"	p	class:MTRand	access:public	signature:( const MTRand& o )
MTRand::MTRand	MersenneTwister.h	/^	MTRand( const uint32 oneSeed );  \/\/ initialize with a simple uint32$/;"	p	class:MTRand	access:public	signature:( const uint32 oneSeed )
MTRand::MTRand	MersenneTwister.h	/^	MTRand( uint32 *const bigSeed, uint32 const seedLength = N );  \/\/ or array$/;"	p	class:MTRand	access:public	signature:( uint32 *const bigSeed, uint32 const seedLength = N )
MTRand::MTRand	MersenneTwister.h	/^	MTRand();  \/\/ auto-initialize with \/dev\/urandom or time() and clock()$/;"	p	class:MTRand	access:public	signature:()
MTRand::MTRand	MersenneTwister.h	/^inline MTRand::MTRand( const MTRand& o )$/;"	f	class:MTRand	signature:( const MTRand& o )
MTRand::MTRand	MersenneTwister.h	/^inline MTRand::MTRand( const uint32 oneSeed )$/;"	f	class:MTRand	signature:( const uint32 oneSeed )
MTRand::MTRand	MersenneTwister.h	/^inline MTRand::MTRand( uint32 *const bigSeed, const uint32 seedLength )$/;"	f	class:MTRand	signature:( uint32 *const bigSeed, const uint32 seedLength )
MTRand::MTRand	MersenneTwister.h	/^inline MTRand::MTRand()$/;"	f	class:MTRand	signature:()
MTRand::N	MersenneTwister.h	/^	enum { N = 624 };       \/\/ length of state vector$/;"	e	enum:MTRand::__anon1
MTRand::SAVE	MersenneTwister.h	/^	enum { SAVE = N + 1 };  \/\/ length of array for save()$/;"	e	enum:MTRand::__anon2
MTRand::hash	MersenneTwister.h	/^	static uint32 hash( time_t t, clock_t c );$/;"	p	class:MTRand	access:protected	signature:( time_t t, clock_t c )
MTRand::hash	MersenneTwister.h	/^inline MTRand::uint32 MTRand::hash( time_t t, clock_t c )$/;"	f	class:MTRand	signature:( time_t t, clock_t c )
MTRand::hiBit	MersenneTwister.h	/^	uint32 hiBit( const uint32 u ) const { return u & 0x80000000UL; }$/;"	f	class:MTRand	access:protected	signature:( const uint32 u ) const
MTRand::initialize	MersenneTwister.h	/^	void initialize( const uint32 oneSeed );$/;"	p	class:MTRand	access:protected	signature:( const uint32 oneSeed )
MTRand::initialize	MersenneTwister.h	/^inline void MTRand::initialize( const uint32 seed )$/;"	f	class:MTRand	signature:( const uint32 seed )
MTRand::left	MersenneTwister.h	/^	int left;          \/\/ number of values left before reload needed$/;"	m	class:MTRand	access:protected
MTRand::loBit	MersenneTwister.h	/^	uint32 loBit( const uint32 u ) const { return u & 0x00000001UL; }$/;"	f	class:MTRand	access:protected	signature:( const uint32 u ) const
MTRand::loBits	MersenneTwister.h	/^	uint32 loBits( const uint32 u ) const { return u & 0x7fffffffUL; }$/;"	f	class:MTRand	access:protected	signature:( const uint32 u ) const
MTRand::load	MersenneTwister.h	/^	void load( uint32 *const loadArray );  \/\/ from such array$/;"	p	class:MTRand	access:public	signature:( uint32 *const loadArray )
MTRand::load	MersenneTwister.h	/^inline void MTRand::load( uint32 *const loadArray )$/;"	f	class:MTRand	signature:( uint32 *const loadArray )
MTRand::magic	MersenneTwister.h	/^	uint32 magic( const uint32 u ) const$/;"	f	class:MTRand	access:protected	signature:( const uint32 u ) const
MTRand::mixBits	MersenneTwister.h	/^	uint32 mixBits( const uint32 u, const uint32 v ) const$/;"	f	class:MTRand	access:protected	signature:( const uint32 u, const uint32 v ) const
MTRand::operator ()	MersenneTwister.h	/^	double operator()();                  \/\/ same as rand()$/;"	p	class:MTRand	access:public	signature:()
MTRand::operator ()	MersenneTwister.h	/^inline double MTRand::operator()()$/;"	f	class:MTRand	signature:()
MTRand::operator <<	MersenneTwister.h	/^	friend std::ostream& operator<<( std::ostream& os, const MTRand& mtrand );$/;"	p	class:MTRand	access:friend	signature:( std::ostream& os, const MTRand& mtrand )
MTRand::operator =	MersenneTwister.h	/^	MTRand& operator=( const MTRand& o );$/;"	p	class:MTRand	access:public	signature:( const MTRand& o )
MTRand::operator =	MersenneTwister.h	/^inline MTRand& MTRand::operator=( const MTRand& o )$/;"	f	class:MTRand	signature:( const MTRand& o )
MTRand::operator >>	MersenneTwister.h	/^	friend std::istream& operator>>( std::istream& is, MTRand& mtrand );$/;"	p	class:MTRand	access:friend	signature:( std::istream& is, MTRand& mtrand )
MTRand::pNext	MersenneTwister.h	/^	uint32 *pNext;     \/\/ next value to get from state$/;"	m	class:MTRand	access:protected
MTRand::rand	MersenneTwister.h	/^	double rand( const double n );        \/\/ real number in [0,n]$/;"	p	class:MTRand	access:public	signature:( const double n )
MTRand::rand	MersenneTwister.h	/^	double rand();                        \/\/ real number in [0,1]$/;"	p	class:MTRand	access:public	signature:()
MTRand::rand	MersenneTwister.h	/^inline double MTRand::rand( const double n )$/;"	f	class:MTRand	signature:( const double n )
MTRand::rand	MersenneTwister.h	/^inline double MTRand::rand()$/;"	f	class:MTRand	signature:()
MTRand::rand53	MersenneTwister.h	/^	double rand53();  \/\/ real number in [0,1)$/;"	p	class:MTRand	access:public	signature:()
MTRand::rand53	MersenneTwister.h	/^inline double MTRand::rand53()$/;"	f	class:MTRand	signature:()
MTRand::randDblExc	MersenneTwister.h	/^	double randDblExc( const double n );  \/\/ real number in (0,n)$/;"	p	class:MTRand	access:public	signature:( const double n )
MTRand::randDblExc	MersenneTwister.h	/^	double randDblExc();                  \/\/ real number in (0,1)$/;"	p	class:MTRand	access:public	signature:()
MTRand::randDblExc	MersenneTwister.h	/^inline double MTRand::randDblExc( const double n )$/;"	f	class:MTRand	signature:( const double n )
MTRand::randDblExc	MersenneTwister.h	/^inline double MTRand::randDblExc()$/;"	f	class:MTRand	signature:()
MTRand::randExc	MersenneTwister.h	/^	double randExc( const double n );     \/\/ real number in [0,n)$/;"	p	class:MTRand	access:public	signature:( const double n )
MTRand::randExc	MersenneTwister.h	/^	double randExc();                     \/\/ real number in [0,1)$/;"	p	class:MTRand	access:public	signature:()
MTRand::randExc	MersenneTwister.h	/^inline double MTRand::randExc( const double n )$/;"	f	class:MTRand	signature:( const double n )
MTRand::randExc	MersenneTwister.h	/^inline double MTRand::randExc()$/;"	f	class:MTRand	signature:()
MTRand::randInt	MersenneTwister.h	/^	uint32 randInt( const uint32 n );     \/\/ integer in [0,n] for n < 2^32$/;"	p	class:MTRand	access:public	signature:( const uint32 n )
MTRand::randInt	MersenneTwister.h	/^	uint32 randInt();                     \/\/ integer in [0,2^32-1]$/;"	p	class:MTRand	access:public	signature:()
MTRand::randInt	MersenneTwister.h	/^inline MTRand::uint32 MTRand::randInt( const uint32 n )$/;"	f	class:MTRand	signature:( const uint32 n )
MTRand::randInt	MersenneTwister.h	/^inline MTRand::uint32 MTRand::randInt()$/;"	f	class:MTRand	signature:()
MTRand::randNorm	MersenneTwister.h	/^	double randNorm( const double mean = 0.0, const double stddev = 1.0 );$/;"	p	class:MTRand	access:public	signature:( const double mean = 0.0, const double stddev = 1.0 )
MTRand::randNorm	MersenneTwister.h	/^inline double MTRand::randNorm( const double mean, const double stddev )$/;"	f	class:MTRand	signature:( const double mean, const double stddev )
MTRand::reload	MersenneTwister.h	/^	void reload();$/;"	p	class:MTRand	access:protected	signature:()
MTRand::reload	MersenneTwister.h	/^inline void MTRand::reload()$/;"	f	class:MTRand	signature:()
MTRand::save	MersenneTwister.h	/^	void save( uint32* saveArray ) const;  \/\/ to array of size SAVE$/;"	p	class:MTRand	access:public	signature:( uint32* saveArray ) const
MTRand::save	MersenneTwister.h	/^inline void MTRand::save( uint32* saveArray ) const$/;"	f	class:MTRand	signature:( uint32* saveArray ) const
MTRand::seed	MersenneTwister.h	/^	void seed( const uint32 oneSeed );$/;"	p	class:MTRand	access:public	signature:( const uint32 oneSeed )
MTRand::seed	MersenneTwister.h	/^	void seed( uint32 *const bigSeed, const uint32 seedLength = N );$/;"	p	class:MTRand	access:public	signature:( uint32 *const bigSeed, const uint32 seedLength = N )
MTRand::seed	MersenneTwister.h	/^	void seed();$/;"	p	class:MTRand	access:public	signature:()
MTRand::seed	MersenneTwister.h	/^inline void MTRand::seed( const uint32 oneSeed )$/;"	f	class:MTRand	signature:( const uint32 oneSeed )
MTRand::seed	MersenneTwister.h	/^inline void MTRand::seed( uint32 *const bigSeed, const uint32 seedLength )$/;"	f	class:MTRand	signature:( uint32 *const bigSeed, const uint32 seedLength )
MTRand::seed	MersenneTwister.h	/^inline void MTRand::seed()$/;"	f	class:MTRand	signature:()
MTRand::state	MersenneTwister.h	/^	uint32 state[N];   \/\/ internal state$/;"	m	class:MTRand	access:protected
MTRand::twist	MersenneTwister.h	/^	uint32 twist( const uint32 m, const uint32 s0, const uint32 s1 ) const$/;"	f	class:MTRand	access:protected	signature:( const uint32 m, const uint32 s0, const uint32 s1 ) const
MTRand::uint32	MersenneTwister.h	/^	typedef unsigned long uint32;  \/\/ unsigned integer type, at least 32 bits$/;"	t	class:MTRand	access:public
MakeDirectory	XYFile.cpp	/^int CXYFile::MakeDirectory(char* sPath, int imode)$/;"	f	class:CXYFile	signature:(char* sPath, int imode)
MakeDirectory	XYFile.h	/^	static int MakeDirectory(char* sPath, int imode);$/;"	p	class:CXYFile	access:public	signature:(char* sPath, int imode)
MultiArray	XYSIS.h	/^typedef vector< vector< float> > MultiArray;$/;"	t
N	MersenneTwister.h	/^	enum { N = 624 };       \/\/ length of state vector$/;"	e	enum:MTRand::__anon1
NANCHECK	XYMath.h	8;"	d
NUM_OCTREE_NODE_TYPES	octree.h	/^    NUM_OCTREE_NODE_TYPES,$/;"	e	enum:spatialaggregate::OcTreeNodeType
NewXYZ	XYEnsemble.h	/^	CXYMatrix<float> NewXYZ(CXYVector<float> kV_0, CXYVector<float> kV_1, CXYVector<float> kV_2);$/;"	p	class:CXYEnsemble	access:public	signature:(CXYVector<float> kV_0, CXYVector<float> kV_1, CXYVector<float> kV_2)
NewXYZ	XYEnsemble.h	/^	CXYMatrix<float> NewXYZ(CXYVector<float> kV_1, CXYVector<float> kV_2);$/;"	p	class:CXYEnsemble	access:public	signature:(CXYVector<float> kV_1, CXYVector<float> kV_2)
NewXYZ	XYSIS.h	/^  CXYMatrix<float> NewXYZ(CXYVector<float> kV_0, CXYVector<float> kV_1, CXYVector<float> kV_2);$/;"	p	class:CXYSIS	access:public	signature:(CXYVector<float> kV_0, CXYVector<float> kV_1, CXYVector<float> kV_2)
NewXYZ	XYSIS.h	/^  CXYMatrix<float> NewXYZ(CXYVector<float> kV_1, CXYVector<float> kV_2);$/;"	p	class:CXYSIS	access:public	signature:(CXYVector<float> kV_1, CXYVector<float> kV_2)
Normalize	XYVector.h	/^    Real Normalize ();$/;"	p	class:CXYVector	access:public	signature:()
Normalize	XYVector.inl	/^Real CXYVector<Real>::Normalize ()$/;"	f	class:CXYVector	signature:()
OCTREE_BRANCHING_NODE	octree.h	/^    OCTREE_BRANCHING_NODE,$/;"	e	enum:spatialaggregate::OcTreeNodeType
OCTREE_LEAF_NODE	octree.h	/^    OCTREE_LEAF_NODE,$/;"	e	enum:spatialaggregate::OcTreeNodeType
OcTree	octree.h	/^		OcTree( const Eigen::Matrix< CoordType, 4, 1 >& center, CoordType minimumVolumeSize, CoordType maxDistance, boost::shared_ptr< OcTreeNodeAllocator< CoordType, ValueType > > allocator );$/;"	p	class:spatialaggregate::OcTree	access:public	signature:( const Eigen::Matrix< CoordType, 4, 1 >& center, CoordType minimumVolumeSize, CoordType maxDistance, boost::shared_ptr< OcTreeNodeAllocator< CoordType, ValueType > > allocator )
OcTree	octree.h	/^  class OcTree {$/;"	c	namespace:spatialaggregate
OcTree	octree.h	/^  template< typename CoordType, typename ValueType > class OcTree;$/;"	x
OcTree	octree.hpp	/^spatialaggregate::OcTree< CoordType, ValueType >::OcTree( const Eigen::Matrix< CoordType, 4, 1 >& center, CoordType minimumVolumeSize, CoordType maxDistance, boost::shared_ptr< spatialaggregate::OcTreeNodeAllocator< CoordType, ValueType > > allocator ) {$/;"	f	class:spatialaggregate::OcTree	signature:( const Eigen::Matrix< CoordType, 4, 1 >& center, CoordType minimumVolumeSize, CoordType maxDistance, boost::shared_ptr< spatialaggregate::OcTreeNodeAllocator< CoordType, ValueType > > allocator )
OcTreeKey	octree.h	/^    OcTreeKey( const CoordType& x, const CoordType& y, const CoordType& z, OcTree< CoordType, ValueType >* tree ) {$/;"	f	class:spatialaggregate::OcTreeKey	access:public	signature:( const CoordType& x, const CoordType& y, const CoordType& z, OcTree< CoordType, ValueType >* tree )
OcTreeKey	octree.h	/^    OcTreeKey( const Eigen::Matrix< CoordType, 4, 1 >& position, OcTree< CoordType, ValueType >* tree ) {$/;"	f	class:spatialaggregate::OcTreeKey	access:public	signature:( const Eigen::Matrix< CoordType, 4, 1 >& position, OcTree< CoordType, ValueType >* tree )
OcTreeKey	octree.h	/^    OcTreeKey( uint32_t x, uint32_t y, uint32_t z )$/;"	f	class:spatialaggregate::OcTreeKey	access:public	signature:( uint32_t x, uint32_t y, uint32_t z )
OcTreeKey	octree.h	/^    OcTreeKey() {}$/;"	f	class:spatialaggregate::OcTreeKey	access:public	signature:()
OcTreeKey	octree.h	/^  class OcTreeKey {$/;"	c	namespace:spatialaggregate
OcTreeNode	octree.h	/^    OcTreeNode( OcTreeNodeType type ) { $/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:( OcTreeNodeType type )
OcTreeNode	octree.h	/^    OcTreeNode( OcTreeNodeType type, boost::shared_ptr< OcTree< CoordType, ValueType > > tree ) {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:( OcTreeNodeType type, boost::shared_ptr< OcTree< CoordType, ValueType > > tree )
OcTreeNode	octree.h	/^    OcTreeNode() { $/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:()
OcTreeNode	octree.h	/^  class OcTreeNode {$/;"	c	namespace:spatialaggregate
OcTreeNodeAllocator	octree.h	/^    OcTreeNodeAllocator() {}$/;"	f	class:spatialaggregate::OcTreeNodeAllocator	access:public	signature:()
OcTreeNodeAllocator	octree.h	/^  class OcTreeNodeAllocator : public boost::enable_shared_from_this< OcTreeNodeAllocator< CoordType, ValueType > > {$/;"	c	namespace:spatialaggregate	inherits:boost::enable_shared_from_this
OcTreeNodeAllocator	octree.h	/^  template< typename CoordType, typename ValueType > class OcTreeNodeAllocator;$/;"	x
OcTreeNodeDynamicAllocator	octree.h	/^    OcTreeNodeDynamicAllocator( unsigned int block_size )$/;"	f	class:spatialaggregate::OcTreeNodeDynamicAllocator	access:public	signature:( unsigned int block_size )
OcTreeNodeDynamicAllocator	octree.h	/^  class OcTreeNodeDynamicAllocator : public OcTreeNodeAllocator< CoordType, ValueType > {$/;"	c	namespace:spatialaggregate	inherits:OcTreeNodeAllocator
OcTreeNodeFixedCountAllocator	octree.h	/^    OcTreeNodeFixedCountAllocator( unsigned int numPoints ) {$/;"	f	class:spatialaggregate::OcTreeNodeFixedCountAllocator	access:public	signature:( unsigned int numPoints )
OcTreeNodeFixedCountAllocator	octree.h	/^  class OcTreeNodeFixedCountAllocator : public OcTreeNodeAllocator< CoordType, ValueType > {$/;"	c	namespace:spatialaggregate	inherits:OcTreeNodeAllocator
OcTreeNodeType	octree.h	/^  enum OcTreeNodeType {$/;"	g	namespace:spatialaggregate
PI	XYMath.cpp	/^template<> const float CXYMath<float>::PI = 3.1415926;$/;"	m	class:CXYMath	file:
PI	XYMath.h	/^	static const Real PI; \/\/ pi$/;"	m	class:CXYMath	access:public
Pool	octree.h	/^    typedef typename std::list< std::vector< T, Eigen::aligned_allocator< T > > > Pool;$/;"	t	class:spatialaggregate::DynamicAllocator	access:public
PoolIterator	octree.h	/^    typedef typename std::list< std::vector< T, Eigen::aligned_allocator< T > > >::iterator PoolIterator;$/;"	t	class:spatialaggregate::DynamicAllocator	access:public
PostDealPDB	XYPDB.cpp	/^void CXYPDB::PostDealPDB(char* sLevel)$/;"	f	class:CXYPDB	signature:(char* sLevel)
PostDealPDB	XYPDB.h	/^	void PostDealPDB(char* sLevel);$/;"	p	class:CXYPDB	access:public	signature:(char* sLevel)
QForm	XYMatrix.h	/^    Real QForm (const CXYVector<Real>& rkU, const CXYVector<Real>& rkV)$/;"	p	class:CXYMatrix	access:public	signature:(const CXYVector<Real>& rkU, const CXYVector<Real>& rkV) const
QForm	XYMatrix.inl	/^Real CXYMatrix<Real>::QForm (const CXYVector<Real>& rkU, const CXYVector<Real>& rkV)$/;"	f	class:CXYMatrix	signature:(const CXYVector<Real>& rkU, const CXYVector<Real>& rkV) const
QLAlgorithm	XYEigen.cpp	/^bool CXYEigen<Real>::QLAlgorithm ()$/;"	f	class:CXYEigen	signature:()
QLAlgorithm	XYEigen.h	/^    bool QLAlgorithm ();$/;"	p	class:CXYEigen	access:private	signature:()
Quaternion	XYSO3Sequence.h	/^typedef struct Quaternion {$/;"	s
Quaternion	XYSO3Sequence.h	/^} Quaternion;$/;"	t	typeref:struct:Quaternion
Quaternion::w	XYSO3Sequence.h	/^	double w;$/;"	m	struct:Quaternion	access:public
Quaternion::x	XYSO3Sequence.h	/^	double x;$/;"	m	struct:Quaternion	access:public
Quaternion::y	XYSO3Sequence.h	/^	double y;$/;"	m	struct:Quaternion	access:public
Quaternion::z	XYSO3Sequence.h	/^	double z;$/;"	m	struct:Quaternion	access:public
RANDOM_MAX	XYUtility.h	/^const int RANDOM_MAX = 32767;$/;"	v
RandPerm	XYUtility.cpp	/^vector<int> CXYUtility::RandPerm( vector<int>& kV )$/;"	f	class:CXYUtility	signature:( vector<int>& kV )
RandPerm	XYUtility.h	/^	static vector<int> RandPerm(vector<int>& kV);$/;"	p	class:CXYUtility	access:public	signature:(vector<int>& kV)
RandomPermutation	XYSIS.cpp	/^void CXYSIS::RandomPermutation(int ArrN[], int n, int ArrM[], int m){ \/\/ m <= n$/;"	f	class:CXYSIS	signature:(int ArrN[], int n, int ArrM[], int m)
RandomPermutation	XYSIS.h	/^  void RandomPermutation(int ArrN[], int n, int ArrM[], int m); \/\/ N > M$/;"	p	class:CXYSIS	access:public	signature:(int ArrN[], int n, int ArrM[], int m)
ReadAtomsFromPDB	XYFile.cpp	/^CXYPDB CXYFile::ReadAtomsFromPDB(const char* acfname)$/;"	f	class:CXYFile	signature:(const char* acfname)
ReadAtomsFromPDB	XYFile.h	/^	static CXYPDB ReadAtomsFromPDB(const char* acfname);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname)
ReadCSV	XYFile.cpp	/^void CXYFile::ReadCSV(istream& in, vector<vector<string>*>& data) {$/;"	f	class:CXYFile	signature:(istream& in, vector<vector<string>*>& data)
ReadCSV	XYFile.h	/^	static void ReadCSV(istream& in, vector<vector<string>*>& data);$/;"	p	class:CXYFile	access:public	signature:(istream& in, vector<vector<string>*>& data)
ReadLine	XYPDBAtom.cpp	/^void CXYPDBAtom::ReadLine(const char *acBuffLine)$/;"	f	class:CXYPDBAtom	signature:(const char *acBuffLine)
ReadLine	XYPDBAtom.h	/^	void ReadLine(const char *acBuffLine);$/;"	p	class:CXYPDBAtom	access:public	signature:(const char *acBuffLine)
ReadMatrix	XYFile.cpp	/^CXYMatrixf CXYFile::ReadMatrix(const char* acfname)$/;"	f	class:CXYFile	signature:(const char* acfname)
ReadMatrix	XYFile.cpp	/^CXYMatrixf CXYFile::ReadMatrix(const char* acfname, int iNumRowSkip, int iNumColSkip)$/;"	f	class:CXYFile	signature:(const char* acfname, int iNumRowSkip, int iNumColSkip)
ReadMatrix	XYFile.h	/^	static CXYMatrixf ReadMatrix(const char* acfname);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname)
ReadMatrix	XYFile.h	/^	static CXYMatrixf ReadMatrix(const char* acfname, int iNumRowSkip, int iNumColSkip);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname, int iNumRowSkip, int iNumColSkip)
ReadSparseMatrix	XYFile.cpp	/^CXYMatrixf CXYFile::ReadSparseMatrix(const char* acfname)$/;"	f	class:CXYFile	signature:(const char* acfname)
ReadSparseMatrix	XYFile.h	/^	static CXYMatrixf ReadSparseMatrix(const char* acfname);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname)
ReadSparseMatrixToTriple	XYFile.cpp	/^vector<CXYTriple<int, int, float> > CXYFile::ReadSparseMatrixToTriple(const char* acfname)$/;"	f	class:CXYFile	signature:(const char* acfname)
ReadSparseMatrixToTriple	XYFile.h	/^  vector<CXYTriple<int, int, float> > ReadSparseMatrixToTriple(const char* acfname);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname)
ReadVector	XYFile.cpp	/^CXYVector<float> CXYFile::ReadVector(const char* acfname)$/;"	f	class:CXYFile	signature:(const char* acfname)
ReadVector	XYFile.h	/^	static CXYVector<float> ReadVector(const char* acfname);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname)
ReadVectorInt	XYFile.cpp	/^CXYVector<int> CXYFile::ReadVectorInt(const char* acfname)$/;"	f	class:CXYFile	signature:(const char* acfname)
ReadVectorInt	XYFile.h	/^	static CXYVector<int> ReadVectorInt(const char* acfname);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname)
ReduceToSCOfCA	XYPDB.cpp	/^void CXYPDB::ReduceToSCOfCA(void)$/;"	f	class:CXYPDB	signature:(void)
ReduceToSCOfCA	XYPDB.h	/^	void ReduceToSCOfCA(void);$/;"	p	class:CXYPDB	access:public	signature:(void)
RefOrder	XYSIS.h	/^struct RefOrder {$/;"	s
RefOrder::operator ()	XYSIS.h	/^  bool operator ()(pair<int, int> const& left, pair<int, int> const& right) {$/;"	f	struct:RefOrder	access:public	signature:(pair<int, int> const& left, pair<int, int> const& right)
RndSetStartPoint	XYEnsemble.cpp	/^CXYVector<float> CXYEnsemble::RndSetStartPoint(void)$/;"	f	class:CXYEnsemble	signature:(void)
RndSetStartPoint	XYEnsemble.h	/^	CXYVector<float> RndSetStartPoint(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
RndSetStartPoint	XYSIS.cpp	/^CXYVector<float> CXYSIS::RndSetStartPoint(void)$/;"	f	class:CXYSIS	signature:(void)
RndSetStartPoint	XYSIS.h	/^  CXYVector<float> RndSetStartPoint(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
SAVE	MersenneTwister.h	/^	enum { SAVE = N + 1 };  \/\/ length of array for save()$/;"	e	enum:MTRand::__anon2
SIGNCHECK	XYMath.h	9;"	d
SIS_Algorithm	XYSIS.cpp	/^void CXYSIS::SIS_Algorithm(void)$/;"	f	class:CXYSIS	signature:(void)
SIS_Algorithm	XYSIS.h	/^  void SIS_Algorithm(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
SPOTRI	XYLapack.cpp	/^	extern "C" int SPOTRI(char *uplo, int *n, float *a, int *lda, int *info);$/;"	p	file:	signature:(char *uplo, int *n, float *a, int *lda, int *info)
SSYEV	XYLapack.cpp	/^	extern "C"  int SSYEV(char *jobz, char *uplo, int *n, float *a, $/;"	p	file:	signature:(char *jobz, char *uplo, int *n, float *a, int *lda, float *w, float *work, int *lwork, int *info)
SetAjust	XYSIS.cpp	/^void CXYSIS::SetAjust(float fAjust)$/;"	f	class:CXYSIS	signature:(float fAjust)
SetAjust	XYSIS.h	/^  void SetAjust(float fAjust);$/;"	p	class:CXYSIS	access:public	signature:(float fAjust)
SetAltLoc	XYPDBAtom.cpp	/^void CXYPDBAtom::SetAltLoc(char *acAltLoc)$/;"	f	class:CXYPDBAtom	signature:(char *acAltLoc)
SetAltLoc	XYPDBAtom.h	/^	void SetAltLoc(char *acAltLoc);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acAltLoc)
SetAtomicSym	XYPDBAtom.cpp	/^void CXYPDBAtom::SetAtomicSym(char *acAtomicSym)$/;"	f	class:CXYPDBAtom	signature:(char *acAtomicSym)
SetAtomicSym	XYPDBAtom.h	/^	void SetAtomicSym(char *acAtomicSym);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acAtomicSym)
SetBendingAngleBeg	XYEnsemble.h	/^	void SetBendingAngleBeg(float fAng);$/;"	p	class:CXYEnsemble	access:public	signature:(float fAng)
SetBendingAngleBeg	XYSIS.h	/^  void SetBendingAngleBeg(float fAng);$/;"	p	class:CXYSIS	access:public	signature:(float fAng)
SetBendingAngleEnd	XYEnsemble.h	/^	void SetBendingAngleEnd(float fAng);$/;"	p	class:CXYEnsemble	access:public	signature:(float fAng)
SetBendingAngleEnd	XYSIS.h	/^  void SetBendingAngleEnd(float fAng);$/;"	p	class:CXYSIS	access:public	signature:(float fAng)
SetBranchDes	XYPDBAtom.cpp	/^void CXYPDBAtom::SetBranchDes(char *acBranchDes)$/;"	f	class:CXYPDBAtom	signature:(char *acBranchDes)
SetBranchDes	XYPDBAtom.h	/^	void SetBranchDes(char *acBranchDes);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acBranchDes)
SetChainID	XYPDBAtom.cpp	/^void CXYPDBAtom::SetChainID(char *acChainID)$/;"	f	class:CXYPDBAtom	signature:(char *acChainID)
SetChainID	XYPDBAtom.h	/^	void SetChainID(char *acChainID);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acChainID)
SetCharge	XYPDBAtom.cpp	/^void CXYPDBAtom::SetCharge(char *acCharge)$/;"	f	class:CXYPDBAtom	signature:(char *acCharge)
SetCharge	XYPDBAtom.h	/^	void SetCharge(char *acCharge);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acCharge)
SetCollisionLength	XYEnsemble.cpp	/^void CXYEnsemble::SetCollisionLength(float fCollision)$/;"	f	class:CXYEnsemble	signature:(float fCollision)
SetCollisionLength	XYEnsemble.h	/^	void SetCollisionLength(float fCollision);$/;"	p	class:CXYEnsemble	access:public	signature:(float fCollision)
SetCollisionLength	XYSIS.cpp	/^void CXYSIS::SetCollisionLength(float fCollision)$/;"	f	class:CXYSIS	signature:(float fCollision)
SetCollisionLength	XYSIS.h	/^  void SetCollisionLength(float fCollision);$/;"	p	class:CXYSIS	access:public	signature:(float fCollision)
SetColumn	XYMatrix.h	/^    void SetColumn (int iCol, const CXYVector<Real>& rkV);$/;"	p	class:CXYMatrix	access:public	signature:(int iCol, const CXYVector<Real>& rkV)
SetColumn	XYMatrix.inl	/^void CXYMatrix<Real>::SetColumn (int iCol, const CXYVector<Real>& rkV)$/;"	f	class:CXYMatrix	signature:(int iCol, const CXYVector<Real>& rkV)
SetContIndex	XYEnsemble.cpp	/^void CXYEnsemble::SetContIndex(char* cContIndFile){$/;"	f	class:CXYEnsemble	signature:(char* cContIndFile)
SetContIndex	XYEnsemble.cpp	/^void CXYEnsemble::SetContIndex(void){$/;"	f	class:CXYEnsemble	signature:(void)
SetContIndex	XYEnsemble.h	/^	void SetContIndex(char* cContIndFile);$/;"	p	class:CXYEnsemble	access:public	signature:(char* cContIndFile)
SetContIndex	XYEnsemble.h	/^  void SetContIndex(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
SetContIndex	XYSIS.cpp	/^void CXYSIS::SetContIndex(char* cContIndFile){$/;"	f	class:CXYSIS	signature:(char* cContIndFile)
SetContIndex	XYSIS.cpp	/^void CXYSIS::SetContIndex(void){$/;"	f	class:CXYSIS	signature:(void)
SetContIndex	XYSIS.h	/^  void SetContIndex(char* cContIndFile);$/;"	p	class:CXYSIS	access:public	signature:(char* cContIndFile)
SetContIndex	XYSIS.h	/^  void SetContIndex(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
SetDistFileName	XYSIS.cpp	/^void CXYSIS::SetDistFileName(char* cFileName)$/;"	f	class:CXYSIS	signature:(char* cFileName)
SetDistFileName	XYSIS.h	/^  void SetDistFileName(char* cFileName);$/;"	p	class:CXYSIS	access:public	signature:(char* cFileName)
SetDistMatrix	XYSIS.cpp	/^void CXYSIS::SetDistMatrix(void)$/;"	f	class:CXYSIS	signature:(void)
SetDistMatrix	XYSIS.h	/^  void SetDistMatrix(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
SetDistQuantile	XYSIS.cpp	/^void CXYSIS::SetDistQuantile(char* cFN){$/;"	f	class:CXYSIS	signature:(char* cFN)
SetDistQuantile	XYSIS.h	/^  void SetDistQuantile(char* cFN);$/;"	p	class:CXYSIS	access:public	signature:(char* cFN)
SetElement	XYPDBAtom.cpp	/^void CXYPDBAtom::SetElement(char *acElement)$/;"	f	class:CXYPDBAtom	signature:(char *acElement)
SetElement	XYPDBAtom.h	/^	void SetElement(char *acElement);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acElement)
SetICode	XYPDBAtom.cpp	/^void CXYPDBAtom::SetICode(char *acICode)$/;"	f	class:CXYPDBAtom	signature:(char *acICode)
SetICode	XYPDBAtom.h	/^	void SetICode(char *acICode);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acICode)
SetLwork	XYLapack.cpp	/^void CXYLapackEigen<Real>::SetLwork()$/;"	f	class:CXYLapackEigen	signature:()
SetLwork	XYLapack.h	/^	void SetLwork();$/;"	p	class:CXYLapackEigen	access:public	signature:()
SetMatrix	XYMatrix.h	/^	void SetMatrix (int iRows, int iCols, const Real* afEntry);$/;"	p	class:CXYMatrix	access:public	signature:(int iRows, int iCols, const Real* afEntry)
SetMatrix	XYMatrix.h	/^    void SetMatrix (int iRows, int iCols, const Real** aafMatrix);$/;"	p	class:CXYMatrix	access:public	signature:(int iRows, int iCols, const Real** aafMatrix)
SetMatrix	XYMatrix.inl	/^void CXYMatrix<Real>::SetMatrix (int iRows, int iCols, const Real* afData)$/;"	f	class:CXYMatrix	signature:(int iRows, int iCols, const Real* afData)
SetMatrix	XYMatrix.inl	/^void CXYMatrix<Real>::SetMatrix (int iRows, int iCols, const Real** aafEntry)$/;"	f	class:CXYMatrix	signature:(int iRows, int iCols, const Real** aafEntry)
SetMmax	XYSIS.cpp	/^void CXYSIS::SetMmax(int iMmax)$/;"	f	class:CXYSIS	signature:(int iMmax)
SetMmax	XYSIS.h	/^  void SetMmax(int iMmax);$/;"	p	class:CXYSIS	access:public	signature:(int iMmax)
SetName	XYPDBAtom.cpp	/^void CXYPDBAtom::SetName(char *acAtom)$/;"	f	class:CXYPDBAtom	signature:(char *acAtom)
SetName	XYPDBAtom.h	/^	void SetName(char *acAtom);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acAtom)
SetNucleusSphereDiameter	XYEnsemble.cpp	/^void CXYEnsemble::SetNucleusSphereDiameter(float fNucleusSphereDiameter)$/;"	f	class:CXYEnsemble	signature:(float fNucleusSphereDiameter)
SetNucleusSphereDiameter	XYEnsemble.h	/^	void SetNucleusSphereDiameter(float fNucleusSphereDiameter);$/;"	p	class:CXYEnsemble	access:public	signature:(float fNucleusSphereDiameter)
SetNucleusSphereDiameter	XYSIS.cpp	/^void CXYSIS::SetNucleusSphereDiameter(float fNucleusSphereDiameter)$/;"	f	class:CXYSIS	signature:(float fNucleusSphereDiameter)
SetNucleusSphereDiameter	XYSIS.h	/^  void SetNucleusSphereDiameter(float fNucleusSphereDiameter);$/;"	p	class:CXYSIS	access:public	signature:(float fNucleusSphereDiameter)
SetNumBendingAngle	XYEnsemble.h	/^	void SetNumBendingAngle(int iNum);$/;"	p	class:CXYEnsemble	access:public	signature:(int iNum)
SetNumBendingAngle	XYSIS.h	/^  void SetNumBendingAngle(int iNum);$/;"	p	class:CXYSIS	access:public	signature:(int iNum)
SetNumNodes	XYEnsemble.cpp	/^void CXYEnsemble::SetNumNodes(int iNumNodes){$/;"	f	class:CXYEnsemble	signature:(int iNumNodes)
SetNumNodes	XYEnsemble.h	/^	void SetNumNodes(int iNumNodes);$/;"	p	class:CXYEnsemble	access:public	signature:(int iNumNodes)
SetNumNodes	XYSIS.cpp	/^void CXYSIS::SetNumNodes(int iNumNodes){$/;"	f	class:CXYSIS	signature:(int iNumNodes)
SetNumNodes	XYSIS.h	/^  void SetNumNodes(int iNumNodes);$/;"	p	class:CXYSIS	access:public	signature:(int iNumNodes)
SetNumTorsionAngle	XYEnsemble.h	/^	void SetNumTorsionAngle(int iNum);$/;"	p	class:CXYEnsemble	access:public	signature:(int iNum)
SetNumTorsionAngle	XYSIS.h	/^  void SetNumTorsionAngle(int iNum);$/;"	p	class:CXYSIS	access:public	signature:(int iNum)
SetOccupancy	XYPDBAtom.cpp	/^void CXYPDBAtom::SetOccupancy(float fOccupancy)$/;"	f	class:CXYPDBAtom	signature:(float fOccupancy)
SetOccupancy	XYPDBAtom.h	/^	void SetOccupancy(float fOccupancy);$/;"	p	class:CXYPDBAtom	access:public	signature:(float fOccupancy)
SetOutPath	XYEnsemble.cpp	/^void CXYEnsemble::SetOutPath(char* cPathName)$/;"	f	class:CXYEnsemble	signature:(char* cPathName)
SetOutPath	XYEnsemble.h	/^	void SetOutPath(char* cPathName);$/;"	p	class:CXYEnsemble	access:public	signature:(char* cPathName)
SetOutPath	XYSIS.cpp	/^void CXYSIS::SetOutPath(char* cPathName)$/;"	f	class:CXYSIS	signature:(char* cPathName)
SetOutPath	XYSIS.h	/^  void SetOutPath(char* cPathName);$/;"	p	class:CXYSIS	access:public	signature:(char* cPathName)
SetPackingDensity	XYEnsemble.cpp	/^void CXYEnsemble::SetPackingDensity(float fPackingDensity)$/;"	f	class:CXYEnsemble	signature:(float fPackingDensity)
SetPackingDensity	XYEnsemble.h	/^	void SetPackingDensity(float fPackingDensity);$/;"	p	class:CXYEnsemble	access:public	signature:(float fPackingDensity)
SetPackingDensity	XYSIS.cpp	/^void CXYSIS::SetPackingDensity(float fPackingDensity)$/;"	f	class:CXYSIS	signature:(float fPackingDensity)
SetPackingDensity	XYSIS.h	/^  void SetPackingDensity(float fPackingDensity);$/;"	p	class:CXYSIS	access:public	signature:(float fPackingDensity)
SetPersistenceLength	XYEnsemble.cpp	/^void CXYEnsemble::SetPersistenceLength(float fPL)$/;"	f	class:CXYEnsemble	signature:(float fPL)
SetPersistenceLength	XYEnsemble.h	/^	void SetPersistenceLength(float fPL);$/;"	p	class:CXYEnsemble	access:public	signature:(float fPL)
SetPersistenceLength	XYSIS.cpp	/^void CXYSIS::SetPersistenceLength(float fPL)$/;"	f	class:CXYSIS	signature:(float fPL)
SetPersistenceLength	XYSIS.h	/^  void SetPersistenceLength(float fPL);$/;"	p	class:CXYSIS	access:public	signature:(float fPL)
SetPoint	XYPDBAtom.cpp	/^void CXYPDBAtom::SetPoint(const CXYPoint3Df& rP)$/;"	f	class:CXYPDBAtom	signature:(const CXYPoint3Df& rP)
SetPoint	XYPDBAtom.h	/^	void SetPoint(const CXYPoint3Df& rP);$/;"	p	class:CXYPDBAtom	access:public	signature:(const CXYPoint3Df& rP)
SetRecName	XYPDBAtom.cpp	/^void CXYPDBAtom::SetRecName(char *acRecName)$/;"	f	class:CXYPDBAtom	signature:(char *acRecName)
SetRecName	XYPDBAtom.h	/^	void SetRecName(char *acRecName);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acRecName)
SetRemoteInd	XYPDBAtom.cpp	/^void CXYPDBAtom::SetRemoteInd(char *acRemoteInd)$/;"	f	class:CXYPDBAtom	signature:(char *acRemoteInd)
SetRemoteInd	XYPDBAtom.h	/^	void SetRemoteInd(char *acRemoteInd);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acRemoteInd)
SetResName	XYPDBAtom.cpp	/^void CXYPDBAtom::SetResName(char *acResName)$/;"	f	class:CXYPDBAtom	signature:(char *acResName)
SetResName	XYPDBAtom.h	/^	void SetResName(char *acResName);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acResName)
SetResSeq	XYPDBAtom.cpp	/^void CXYPDBAtom::SetResSeq(int iResSeq)$/;"	f	class:CXYPDBAtom	signature:(int iResSeq)
SetResSeq	XYPDBAtom.h	/^	void SetResSeq(int iResSeq);$/;"	p	class:CXYPDBAtom	access:public	signature:(int iResSeq)
SetRho_1	XYSIS.cpp	/^void CXYSIS::SetRho_1(float fRho_1)$/;"	f	class:CXYSIS	signature:(float fRho_1)
SetRho_1	XYSIS.h	/^  void SetRho_1(float fRho_1);$/;"	p	class:CXYSIS	access:public	signature:(float fRho_1)
SetRho_2	XYSIS.cpp	/^void CXYSIS::SetRho_2(float fRho_2)$/;"	f	class:CXYSIS	signature:(float fRho_2)
SetRho_2	XYSIS.h	/^  void SetRho_2(float fRho_2);$/;"	p	class:CXYSIS	access:public	signature:(float fRho_2)
SetRho_3	XYSIS.cpp	/^void CXYSIS::SetRho_3(float fRho_3)$/;"	f	class:CXYSIS	signature:(float fRho_3)
SetRho_3	XYSIS.h	/^  void SetRho_3(float fRho_3);$/;"	p	class:CXYSIS	access:public	signature:(float fRho_3)
SetRow	XYMatrix.h	/^	void SetRow (int iRow, const CXYVector<Real>& rkV);$/;"	p	class:CXYMatrix	access:public	signature:(int iRow, const CXYVector<Real>& rkV)
SetRow	XYMatrix.inl	/^void CXYMatrix<Real>::SetRow (int iRow, const CXYVector<Real>& rkV)$/;"	f	class:CXYMatrix	signature:(int iRow, const CXYVector<Real>& rkV)
SetSO3Sequence	XYSO3Sequence.cpp	/^int CXYSO3Sequence::SetSO3Sequence(){$/;"	f	class:CXYSO3Sequence	signature:()
SetSO3Sequence	XYSO3Sequence.h	/^	int SetSO3Sequence();$/;"	p	class:CXYSO3Sequence	access:public	signature:()
SetSamplesOrg	XYEnsemble.cpp	/^void CXYEnsemble::SetSamplesOrg(void)$/;"	f	class:CXYEnsemble	signature:(void)
SetSamplesOrg	XYEnsemble.h	/^	void SetSamplesOrg();$/;"	p	class:CXYEnsemble	access:public	signature:()
SetSamplesOrg	XYSIS.cpp	/^void CXYSIS::SetSamplesOrg(void)$/;"	f	class:CXYSIS	signature:(void)
SetSamplesOrg	XYSIS.h	/^  void SetSamplesOrg();$/;"	p	class:CXYSIS	access:public	signature:()
SetSegID	XYPDBAtom.cpp	/^void CXYPDBAtom::SetSegID(char *acSegID)$/;"	f	class:CXYPDBAtom	signature:(char *acSegID)
SetSegID	XYPDBAtom.h	/^	void SetSegID(char *acSegID);$/;"	p	class:CXYPDBAtom	access:public	signature:(char *acSegID)
SetSegLengths	XYEnsemble.cpp	/^void CXYEnsemble::SetSegLengths(char* cStartEndFile,const char* cMethod){$/;"	f	class:CXYEnsemble	signature:(char* cStartEndFile,const char* cMethod)
SetSegLengths	XYEnsemble.cpp	/^void CXYEnsemble::SetSegLengths(void){$/;"	f	class:CXYEnsemble	signature:(void)
SetSegLengths	XYEnsemble.h	/^	void SetSegLengths(char* cStartEndFile,const char* cMethod);$/;"	p	class:CXYEnsemble	access:public	signature:(char* cStartEndFile,const char* cMethod)
SetSegLengths	XYEnsemble.h	/^	void SetSegLengths(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
SetSegLengths	XYSIS.cpp	/^void CXYSIS::SetSegLengths(char* cStartEndFile,const char* cMethod){$/;"	f	class:CXYSIS	signature:(char* cStartEndFile,const char* cMethod)
SetSegLengths	XYSIS.cpp	/^void CXYSIS::SetSegLengths(void){$/;"	f	class:CXYSIS	signature:(void)
SetSegLengths	XYSIS.h	/^  void SetSegLengths(char* cStartEndFile,const char* cMethod);$/;"	p	class:CXYSIS	access:public	signature:(char* cStartEndFile,const char* cMethod)
SetSegLengths	XYSIS.h	/^  void SetSegLengths(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
SetSegSegPval	XYSIS.cpp	/^void CXYSIS::SetSegSegPval(char* cPvalFile){$/;"	f	class:CXYSIS	signature:(char* cPvalFile)
SetSegSegPval	XYSIS.h	/^  void SetSegSegPval(char* cPvalFile);$/;"	p	class:CXYSIS	access:public	signature:(char* cPvalFile)
SetSegSegPval_2	XYSIS.cpp	/^void CXYSIS::SetSegSegPval_2(char* cPvalFile){$/;"	f	class:CXYSIS	signature:(char* cPvalFile)
SetSegSegPval_2	XYSIS.h	/^  void SetSegSegPval_2(char* cPvalFile);$/;"	p	class:CXYSIS	access:public	signature:(char* cPvalFile)
SetSequenceBase	XYSO3Sequence.cpp	/^void	CXYSO3Sequence:: SetSequenceBase(){$/;"	f	class:CXYSO3Sequence	signature:()
SetSequenceBase	XYSO3Sequence.h	/^	void	SetSequenceBase();$/;"	p	class:CXYSO3Sequence	access:public	signature:()
SetSerial	XYPDBAtom.cpp	/^void CXYPDBAtom::SetSerial(int iSerial)$/;"	f	class:CXYPDBAtom	signature:(int iSerial)
SetSerial	XYPDBAtom.h	/^	void SetSerial(int iSerial);$/;"	p	class:CXYPDBAtom	access:public	signature:(int iSerial)
SetSize	XYMatrix.h	/^    void SetSize (int iRows, int iCols);$/;"	p	class:CXYMatrix	access:public	signature:(int iRows, int iCols)
SetSize	XYMatrix.inl	/^void CXYMatrix<Real>::SetSize (int iRows, int iCols)$/;"	f	class:CXYMatrix	signature:(int iRows, int iCols)
SetSize	XYVector.h	/^    void SetSize (int iSize);$/;"	p	class:CXYVector	access:public	signature:(int iSize)
SetSize	XYVector.inl	/^void CXYVector<Real>::SetSize(int iSize)$/;"	f	class:CXYVector	signature:(int iSize)
SetTau_t	XYSIS.cpp	/^void CXYSIS::SetTau_t(float fTau_t)$/;"	f	class:CXYSIS	signature:(float fTau_t)
SetTau_t	XYSIS.h	/^  void SetTau_t(float fTau_t);$/;"	p	class:CXYSIS	access:public	signature:(float fTau_t)
SetTempFactor	XYPDBAtom.cpp	/^void CXYPDBAtom::SetTempFactor(float fTempFactor)$/;"	f	class:CXYPDBAtom	signature:(float fTempFactor)
SetTempFactor	XYPDBAtom.h	/^	void SetTempFactor(float fTempFactor);$/;"	p	class:CXYPDBAtom	access:public	signature:(float fTempFactor)
SetTorsionAngleBeg	XYEnsemble.h	/^	void SetTorsionAngleBeg(float fAng);$/;"	p	class:CXYEnsemble	access:public	signature:(float fAng)
SetTorsionAngleBeg	XYSIS.h	/^  void SetTorsionAngleBeg(float fAng);$/;"	p	class:CXYSIS	access:public	signature:(float fAng)
SetTorsionAngleEnd	XYEnsemble.h	/^	void SetTorsionAngleEnd(float fAng);$/;"	p	class:CXYEnsemble	access:public	signature:(float fAng)
SetTorsionAngleEnd	XYSIS.h	/^  void SetTorsionAngleEnd(float fAng);$/;"	p	class:CXYSIS	access:public	signature:(float fAng)
SetX	XYPDBAtom.cpp	/^void CXYPDBAtom::SetX(float fX)$/;"	f	class:CXYPDBAtom	signature:(float fX)
SetX	XYPDBAtom.h	/^	void SetX(float fX);$/;"	p	class:CXYPDBAtom	access:public	signature:(float fX)
SetY	XYPDBAtom.cpp	/^void CXYPDBAtom::SetY(float fY)$/;"	f	class:CXYPDBAtom	signature:(float fY)
SetY	XYPDBAtom.h	/^	void SetY(float fY);$/;"	p	class:CXYPDBAtom	access:public	signature:(float fY)
SetZ	XYPDBAtom.cpp	/^void CXYPDBAtom::SetZ(float fZ)$/;"	f	class:CXYPDBAtom	signature:(float fZ)
SetZ	XYPDBAtom.h	/^	void SetZ(float fZ);$/;"	p	class:CXYPDBAtom	access:public	signature:(float fZ)
SetZeros	XYMatrix.h	/^	void SetZeros();$/;"	p	class:CXYMatrix	access:public	signature:()
SetZeros	XYMatrix.inl	/^void CXYMatrix<Real>::SetZeros()$/;"	f	class:CXYMatrix	signature:()
Size	XYPDB.cpp	/^int CXYPDB::Size() const$/;"	f	class:CXYPDB	signature:() const
Size	XYPDB.h	/^	int Size() const;$/;"	p	class:CXYPDB	access:public	signature:() const
Sqrt	XYMath.h	/^	static Real Sqrt (Real fValue);$/;"	p	class:CXYMath	access:public	signature:(Real fValue)
Sqrt	XYMath.inl	/^Real CXYMath<Real>::Sqrt (Real fValue)$/;"	f	class:CXYMath	signature:(Real fValue)
SquareLength	XYUtility.cpp	/^float CXYUtility::SquareLength(CXYPoint3D<float> P1,CXYPoint3D<float> P2)$/;"	f	class:CXYUtility	signature:(CXYPoint3D<float> P1,CXYPoint3D<float> P2)
SquareLength	XYUtility.h	/^	static float SquareLength(CXYPoint3D<float> P1,CXYPoint3D<float> P2);$/;"	p	class:CXYUtility	access:public	signature:(CXYPoint3D<float> P1,CXYPoint3D<float> P2)
SquaredLength	XYPoint3D.h	/^	Real SquaredLength () const;$/;"	p	class:CXYPoint3D	access:public	signature:() const
SquaredLength	XYPoint3D.inl	/^Real CXYPoint3D<Real>::SquaredLength () const$/;"	f	class:CXYPoint3D	signature:() const
SquaredLength	XYVector.h	/^    Real SquaredLength () const;$/;"	p	class:CXYVector	access:public	signature:() const
SquaredLength	XYVector.inl	/^Real CXYVector<Real>::SquaredLength () const$/;"	f	class:CXYVector	signature:() const
Sum	XYVector.h	/^	Real Sum() const;$/;"	p	class:CXYVector	access:public	signature:() const
Sum	XYVector.inl	/^Real CXYVector<Real>::Sum () const$/;"	f	class:CXYVector	signature:() const
SwapRows	XYMatrix.h	/^    void SwapRows (int iRow0, int iRow1);$/;"	p	class:CXYMatrix	access:public	signature:(int iRow0, int iRow1)
SwapRows	XYMatrix.inl	/^void CXYMatrix<Real>::SwapRows (int iRow0, int iRow1)$/;"	f	class:CXYMatrix	signature:(int iRow0, int iRow1)
T_as_string	ConfigFile.h	/^	template<class T> static string T_as_string( const T& t );$/;"	p	class:ConfigFile	access:protected	signature:( const T& t )
T_as_string	ConfigFile.h	/^string ConfigFile::T_as_string( const T& t )$/;"	f	class:ConfigFile	signature:( const T& t )
TimesTranspose	XYMatrix.h	/^    CXYMatrix TimesTranspose (const CXYMatrix& rkM) const;  \/\/ this * M^T$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
TimesTranspose	XYMatrix.inl	/^CXYMatrix<Real> CXYMatrix<Real>::TimesTranspose (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
Transpose	XYMatrix.h	/^    CXYMatrix Transpose () const;  \/\/ M^T$/;"	p	class:CXYMatrix	access:public	signature:() const
Transpose	XYMatrix.inl	/^CXYMatrix<Real> CXYMatrix<Real>::Transpose () const$/;"	f	class:CXYMatrix	signature:() const
TransposeTimes	XYMatrix.h	/^    CXYMatrix TransposeTimes (const CXYMatrix& rkM) const;  \/\/ this^T * M$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
TransposeTimes	XYMatrix.inl	/^CXYMatrix<Real> CXYMatrix<Real>::TransposeTimes (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
TreeIterator_MultiArray_Map	XYSIS.h	/^  tree<CXYVector<float> >::iterator_base_less>  TreeIterator_MultiArray_Map;$/;"	t
TreeIterator_VecpOcTree_Map	XYSIS.h	/^  tree<CXYVector<float> >::iterator_base_less>  TreeIterator_VecpOcTree_Map;$/;"	t
TridiagonalN	XYEigen.cpp	/^void CXYEigen<Real>::TridiagonalN ()$/;"	f	class:CXYEigen	signature:()
TridiagonalN	XYEigen.h	/^    void TridiagonalN ();$/;"	p	class:CXYEigen	access:private	signature:()
TrimChar	XYUtility.cpp	/^char *CXYUtility::TrimChar(char *pszSource)$/;"	f	class:CXYUtility	signature:(char *pszSource)
TrimChar	XYUtility.h	/^	static char *TrimChar( char *szSource );$/;"	p	class:CXYUtility	access:public	signature:( char *szSource )
UpdateMap_TreeIt_Vec_Append	XYSIS.cpp	/^void CXYSIS::UpdateMap_TreeIt_Vec_Append($/;"	f	class:CXYSIS	signature:( tree<CXYVector<float> >::iterator oldpos, tree<CXYVector<float> >::iterator newpos, int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
UpdateMap_TreeIt_Vec_Append	XYSIS.h	/^  void UpdateMap_TreeIt_Vec_Append(tree<CXYVector<float> >::iterator oldpos, $/;"	p	class:CXYSIS	access:public	signature:(tree<CXYVector<float> >::iterator oldpos, tree<CXYVector<float> >::iterator newpos, int iSegInd, int iNodeInd, int iNodeStartInd, int iNodeEndInd)
UpdateMap_TreeIt_Vec_Clean	XYSIS.cpp	/^void CXYSIS::UpdateMap_TreeIt_Vec_Clean(void){$/;"	f	class:CXYSIS	signature:(void)
UpdateMap_TreeIt_Vec_Clean	XYSIS.h	/^  void UpdateMap_TreeIt_Vec_Clean(void); $/;"	p	class:CXYSIS	access:public	signature:(void)
UpdateOctreeMap_Del	XYSIS.h	/^  void UpdateOctreeMap_Del(vector<tree<CXYVector<float> >::iterator>& v_octreemap_prvkey);$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator>& v_octreemap_prvkey)
UpdateOctreeMap_New	XYSIS.h	/^  void UpdateOctreeMap_New(tree<CXYVector<float> >::iterator oldpos, $/;"	p	class:CXYSIS	access:public	signature:(tree<CXYVector<float> >::iterator oldpos, tree<CXYVector<float> >::iterator newpos, vector<tree<CXYVector<float> >::iterator>& v_octreemap_prvkey)
WriteAtomsToPDB	XYFile.cpp	/^void CXYFile::WriteAtomsToPDB( const char* acfname, const char* _mode, vector<CXYPDB>& rkvPDBs )$/;"	f	class:CXYFile	signature:( const char* acfname, const char* _mode, vector<CXYPDB>& rkvPDBs )
WriteAtomsToPDB	XYFile.cpp	/^void CXYFile::WriteAtomsToPDB(const char* acfname, const char* _mode, CXYPDB& rkP)$/;"	f	class:CXYFile	signature:(const char* acfname, const char* _mode, CXYPDB& rkP)
WriteAtomsToPDB	XYFile.h	/^	static void WriteAtomsToPDB(const char* acfname, const char* _mode, CXYPDB& rkP);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname, const char* _mode, CXYPDB& rkP)
WriteAtomsToPDB	XYFile.h	/^	static void WriteAtomsToPDB(const char* acfname, const char* _mode, vector<CXYPDB>& rkvPDBs);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname, const char* _mode, vector<CXYPDB>& rkvPDBs)
WriteChain	XYEnsemble.cpp	/^void CXYEnsemble::WriteChain(char* fn)$/;"	f	class:CXYEnsemble	signature:(char* fn)
WriteChain	XYEnsemble.h	/^	void WriteChain(char* fn);$/;"	p	class:CXYEnsemble	access:public	signature:(char* fn)
WriteChain	XYSIS.cpp	/^void CXYSIS::WriteChain(char* fn)$/;"	f	class:CXYSIS	signature:(char* fn)
WriteChain	XYSIS.h	/^  void WriteChain(char* fn);$/;"	p	class:CXYSIS	access:public	signature:(char* fn)
WriteComment	XYFile.cpp	/^void CXYFile::WriteComment(const char* acfname, const char* _mode, const char* acComment)$/;"	f	class:CXYFile	signature:(const char* acfname, const char* _mode, const char* acComment)
WriteComment	XYFile.h	/^	static void WriteComment(const char* acfname, const char* _mode, const char* acComment);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname, const char* _mode, const char* acComment)
WriteContactDistance	XYEnsemble.cpp	/^void CXYEnsemble::WriteContactDistance(char* fn)$/;"	f	class:CXYEnsemble	signature:(char* fn)
WriteContactDistance	XYEnsemble.h	/^  void WriteContactDistance(char* fn);$/;"	p	class:CXYEnsemble	access:public	signature:(char* fn)
WriteDistance	XYEnsemble.cpp	/^void CXYEnsemble::WriteDistance(char* fn)$/;"	f	class:CXYEnsemble	signature:(char* fn)
WriteDistance	XYEnsemble.h	/^	void WriteDistance(char* fn);	$/;"	p	class:CXYEnsemble	access:public	signature:(char* fn)
WriteDistance	XYSIS.cpp	/^void CXYSIS::WriteDistance(char* fn)$/;"	f	class:CXYSIS	signature:(char* fn)
WriteDistance	XYSIS.h	/^  void WriteDistance(char* fn); $/;"	p	class:CXYSIS	access:public	signature:(char* fn)
WriteMatrix	XYFile.cpp	/^void CXYFile::WriteMatrix(const char* acfname, const char* _mode, const CXYMatrixf& rkM)$/;"	f	class:CXYFile	signature:(const char* acfname, const char* _mode, const CXYMatrixf& rkM)
WriteMatrix	XYFile.h	/^	static void WriteMatrix(const char* acfname, const char* _mode, const CXYMatrixf& rkM);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname, const char* _mode, const CXYMatrixf& rkM)
WritePDB	XYSIS.cpp	/^void CXYSIS::WritePDB(char* cFN, CXYMatrix<float>& kM, int iInd)$/;"	f	class:CXYSIS	signature:(char* cFN, CXYMatrix<float>& kM, int iInd)
WritePDB	XYSIS.h	/^  void WritePDB(char* cFN, CXYMatrix<float>& kM, int iInd);$/;"	p	class:CXYSIS	access:public	signature:(char* cFN, CXYMatrix<float>& kM, int iInd)
WritePDBArr	XYSIS.cpp	/^void CXYSIS::WritePDBArr(void)$/;"	f	class:CXYSIS	signature:(void)
WritePDBArr	XYSIS.h	/^  void WritePDBArr(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
WritePtsArr	XYSIS.cpp	/^void CXYSIS::WritePtsArr(void)$/;"	f	class:CXYSIS	signature:(void)
WritePtsArr	XYSIS.h	/^  void WritePtsArr(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
WriteSparseMatrix	XYFile.cpp	/^void CXYFile::WriteSparseMatrix(const char* acfname, const char* _mode, const CXYMatrixf& rkM)$/;"	f	class:CXYFile	signature:(const char* acfname, const char* _mode, const CXYMatrixf& rkM)
WriteSparseMatrix	XYFile.h	/^	static void WriteSparseMatrix(const char* acfname, const char* _mode, const CXYMatrixf& rkM);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname, const char* _mode, const CXYMatrixf& rkM)
WriteVector	XYFile.cpp	/^void CXYFile::WriteVector(const char* acfname, const char* _mode, const CXYVector<CXYPoint3D<float> >& rkV)$/;"	f	class:CXYFile	signature:(const char* acfname, const char* _mode, const CXYVector<CXYPoint3D<float> >& rkV)
WriteVector	XYFile.cpp	/^void CXYFile::WriteVector(const char* acfname, const char* _mode, const CXYVectorf& rkV)$/;"	f	class:CXYFile	signature:(const char* acfname, const char* _mode, const CXYVectorf& rkV)
WriteVector	XYFile.h	/^	static void WriteVector(const char* acfname, const char* _mode, const CXYVector<CXYPoint3D<float> >& rkV);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname, const char* _mode, const CXYVector<CXYPoint3D<float> >& rkV)
WriteVector	XYFile.h	/^	static void WriteVector(const char* acfname, const char* _mode, const CXYVectorf& rkV);$/;"	p	class:CXYFile	access:public	signature:(const char* acfname, const char* _mode, const CXYVectorf& rkV)
WriteWeight	XYEnsemble.cpp	/^void CXYEnsemble::WriteWeight(char* fn)$/;"	f	class:CXYEnsemble	signature:(char* fn)
WriteWeight	XYEnsemble.h	/^  void WriteWeight(char* fn);$/;"	p	class:CXYEnsemble	access:public	signature:(char* fn)
X	XYPoint3D.h	/^	Real X () const;$/;"	p	class:CXYPoint3D	access:public	signature:() const
X	XYPoint3D.h	/^	Real& X ();$/;"	p	class:CXYPoint3D	access:public	signature:()
X	XYPoint3D.inl	/^Real CXYPoint3D<Real>::X () const$/;"	f	class:CXYPoint3D	signature:() const
X	XYPoint3D.inl	/^Real& CXYPoint3D<Real>::X ()$/;"	f	class:CXYPoint3D	signature:()
XTTimesY	XYMatrix.h	/^CXYMatrix<Real> XTTimesY (const CXYVector<Real>& rkV1, const CXYVector<Real>& rkV2);$/;"	p	signature:(const CXYVector<Real>& rkV1, const CXYVector<Real>& rkV2)
XTTimesY	XYMatrix.inl	/^CXYMatrix<Real> XTTimesY (const CXYVector<Real>& rkV1, const CXYVector<Real>& rkV2)$/;"	f	signature:(const CXYVector<Real>& rkV1, const CXYVector<Real>& rkV2)
XYEIGEN_H	XYEigen.h	2;"	d
XYENSEMBLE_H	XYEnsemble.h	8;"	d
XYENSEMBLE_H	XYSIS.h	8;"	d
XYFILE_H	XYFile.h	2;"	d
XYLAPACK_H	XYLapack.h	2;"	d
XYMATH_H	XYMath.h	2;"	d
XYMATRIX_H	XYMatrix.h	2;"	d
XYPDBATOM_H	XYPDBAtom.h	2;"	d
XYPDB_H	XYPDB.h	2;"	d
XYPOINT3D_H	XYPoint3D.h	2;"	d
XYSO3SEQUENCE_H	XYSO3Sequence.h	38;"	d
XYUTILITY_H	XYUtility.h	2;"	d
XYVECTOR_H	XYVector.h	2;"	d
Y	XYPoint3D.h	/^	Real Y () const;$/;"	p	class:CXYPoint3D	access:public	signature:() const
Y	XYPoint3D.h	/^	Real& Y ();$/;"	p	class:CXYPoint3D	access:public	signature:()
Y	XYPoint3D.inl	/^Real CXYPoint3D<Real>::Y () const$/;"	f	class:CXYPoint3D	signature:() const
Y	XYPoint3D.inl	/^Real& CXYPoint3D<Real>::Y ()$/;"	f	class:CXYPoint3D	signature:()
Z	XYPoint3D.h	/^	Real Z () const;$/;"	p	class:CXYPoint3D	access:public	signature:() const
Z	XYPoint3D.h	/^	Real& Z ();$/;"	p	class:CXYPoint3D	access:public	signature:()
Z	XYPoint3D.inl	/^Real CXYPoint3D<Real>::Z () const$/;"	f	class:CXYPoint3D	signature:() const
Z	XYPoint3D.inl	/^Real& CXYPoint3D<Real>::Z ()$/;"	f	class:CXYPoint3D	signature:()
ZERO_TOLERANCE	XYMath.cpp	/^template<> const double CXYMath<double>::ZERO_TOLERANCE = 1e-08;$/;"	m	class:CXYMath	file:
ZERO_TOLERANCE	XYMath.cpp	/^template<> const float CXYMath<float>::ZERO_TOLERANCE = 1e-06f;$/;"	m	class:CXYMath	file:
ZERO_TOLERANCE	XYMath.h	/^	static const Real ZERO_TOLERANCE;$/;"	m	class:CXYMath	access:public
__SPATIALAGGREGATE_OCTREE_H__	octree.h	39;"	d
acquire	octree.h	/^    inline void acquire( OcTreeNode< CoordType, ValueType >* node ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( OcTreeNode< CoordType, ValueType >* node )
add	ConfigFile.h	/^	template<class T> void add( string key, const T& value );$/;"	p	class:ConfigFile	access:public	signature:( string key, const T& value )
add	ConfigFile.h	/^void ConfigFile::add( string key, const T& value )$/;"	f	class:ConfigFile	signature:( string key, const T& value )
addPoint	octree.h	/^    inline OcTreeNode< CoordType, ValueType >* addPoint( const CoordType& x, const CoordType& y, const CoordType& z, const ValueType& value, int maxDepth ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( const CoordType& x, const CoordType& y, const CoordType& z, const ValueType& value, int maxDepth )
addPoint	octree.h	/^    inline OcTreeNode< CoordType, ValueType >* addPoint( const Eigen::Matrix< CoordType, 4, 1 >& position, const ValueType& value, int maxDepth ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( const Eigen::Matrix< CoordType, 4, 1 >& position, const ValueType& value, int maxDepth )
addPoint	octree.h	/^    inline OcTreeNode< CoordType, ValueType >* addPoint( const OcTreeKey< CoordType, ValueType >& position, const ValueType& value, int maxDepth );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& position, const ValueType& value, int maxDepth )
addPoint	octree.hpp	/^inline spatialaggregate::OcTreeNode< CoordType, ValueType >* spatialaggregate::OcTreeNode< CoordType, ValueType >::addPoint( const OcTreeKey< CoordType, ValueType >& position, const ValueType& value, int maxDepth ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const OcTreeKey< CoordType, ValueType >& position, const ValueType& value, int maxDepth )
alloc_	octree.h	/^    DynamicAllocator< OcTreeNode< CoordType, ValueType > > alloc_;$/;"	m	class:spatialaggregate::OcTreeNodeDynamicAllocator	access:public
alloc_	tree.hh	/^		tree_node_allocator alloc_;$/;"	m	class:tree	access:private
allocate	octree.h	/^    T* allocate() {$/;"	f	class:spatialaggregate::DynamicAllocator	access:public	signature:()
allocateNode	octree.h	/^    inline virtual OcTreeNode< CoordType, ValueType >* allocateNode() { return new OcTreeNode< CoordType, ValueType >(); }$/;"	f	class:spatialaggregate::OcTreeNodeAllocator	access:public	signature:()
allocateNode	octree.h	/^    inline virtual OcTreeNode< CoordType, ValueType >* allocateNode() {$/;"	f	class:spatialaggregate::OcTreeNodeDynamicAllocator	access:public	signature:()
allocateNode	octree.h	/^    inline virtual OcTreeNode< CoordType, ValueType >* allocateNode() {$/;"	f	class:spatialaggregate::OcTreeNodeFixedCountAllocator	access:public	signature:()
allocator_	octree.h	/^    boost::shared_ptr< OcTreeNodeAllocator< CoordType, ValueType > > allocator_;$/;"	m	class:spatialaggregate::OcTree	access:public
ang2vec	XYSO3Sequence.cpp	/^void CXYSO3Sequence::ang2vec(double theta, double phi, double *vec) {$/;"	f	class:CXYSO3Sequence	signature:(double theta, double phi, double *vec)
ang2vec	XYSO3Sequence.h	/^	void ang2vec(double theta, double phi, double *vec);$/;"	p	class:CXYSO3Sequence	access:public	signature:(double theta, double phi, double *vec)
append_child	tree.hh	/^		template<typename iter> iter append_child(iter position); $/;"	p	class:tree	access:public	signature:(iter position)
append_child	tree.hh	/^		template<typename iter> iter append_child(iter position, const T& x);$/;"	p	class:tree	access:public	signature:(iter position, const T& x)
append_child	tree.hh	/^		template<typename iter> iter append_child(iter position, iter other_position);$/;"	p	class:tree	access:public	signature:(iter position, iter other_position)
append_child	tree.hh	/^iter tree<T, tree_node_allocator>::append_child(iter position)$/;"	f	class:tree	signature:(iter position)
append_child	tree.hh	/^iter tree<T, tree_node_allocator>::append_child(iter position, const T& x)$/;"	f	class:tree	signature:(iter position, const T& x)
append_child	tree.hh	/^iter tree<T, tree_node_allocator>::append_child(iter position, iter other)$/;"	f	class:tree	signature:(iter position, iter other)
append_children	tree.hh	/^		template<typename iter> iter append_children(iter position, sibling_iterator from, sibling_iterator to);$/;"	p	class:tree	access:public	signature:(iter position, sibling_iterator from, sibling_iterator to)
append_children	tree.hh	/^iter tree<T, tree_node_allocator>::append_children(iter position, sibling_iterator from, sibling_iterator to)$/;"	f	class:tree	signature:(iter position, sibling_iterator from, sibling_iterator to)
applyOperatorInVolume	octree.h	/^    inline void applyOperatorInVolume( ValueType& value, void* data, void (*f)( ValueType& v, OcTreeNode< CoordType, ValueType >* current, void* data ), const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( ValueType& value, void* data, void (*f)( ValueType& v, OcTreeNode< CoordType, ValueType >* current, void* data ), const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth )
applyOperatorInVolume	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::applyOperatorInVolume( ValueType& value, void* data, void (*f)( ValueType& v, spatialaggregate::OcTreeNode< CoordType, ValueType >* current, void* data ), const spatialaggregate::OcTreeKey< CoordType, ValueType >& minPosition, const spatialaggregate::OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( ValueType& value, void* data, void (*f)( ValueType& v, spatialaggregate::OcTreeNode< CoordType, ValueType >* current, void* data ), const spatialaggregate::OcTreeKey< CoordType, ValueType >& minPosition, const spatialaggregate::OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth )
begin	tree.hh	/^				sibling_iterator begin() const;$/;"	p	class:tree::iterator_base	access:public	signature:() const
begin	tree.hh	/^		inline pre_order_iterator   begin() const;$/;"	p	class:tree	access:public	signature:() const
begin	tree.hh	/^		sibling_iterator     begin(const iterator_base&) const;$/;"	p	class:tree	access:public	signature:(const iterator_base&) const
begin	tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator tree<T, tree_node_allocator>::begin() const$/;"	f	class:tree	signature:() const
begin	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::begin(const iterator_base& pos) const$/;"	f	class:tree	signature:(const iterator_base& pos) const
begin	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::iterator_base::begin() const$/;"	f	class:tree::iterator_base	signature:() const
begin_	XYFile.h	/^   int begin_;$/;"	m	class:CXYStringTokenizer	access:private
begin_breadth_first	tree.hh	/^		breadth_first_queued_iterator begin_breadth_first() const;$/;"	p	class:tree	access:public	signature:() const
begin_breadth_first	tree.hh	/^typename tree<T, tree_node_allocator>::breadth_first_queued_iterator tree<T, tree_node_allocator>::begin_breadth_first() const$/;"	f	class:tree	signature:() const
begin_fixed	tree.hh	/^		fixed_depth_iterator begin_fixed(const iterator_base&, unsigned int) const;$/;"	p	class:tree	access:public	signature:(const iterator_base&, unsigned int) const
begin_fixed	tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator tree<T, tree_node_allocator>::begin_fixed(const iterator_base& pos, unsigned int dp) const$/;"	f	class:tree	signature:(const iterator_base& pos, unsigned int dp) const
begin_leaf	tree.hh	/^      leaf_iterator   begin_leaf() const;$/;"	p	class:tree	access:public	signature:() const
begin_leaf	tree.hh	/^      leaf_iterator   begin_leaf(const iterator_base& top) const;$/;"	p	class:tree	access:public	signature:(const iterator_base& top) const
begin_leaf	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator tree<T, tree_node_allocator>::begin_leaf() const$/;"	f	class:tree	signature:() const
begin_leaf	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator tree<T, tree_node_allocator>::begin_leaf(const iterator_base& top) const$/;"	f	class:tree	signature:(const iterator_base& top) const
begin_post	tree.hh	/^		post_order_iterator  begin_post() const;$/;"	p	class:tree	access:public	signature:() const
begin_post	tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator tree<T, tree_node_allocator>::begin_post() const$/;"	f	class:tree	signature:() const
block_size_	octree.h	/^    int block_size_;$/;"	m	class:spatialaggregate::DynamicAllocator	access:public
breadth_first_iterator	tree.hh	/^		typedef breadth_first_queued_iterator breadth_first_iterator;$/;"	t	class:tree	access:public
breadth_first_queued_iterator	tree.hh	/^				breadth_first_queued_iterator();$/;"	p	class:tree::breadth_first_queued_iterator	access:public	signature:()
breadth_first_queued_iterator	tree.hh	/^				breadth_first_queued_iterator(const iterator_base&);$/;"	p	class:tree::breadth_first_queued_iterator	access:public	signature:(const iterator_base&)
breadth_first_queued_iterator	tree.hh	/^				breadth_first_queued_iterator(tree_node *);$/;"	p	class:tree::breadth_first_queued_iterator	access:public	signature:(tree_node *)
breadth_first_queued_iterator	tree.hh	/^		class breadth_first_queued_iterator : public iterator_base {$/;"	c	class:tree	inherits:iterator_base	access:public
breadth_first_queued_iterator	tree.hh	/^tree<T, tree_node_allocator>::breadth_first_queued_iterator::breadth_first_queued_iterator()$/;"	f	class:tree::breadth_first_queued_iterator	signature:()
breadth_first_queued_iterator	tree.hh	/^tree<T, tree_node_allocator>::breadth_first_queued_iterator::breadth_first_queued_iterator(const iterator_base& other)$/;"	f	class:tree::breadth_first_queued_iterator	signature:(const iterator_base& other)
breadth_first_queued_iterator	tree.hh	/^tree<T, tree_node_allocator>::breadth_first_queued_iterator::breadth_first_queued_iterator(tree_node *tn)$/;"	f	class:tree::breadth_first_queued_iterator	signature:(tree_node *tn)
child	tree.hh	/^		static sibling_iterator child(const iterator_base& position, unsigned int);$/;"	p	class:tree	access:public	signature:(const iterator_base& position, unsigned int)
child	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::child(const iterator_base& it, unsigned int num) $/;"	f	class:tree	signature:(const iterator_base& it, unsigned int num)
children_	octree.h	/^    OcTreeNode< CoordType, ValueType >* children_[8];$/;"	m	class:spatialaggregate::OcTreeNode	access:public
clear	tree.hh	/^		void     clear();$/;"	p	class:tree	access:public	signature:()
clear	tree.hh	/^void tree<T, tree_node_allocator>::clear()$/;"	f	class:tree	signature:()
comp_	tree.hh	/^				StrictWeakOrdering comp_;$/;"	m	class:tree::compare_nodes	access:private
compare_nodes	tree.hh	/^				compare_nodes(StrictWeakOrdering comp) : comp_(comp) {};$/;"	f	class:tree::compare_nodes	access:public	signature:(StrictWeakOrdering comp)
compare_nodes	tree.hh	/^		class compare_nodes {$/;"	c	class:tree	access:private
constructor	tree.hh	/^void constructor(T1* p) $/;"	f	namespace:kp	signature:(T1* p)
constructor	tree.hh	/^void constructor(T1* p, T2& val) $/;"	f	namespace:kp	signature:(T1* p, T2& val)
containedInRegion	octree.h	/^    inline bool containedInRegion( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition )
containedInRegion	octree.hpp	/^inline bool spatialaggregate::OcTreeNode< CoordType, ValueType >::containedInRegion( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition )
copy_	tree.hh	/^		void copy_(const tree<T, tree_node_allocator>& other);$/;"	p	class:tree	access:private	signature:(const tree<T, tree_node_allocator>& other)
copy_	tree.hh	/^void tree<T, tree_node_allocator>::copy_(const tree<T, tree_node_allocator>& other) $/;"	f	class:tree	signature:(const tree<T, tree_node_allocator>& other)
countNodes	octree.h	/^    inline unsigned int countNodes() {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:()
countTokens	XYFile.h	/^   size_t countTokens( ) {$/;"	f	class:CXYStringTokenizer	access:public	signature:( )
count_	XYFile.h	/^   int count_;$/;"	m	class:CXYStringTokenizer	access:private
curr_idx_	octree.h	/^    int curr_idx_;$/;"	m	class:spatialaggregate::DynamicAllocator	access:public
current_node_	octree.h	/^    OcTreeNode< CoordType, ValueType >* current_node_;$/;"	m	class:spatialaggregate::OcTreeNodeFixedCountAllocator	access:public
data	tree.hh	/^		T data;$/;"	m	class:tree_node_	access:public
deallocateNode	octree.h	/^    inline virtual void deallocateNode( OcTreeNode< CoordType, ValueType >* node ) { delete node; }$/;"	f	class:spatialaggregate::OcTreeNodeAllocator	access:public	signature:( OcTreeNode< CoordType, ValueType >* node )
deallocateNode	octree.h	/^    inline virtual void deallocateNode( OcTreeNode< CoordType, ValueType >* node ) {}$/;"	f	class:spatialaggregate::OcTreeNodeDynamicAllocator	access:public	signature:( OcTreeNode< CoordType, ValueType >* node )
deallocateNode	octree.h	/^    inline virtual void deallocateNode( OcTreeNode< CoordType, ValueType >* node ) {}$/;"	f	class:spatialaggregate::OcTreeNodeFixedCountAllocator	access:public	signature:( OcTreeNode< CoordType, ValueType >* node )
decodeMorton48	octree.h	/^    inline void decodeMorton48( uint64_t key, uint64_t& x, uint64_t& y, uint64_t& z );$/;"	p	class:spatialaggregate::OcTreeKey	access:public	signature:( uint64_t key, uint64_t& x, uint64_t& y, uint64_t& z )
decodeMorton48	octree.hpp	/^inline void spatialaggregate::OcTreeKey< CoordType, ValueType >::decodeMorton48( uint64_t key, uint64_t& x, uint64_t& y, uint64_t& z ) {$/;"	f	class:spatialaggregate::OcTreeKey	signature:( uint64_t key, uint64_t& x, uint64_t& y, uint64_t& z )
delim_	XYFile.h	/^   string delim_;$/;"	m	class:CXYStringTokenizer	access:private
depth	tree.hh	/^		static int depth(const iterator_base&);$/;"	p	class:tree	access:public	signature:(const iterator_base&)
depth	tree.hh	/^		static int depth(const iterator_base&, const iterator_base&);$/;"	p	class:tree	access:public	signature:(const iterator_base&, const iterator_base&)
depth	tree.hh	/^int tree<T, tree_node_allocator>::depth(const iterator_base& it) $/;"	f	class:tree	signature:(const iterator_base& it)
depth	tree.hh	/^int tree<T, tree_node_allocator>::depth(const iterator_base& it, const iterator_base& root) $/;"	f	class:tree	signature:(const iterator_base& it, const iterator_base& root)
depthForVolumeSize	octree.h	/^    inline double depthForVolumeSize( CoordType volumeSize ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( CoordType volumeSize )
depth_	octree.h	/^    int depth_;$/;"	m	class:spatialaggregate::OcTreeNode	access:public
depth_masks_	octree.h	/^    uint32_t depth_masks_[MAX_REPRESENTABLE_DEPTH+1];$/;"	m	class:spatialaggregate::OcTree	access:public
descend_all	tree.hh	/^				void descend_all();$/;"	p	class:tree::post_order_iterator	access:public	signature:()
descend_all	tree.hh	/^void tree<T, tree_node_allocator>::post_order_iterator::descend_all()$/;"	f	class:tree::post_order_iterator	signature:()
destructor	tree.hh	/^void destructor(T1* p)$/;"	f	namespace:kp	signature:(T1* p)
difference_type	tree.hh	/^				typedef ptrdiff_t                       difference_type;$/;"	t	class:tree::iterator_base	access:public
dilate1By2	octree.h	/^    inline uint64_t dilate1By2( uint64_t x );$/;"	p	class:spatialaggregate::OcTreeKey	access:public	signature:( uint64_t x )
dilate1By2	octree.hpp	/^inline uint64_t spatialaggregate::OcTreeKey< CoordType, ValueType >::dilate1By2( uint64_t x ) {$/;"	f	class:spatialaggregate::OcTreeKey	signature:( uint64_t x )
empty	tree.hh	/^		bool     empty() const;$/;"	p	class:tree	access:public	signature:() const
empty	tree.hh	/^bool tree<T, tree_node_allocator>::empty() const$/;"	f	class:tree	signature:() const
encodeMorton48	octree.h	/^    inline uint64_t encodeMorton48( uint64_t x, uint64_t y, uint64_t z );$/;"	p	class:spatialaggregate::OcTreeKey	access:public	signature:( uint64_t x, uint64_t y, uint64_t z )
encodeMorton48	octree.hpp	/^inline uint64_t spatialaggregate::OcTreeKey< CoordType, ValueType >::encodeMorton48( uint64_t x, uint64_t y, uint64_t z ) {$/;"	f	class:spatialaggregate::OcTreeKey	signature:( uint64_t x, uint64_t y, uint64_t z )
end	tree.hh	/^				sibling_iterator end() const;$/;"	p	class:tree::iterator_base	access:public	signature:() const
end	tree.hh	/^		inline pre_order_iterator   end() const;$/;"	p	class:tree	access:public	signature:() const
end	tree.hh	/^		sibling_iterator     end(const iterator_base&) const;$/;"	p	class:tree	access:public	signature:(const iterator_base&) const
end	tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator tree<T, tree_node_allocator>::end() const$/;"	f	class:tree	signature:() const
end	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::end(const iterator_base& pos) const$/;"	f	class:tree	signature:(const iterator_base& pos) const
end	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::iterator_base::end() const$/;"	f	class:tree::iterator_base	signature:() const
end_	XYFile.h	/^   int end_;$/;"	m	class:CXYStringTokenizer	access:private
end_breadth_first	tree.hh	/^		breadth_first_queued_iterator end_breadth_first() const;$/;"	p	class:tree	access:public	signature:() const
end_breadth_first	tree.hh	/^typename tree<T, tree_node_allocator>::breadth_first_queued_iterator tree<T, tree_node_allocator>::end_breadth_first() const$/;"	f	class:tree	signature:() const
end_fixed	tree.hh	/^		fixed_depth_iterator end_fixed(const iterator_base&, unsigned int) const;$/;"	p	class:tree	access:public	signature:(const iterator_base&, unsigned int) const
end_fixed	tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator tree<T, tree_node_allocator>::end_fixed(const iterator_base& pos, unsigned int dp) const$/;"	f	class:tree	signature:(const iterator_base& pos, unsigned int dp) const
end_leaf	tree.hh	/^      leaf_iterator   end_leaf() const;$/;"	p	class:tree	access:public	signature:() const
end_leaf	tree.hh	/^      leaf_iterator   end_leaf(const iterator_base& top) const;$/;"	p	class:tree	access:public	signature:(const iterator_base& top) const
end_leaf	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator tree<T, tree_node_allocator>::end_leaf() const$/;"	f	class:tree	signature:() const
end_leaf	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator tree<T, tree_node_allocator>::end_leaf(const iterator_base& top) const$/;"	f	class:tree	signature:(const iterator_base& top) const
end_post	tree.hh	/^		post_order_iterator  end_post() const;$/;"	p	class:tree	access:public	signature:() const
end_post	tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator tree<T, tree_node_allocator>::end_post() const$/;"	f	class:tree	signature:() const
equal	tree.hh	/^		bool     equal(const iter& one, const iter& two, const iter& three) const;$/;"	p	class:tree	access:public	signature:(const iter& one, const iter& two, const iter& three) const
equal	tree.hh	/^		bool     equal(const iter& one, const iter& two, const iter& three, BinaryPredicate) const;$/;"	p	class:tree	access:public	signature:(const iter& one, const iter& two, const iter& three, BinaryPredicate) const
equal	tree.hh	/^bool tree<T, tree_node_allocator>::equal(const iter& one_, const iter& two, const iter& three_) const$/;"	f	class:tree	signature:(const iter& one_, const iter& two, const iter& three_) const
equal	tree.hh	/^bool tree<T, tree_node_allocator>::equal(const iter& one_, const iter& two, const iter& three_, BinaryPredicate fun) const$/;"	f	class:tree	signature:(const iter& one_, const iter& two, const iter& three_, BinaryPredicate fun) const
equal_subtree	tree.hh	/^		bool     equal_subtree(const iter& one, const iter& two) const;$/;"	p	class:tree	access:public	signature:(const iter& one, const iter& two) const
equal_subtree	tree.hh	/^		bool     equal_subtree(const iter& one, const iter& two, BinaryPredicate) const;$/;"	p	class:tree	access:public	signature:(const iter& one, const iter& two, BinaryPredicate) const
equal_subtree	tree.hh	/^bool tree<T, tree_node_allocator>::equal_subtree(const iter& one_, const iter& two_) const$/;"	f	class:tree	signature:(const iter& one_, const iter& two_) const
equal_subtree	tree.hh	/^bool tree<T, tree_node_allocator>::equal_subtree(const iter& one_, const iter& two_, BinaryPredicate fun) const$/;"	f	class:tree	signature:(const iter& one_, const iter& two_, BinaryPredicate fun) const
erase	tree.hh	/^		template<typename iter> iter erase(iter);$/;"	p	class:tree	access:public	signature:(iter)
erase	tree.hh	/^iter tree<T, tree_node_allocator>::erase(iter it)$/;"	f	class:tree	signature:(iter it)
erase_children	tree.hh	/^		void     erase_children(const iterator_base&);$/;"	p	class:tree	access:public	signature:(const iterator_base&)
erase_children	tree.hh	/^void tree<T, tree_node_allocator>::erase_children(const iterator_base& it)$/;"	f	class:tree	signature:(const iterator_base& it)
establishNeighbors	octree.h	/^    inline void establishNeighbors();$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:()
establishNeighbors	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::establishNeighbors() {$/;"	f	class:spatialaggregate::OcTreeNode	signature:()
eulerangle2vector	XYSO3Sequence.h	/^	void eulerangle2vector(EulerAngle ea, double oldpoint_xyz[], double newpoint_xyz[]);$/;"	p	class:CXYSO3Sequence	access:public	signature:(EulerAngle ea, double oldpoint_xyz[], double newpoint_xyz[])
feet	tree.hh	/^		tree_node *head, *feet;    \/\/ head\/feet are always dummy; if an iterator points to them it is invalid$/;"	m	class:tree	access:public
file_not_found	ConfigFile.h	/^		file_not_found( const string& filename_ = string() )$/;"	f	struct:ConfigFile::file_not_found	access:public	signature:( const string& filename_ = string() )
file_not_found	ConfigFile.h	/^	struct file_not_found {$/;"	s	class:ConfigFile	access:public
filename	ConfigFile.h	/^		string filename;$/;"	m	struct:ConfigFile::file_not_found	access:public
findClosestNode	octree.h	/^    inline OcTreeNode< CoordType, ValueType >* findClosestNode( const Eigen::Matrix< CoordType, 4, 1 >& position, int depth, int& dist ) {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:( const Eigen::Matrix< CoordType, 4, 1 >& position, int depth, int& dist )
findClosestNode	octree.h	/^    inline OcTreeNode< CoordType, ValueType >* findClosestNode( const OcTreeKey< CoordType, ValueType >& position, int depth, int& dist );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& position, int depth, int& dist )
findClosestNode	octree.hpp	/^inline spatialaggregate::OcTreeNode< CoordType, ValueType >* spatialaggregate::OcTreeNode< CoordType, ValueType >::findClosestNode( const OcTreeKey< CoordType, ValueType >& position, int depth, int& dist ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const OcTreeKey< CoordType, ValueType >& position, int depth, int& dist )
findRepresentative	octree.h	/^    inline OcTreeNode< CoordType, ValueType >* findRepresentative( const Eigen::Matrix< CoordType, 4, 1 >& position, int maxDepth ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( const Eigen::Matrix< CoordType, 4, 1 >& position, int maxDepth )
findRepresentative	octree.h	/^    inline OcTreeNode< CoordType, ValueType >* findRepresentative( const Eigen::Matrix< CoordType, 4, 1 >& position, int maxDepth ) {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:( const Eigen::Matrix< CoordType, 4, 1 >& position, int maxDepth )
findRepresentative	octree.h	/^    inline OcTreeNode< CoordType, ValueType >* findRepresentative( const OcTreeKey< CoordType, ValueType >& position, int maxDepth );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& position, int maxDepth )
findRepresentative	octree.hpp	/^inline spatialaggregate::OcTreeNode< CoordType, ValueType >* spatialaggregate::OcTreeNode< CoordType, ValueType >::findRepresentative( const OcTreeKey< CoordType, ValueType >& position, int maxDepth ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const OcTreeKey< CoordType, ValueType >& position, int maxDepth )
find_point	XYSO3Sequence.cpp	/^vector<double> CXYSO3Sequence::find_point(int base_grid, long int point,long int level,long int healpix_point)$/;"	f	class:CXYSO3Sequence	signature:(int base_grid, long int point,long int level,long int healpix_point)
find_point	XYSO3Sequence.h	/^	vector<double> find_point(int base_grid, long int point,long int level,long int healpix_point);$/;"	p	class:CXYSO3Sequence	access:public	signature:(int base_grid, long int point,long int level,long int healpix_point)
finishBranch	octree.h	/^    inline void finishBranch();$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:()
finishBranch	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::finishBranch() {$/;"	f	class:spatialaggregate::OcTreeNode	signature:()
first	XYUtility.h	/^	T1 first;$/;"	m	class:CXYTriple	access:public
first_child	tree.hh	/^	   tree_node_<T> *first_child, *last_child;$/;"	m	class:tree_node_	access:public
fixed_depth_iterator	tree.hh	/^				fixed_depth_iterator();$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:()
fixed_depth_iterator	tree.hh	/^				fixed_depth_iterator(const fixed_depth_iterator&);$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(const fixed_depth_iterator&)
fixed_depth_iterator	tree.hh	/^				fixed_depth_iterator(const iterator_base&);$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(const iterator_base&)
fixed_depth_iterator	tree.hh	/^				fixed_depth_iterator(const sibling_iterator&);$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(const sibling_iterator&)
fixed_depth_iterator	tree.hh	/^				fixed_depth_iterator(tree_node *);$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(tree_node *)
fixed_depth_iterator	tree.hh	/^		class fixed_depth_iterator : public iterator_base {$/;"	c	class:tree	inherits:iterator_base	access:public
fixed_depth_iterator	tree.hh	/^tree<T, tree_node_allocator>::fixed_depth_iterator::fixed_depth_iterator()$/;"	f	class:tree::fixed_depth_iterator	signature:()
fixed_depth_iterator	tree.hh	/^tree<T, tree_node_allocator>::fixed_depth_iterator::fixed_depth_iterator(const fixed_depth_iterator& other)$/;"	f	class:tree::fixed_depth_iterator	signature:(const fixed_depth_iterator& other)
fixed_depth_iterator	tree.hh	/^tree<T, tree_node_allocator>::fixed_depth_iterator::fixed_depth_iterator(const iterator_base& other)$/;"	f	class:tree::fixed_depth_iterator	signature:(const iterator_base& other)
fixed_depth_iterator	tree.hh	/^tree<T, tree_node_allocator>::fixed_depth_iterator::fixed_depth_iterator(const sibling_iterator& other)$/;"	f	class:tree::fixed_depth_iterator	signature:(const sibling_iterator& other)
fixed_depth_iterator	tree.hh	/^tree<T, tree_node_allocator>::fixed_depth_iterator::fixed_depth_iterator(tree_node *tn)$/;"	f	class:tree::fixed_depth_iterator	signature:(tree_node *tn)
flatten	tree.hh	/^		template<typename iter> iter flatten(iter position);$/;"	p	class:tree	access:public	signature:(iter position)
flatten	tree.hh	/^iter tree<T, tree_node_allocator>::flatten(iter position)$/;"	f	class:tree	signature:(iter position)
getAllLeaves	octree.h	/^    inline void getAllLeaves( std::list< OcTreeNode< CoordType, ValueType >* >& nodes );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( std::list< OcTreeNode< CoordType, ValueType >* >& nodes )
getAllLeaves	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::getAllLeaves( std::list< spatialaggregate::OcTreeNode< CoordType, ValueType >* >& points ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( std::list< spatialaggregate::OcTreeNode< CoordType, ValueType >* >& points )
getAllLeavesInVolume	octree.h	/^    inline void getAllLeavesInVolume( std::list< OcTreeNode< CoordType, ValueType >* >& nodes, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( std::list< OcTreeNode< CoordType, ValueType >* >& nodes, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth )
getAllLeavesInVolume	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::getAllLeavesInVolume( std::list< spatialaggregate::OcTreeNode< CoordType, ValueType >* >& points, const spatialaggregate::OcTreeKey< CoordType, ValueType >& minPosition, const spatialaggregate::OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( std::list< spatialaggregate::OcTreeNode< CoordType, ValueType >* >& points, const spatialaggregate::OcTreeKey< CoordType, ValueType >& minPosition, const spatialaggregate::OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth )
getAllNodesInVolumeOnDepth	octree.h	/^    inline void getAllNodesInVolumeOnDepth( std::list< OcTreeNode< CoordType, ValueType >* >& nodes, const Eigen::Matrix< CoordType, 4, 1 >& minPosition, const Eigen::Matrix< CoordType, 4, 1 >& maxPosition, int depth, bool lowerDepthLeaves ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( std::list< OcTreeNode< CoordType, ValueType >* >& nodes, const Eigen::Matrix< CoordType, 4, 1 >& minPosition, const Eigen::Matrix< CoordType, 4, 1 >& maxPosition, int depth, bool lowerDepthLeaves )
getAllNodesInVolumeOnDepth	octree.h	/^    inline void getAllNodesInVolumeOnDepth( std::list< OcTreeNode< CoordType, ValueType >* >& nodes, const Eigen::Matrix< CoordType, 4, 1 >& minPosition, const Eigen::Matrix< CoordType, 4, 1 >& maxPosition, int depth, bool lowerDepthLeaves ) {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:( std::list< OcTreeNode< CoordType, ValueType >* >& nodes, const Eigen::Matrix< CoordType, 4, 1 >& minPosition, const Eigen::Matrix< CoordType, 4, 1 >& maxPosition, int depth, bool lowerDepthLeaves )
getAllNodesInVolumeOnDepth	octree.h	/^    inline void getAllNodesInVolumeOnDepth( std::list< OcTreeNode< CoordType, ValueType >* >& nodes, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int depth, bool lowerDepthLeaves );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( std::list< OcTreeNode< CoordType, ValueType >* >& nodes, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int depth, bool lowerDepthLeaves )
getAllNodesInVolumeOnDepth	octree.h	/^    inline void getAllNodesInVolumeOnDepth( std::vector< OcTreeNode< CoordType, ValueType >* >& nodes, const Eigen::Matrix< CoordType, 4, 1 >& minPosition, const Eigen::Matrix< CoordType, 4, 1 >& maxPosition, int depth, bool lowerDepthLeaves ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( std::vector< OcTreeNode< CoordType, ValueType >* >& nodes, const Eigen::Matrix< CoordType, 4, 1 >& minPosition, const Eigen::Matrix< CoordType, 4, 1 >& maxPosition, int depth, bool lowerDepthLeaves )
getAllNodesInVolumeOnDepth	octree.h	/^    inline void getAllNodesInVolumeOnDepth( std::vector< OcTreeNode< CoordType, ValueType >* >& nodes, const Eigen::Matrix< CoordType, 4, 1 >& minPosition, const Eigen::Matrix< CoordType, 4, 1 >& maxPosition, int depth, bool lowerDepthLeaves ) {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:( std::vector< OcTreeNode< CoordType, ValueType >* >& nodes, const Eigen::Matrix< CoordType, 4, 1 >& minPosition, const Eigen::Matrix< CoordType, 4, 1 >& maxPosition, int depth, bool lowerDepthLeaves )
getAllNodesInVolumeOnDepth	octree.h	/^    inline void getAllNodesInVolumeOnDepth( std::vector< OcTreeNode< CoordType, ValueType >* >& nodes, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int depth, bool lowerDepthLeaves );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( std::vector< OcTreeNode< CoordType, ValueType >* >& nodes, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int depth, bool lowerDepthLeaves )
getAllNodesInVolumeOnDepth	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::getAllNodesInVolumeOnDepth( std::list< OcTreeNode< CoordType, ValueType >* >& points, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth, bool higherDepthLeaves ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( std::list< OcTreeNode< CoordType, ValueType >* >& points, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth, bool higherDepthLeaves )
getAllNodesInVolumeOnDepth	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::getAllNodesInVolumeOnDepth( std::vector< OcTreeNode< CoordType, ValueType >* >& points, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth, bool higherDepthLeaves ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( std::vector< OcTreeNode< CoordType, ValueType >* >& points, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth, bool higherDepthLeaves )
getCenterKey	octree.h	/^    inline void getCenterKey( OcTreeKey< CoordType, ValueType >& center_key ) const;$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( OcTreeKey< CoordType, ValueType >& center_key ) const
getCenterKey	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::getCenterKey( OcTreeKey< CoordType, ValueType >& center_key ) const {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( OcTreeKey< CoordType, ValueType >& center_key ) const
getCenterPosition	octree.h	/^    inline Eigen::Matrix< CoordType, 4, 1 > getCenterPosition() const {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:() const
getComment	ConfigFile.h	/^	string getComment() const { return myComment; }$/;"	f	class:ConfigFile	access:public	signature:() const
getDelimiter	ConfigFile.h	/^	string getDelimiter() const { return myDelimiter; }$/;"	f	class:ConfigFile	access:public	signature:() const
getFiniteBackwardDifference	octree.h	/^    inline double getFiniteBackwardDifference( int dim, double (*f)( OcTreeNode< CoordType, ValueType >* n ) );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( int dim, double (*f)( OcTreeNode< CoordType, ValueType >* n ) )
getFiniteBackwardDifference	octree.hpp	/^inline double spatialaggregate::OcTreeNode< CoordType, ValueType >::getFiniteBackwardDifference( int dim, double (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* n ) ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( int dim, double (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* n ) )
getFiniteCentralDifference	octree.h	/^    inline double getFiniteCentralDifference( int dim, double (*f)( OcTreeNode< CoordType, ValueType >* n ) );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( int dim, double (*f)( OcTreeNode< CoordType, ValueType >* n ) )
getFiniteCentralDifference	octree.hpp	/^inline double spatialaggregate::OcTreeNode< CoordType, ValueType >::getFiniteCentralDifference( int dim, double (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* n ) ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( int dim, double (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* n ) )
getFiniteForwardDifference	octree.h	/^    inline double getFiniteForwardDifference( int dim, double (*f)( OcTreeNode< CoordType, ValueType >* n ) );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( int dim, double (*f)( OcTreeNode< CoordType, ValueType >* n ) )
getFiniteForwardDifference	octree.hpp	/^inline double spatialaggregate::OcTreeNode< CoordType, ValueType >::getFiniteForwardDifference( int dim, double (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* n ) ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( int dim, double (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* n ) )
getKey	octree.h	/^    inline OcTreeKey< CoordType, ValueType > getKey( const CoordType& x, const CoordType& y, const CoordType& z ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( const CoordType& x, const CoordType& y, const CoordType& z )
getKey	octree.h	/^    inline OcTreeKey< CoordType, ValueType > getKey( const Eigen::Matrix< CoordType, 4, 1 >& position ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( const Eigen::Matrix< CoordType, 4, 1 >& position )
getMaxPosition	octree.h	/^    inline Eigen::Matrix< CoordType, 4, 1 > getMaxPosition() const {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:() const
getMinPosition	octree.h	/^    inline Eigen::Matrix< CoordType, 4, 1 > getMinPosition() const {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:() const
getNeighbor	octree.h	/^    inline OcTreeNode< CoordType, ValueType >* getNeighbor( int dx, int dy, int dz );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( int dx, int dy, int dz )
getNeighbor	octree.hpp	/^inline spatialaggregate::OcTreeNode< CoordType, ValueType >* spatialaggregate::OcTreeNode< CoordType, ValueType >::getNeighbor( int dx, int dy, int dz ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( int dx, int dy, int dz )
getNeighbors	octree.h	/^    inline void getNeighbors( std::list< OcTreeNode< CoordType, ValueType >* >& neighbors );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( std::list< OcTreeNode< CoordType, ValueType >* >& neighbors )
getNeighbors	octree.h	/^    inline void getNeighbors( std::vector< OcTreeNode< CoordType, ValueType >* >& neighbors );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( std::vector< OcTreeNode< CoordType, ValueType >* >& neighbors )
getNeighbors	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::getNeighbors( std::list< OcTreeNode< CoordType, ValueType >* >& neighbors ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( std::list< OcTreeNode< CoordType, ValueType >* >& neighbors )
getNeighbors	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::getNeighbors( std::vector< OcTreeNode< CoordType, ValueType >* >& neighbors ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( std::vector< OcTreeNode< CoordType, ValueType >* >& neighbors )
getOctant	octree.h	/^    inline unsigned int getOctant( const OcTreeKey< CoordType, ValueType >& position );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& position )
getOctant	octree.hpp	/^inline unsigned int spatialaggregate::OcTreeNode< CoordType, ValueType >::getOctant( const spatialaggregate::OcTreeKey< CoordType, ValueType >& query ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const spatialaggregate::OcTreeKey< CoordType, ValueType >& query )
getPosition	octree.h	/^    inline Eigen::Matrix< CoordType, 4, 1 > getPosition( OcTree< CoordType, ValueType >* tree ) const;$/;"	p	class:spatialaggregate::OcTreeKey	access:public	signature:( OcTree< CoordType, ValueType >* tree ) const
getPosition	octree.h	/^    inline Eigen::Matrix< CoordType, 4, 1 > getPosition() const {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:() const
getPosition	octree.hpp	/^inline Eigen::Matrix< CoordType, 4, 1 > spatialaggregate::OcTreeKey< CoordType, ValueType >::getPosition( OcTree< CoordType, ValueType >* tree ) const {$/;"	f	class:spatialaggregate::OcTreeKey	signature:( OcTree< CoordType, ValueType >* tree ) const
getSentry	ConfigFile.h	/^	string getSentry() const { return mySentry; }$/;"	f	class:ConfigFile	access:public	signature:() const
getValueInVolume	octree.h	/^    inline ValueType getValueInVolume( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth )
getValueInVolume	octree.hpp	/^inline ValueType spatialaggregate::OcTreeNode< CoordType, ValueType >::getValueInVolume( const spatialaggregate::OcTreeKey< CoordType, ValueType >& minPosition, const spatialaggregate::OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const spatialaggregate::OcTreeKey< CoordType, ValueType >& minPosition, const spatialaggregate::OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth )
h1Function	XYSIS.cpp	/^float CXYSIS::h1Function(CXYMatrix<float>& kM)$/;"	f	class:CXYSIS	signature:(CXYMatrix<float>& kM)
h1Function	XYSIS.h	/^  float h1Function(CXYMatrix<float>& kM);$/;"	p	class:CXYSIS	access:public	signature:(CXYMatrix<float>& kM)
h1Function_ByVector	XYSIS.cpp	/^void CXYSIS::h1Function_ByVector(vector<tree<CXYVector<float> >::iterator >& rvOneChain){$/;"	f	class:CXYSIS	signature:(vector<tree<CXYVector<float> >::iterator >& rvOneChain)
h1Function_ByVector	XYSIS.h	/^  void h1Function_ByVector(vector<tree<CXYVector<float> >::iterator >& rvOneChain);$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator >& rvOneChain)
h2Function	XYSIS.cpp	/^float CXYSIS::h2Function(CXYMatrix<float>& kM)$/;"	f	class:CXYSIS	signature:(CXYMatrix<float>& kM)
h2Function	XYSIS.h	/^  float h2Function(CXYMatrix<float>& kM);$/;"	p	class:CXYSIS	access:public	signature:(CXYMatrix<float>& kM)
h2Function_ByVector	XYSIS.cpp	/^void CXYSIS::h2Function_ByVector(vector<tree<CXYVector<float> >::iterator >& rvOneChain, CXYVector<float>& rKV_Dist){$/;"	f	class:CXYSIS	signature:(vector<tree<CXYVector<float> >::iterator >& rvOneChain, CXYVector<float>& rKV_Dist)
h2Function_ByVector	XYSIS.h	/^  void h2Function_ByVector(vector<tree<CXYVector<float> >::iterator >& rvOneChain, CXYVector<float>& rKV_Dist);$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator >& rvOneChain, CXYVector<float>& rKV_Dist)
h3Function_ByVector	XYSIS.cpp	/^void CXYSIS::h3Function_ByVector($/;"	f	class:CXYSIS	signature:( vector<tree<CXYVector<float> >::iterator >& rvOneChain, CXYVector<float>& rKV_Dist)
h3Function_ByVector	XYSIS.h	/^  void h3Function_ByVector(vector<tree<CXYVector<float> >::iterator >& rvOneChain, CXYVector<float>& rKV_Dist);$/;"	p	class:CXYSIS	access:public	signature:(vector<tree<CXYVector<float> >::iterator >& rvOneChain, CXYVector<float>& rKV_Dist)
hasMoreTokens	XYFile.h	/^   bool hasMoreTokens( ) {return(begin_ != end_);}$/;"	f	class:CXYStringTokenizer	access:public	signature:( )
hash	MersenneTwister.h	/^	static uint32 hash( time_t t, clock_t c );$/;"	p	class:MTRand	access:protected	signature:( time_t t, clock_t c )
hash	MersenneTwister.h	/^inline MTRand::uint32 MTRand::hash( time_t t, clock_t c )$/;"	f	class:MTRand	signature:( time_t t, clock_t c )
head	tree.hh	/^		tree_node *head, *feet;    \/\/ head\/feet are always dummy; if an iterator points to them it is invalid$/;"	m	class:tree	access:public
head_initialise_	tree.hh	/^		void head_initialise_();$/;"	p	class:tree	access:private	signature:()
head_initialise_	tree.hh	/^void tree<T, tree_node_allocator>::head_initialise_() $/;"	f	class:tree	signature:()
hiBit	MersenneTwister.h	/^	uint32 hiBit( const uint32 u ) const { return u & 0x80000000UL; }$/;"	f	class:MTRand	access:protected	signature:( const uint32 u ) const
hopf2quat	XYSO3Sequence.h	/^	bool hopf2quat(vector < vector <double> > Points);$/;"	p	class:CXYSO3Sequence	access:public	signature:(vector < vector <double> > Points)
inRegion	octree.h	/^    inline bool inRegion( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition )
inRegion	octree.h	/^    inline bool inRegion( const OcTreeKey< CoordType, ValueType >& position );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& position )
inRegion	octree.hpp	/^inline bool spatialaggregate::OcTreeNode< CoordType, ValueType >::inRegion( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition )
inRegion	octree.hpp	/^inline bool spatialaggregate::OcTreeNode< CoordType, ValueType >::inRegion( const OcTreeKey< CoordType, ValueType >& position ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const OcTreeKey< CoordType, ValueType >& position )
index	tree.hh	/^		unsigned int index(sibling_iterator it) const;$/;"	p	class:tree	access:public	signature:(sibling_iterator it) const
index	tree.hh	/^unsigned int tree<T, tree_node_allocator>::index(sibling_iterator it) const$/;"	f	class:tree	signature:(sibling_iterator it) const
initialize	MersenneTwister.h	/^	void initialize( const uint32 oneSeed );$/;"	p	class:MTRand	access:protected	signature:( const uint32 oneSeed )
initialize	MersenneTwister.h	/^inline void MTRand::initialize( const uint32 seed )$/;"	f	class:MTRand	signature:( const uint32 seed )
initialize	octree.h	/^    inline void initialize( OcTreeNodeType type, const OcTreeKey< CoordType, ValueType >& key, const ValueType& value, int depth, OcTreeNode< CoordType, ValueType >* parent, OcTree< CoordType, ValueType >* tree );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( OcTreeNodeType type, const OcTreeKey< CoordType, ValueType >& key, const ValueType& value, int depth, OcTreeNode< CoordType, ValueType >* parent, OcTree< CoordType, ValueType >* tree )
initialize	octree.h	/^    inline void initialize( const Eigen::Matrix< CoordType, 4, 1 >& dimensions, const Eigen::Matrix< CoordType, 4, 1 >& center, CoordType minimumVolumeSize );$/;"	p	class:spatialaggregate::OcTree	access:public	signature:( const Eigen::Matrix< CoordType, 4, 1 >& dimensions, const Eigen::Matrix< CoordType, 4, 1 >& center, CoordType minimumVolumeSize )
initialize	octree.h	/^    void initialize( OcTreeNode* node ) {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:( OcTreeNode* node )
initialize	octree.h	/^    void initialize() {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:()
initialize	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::initialize( OcTreeNodeType type, const OcTreeKey< CoordType, ValueType >& key, const ValueType& value, int depth, OcTreeNode< CoordType, ValueType >* parent, OcTree< CoordType, ValueType >* tree ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( OcTreeNodeType type, const OcTreeKey< CoordType, ValueType >& key, const ValueType& value, int depth, OcTreeNode< CoordType, ValueType >* parent, OcTree< CoordType, ValueType >* tree )
insert	tree.hh	/^		sibling_iterator insert(sibling_iterator position, const T& x);$/;"	p	class:tree	access:public	signature:(sibling_iterator position, const T& x)
insert	tree.hh	/^		template<typename iter> iter insert(iter position, const T& x);$/;"	p	class:tree	access:public	signature:(iter position, const T& x)
insert	tree.hh	/^iter tree<T, tree_node_allocator>::insert(iter position, const T& x)$/;"	f	class:tree	signature:(iter position, const T& x)
insert	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::insert(sibling_iterator position, const T& x)$/;"	f	class:tree	signature:(sibling_iterator position, const T& x)
insert_after	tree.hh	/^		template<typename iter> iter insert_after(iter position, const T& x);$/;"	p	class:tree	access:public	signature:(iter position, const T& x)
insert_after	tree.hh	/^iter tree<T, tree_node_allocator>::insert_after(iter position, const T& x)$/;"	f	class:tree	signature:(iter position, const T& x)
insert_subtree	tree.hh	/^		template<typename iter> iter insert_subtree(iter position, const iterator_base& subtree);$/;"	p	class:tree	access:public	signature:(iter position, const iterator_base& subtree)
insert_subtree	tree.hh	/^iter tree<T, tree_node_allocator>::insert_subtree(iter position, const iterator_base& subtree)$/;"	f	class:tree	signature:(iter position, const iterator_base& subtree)
insert_subtree_after	tree.hh	/^		template<typename iter> iter insert_subtree_after(iter position, const iterator_base& subtree);$/;"	p	class:tree	access:public	signature:(iter position, const iterator_base& subtree)
insert_subtree_after	tree.hh	/^iter tree<T, tree_node_allocator>::insert_subtree_after(iter position, const iterator_base& subtree)$/;"	f	class:tree	signature:(iter position, const iterator_base& subtree)
interpolateTriLinear	octree.h	/^    inline bool interpolateTriLinear( double& value, OcTreeNode< CoordType, ValueType >* node, const OcTreeKey< CoordType, ValueType >& queryKey, double (*f)( OcTreeNode< CoordType, ValueType >* n ) );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( double& value, OcTreeNode< CoordType, ValueType >* node, const OcTreeKey< CoordType, ValueType >& queryKey, double (*f)( OcTreeNode< CoordType, ValueType >* n ) )
interpolateTriLinear	octree.hpp	/^inline bool spatialaggregate::OcTreeNode< CoordType, ValueType >::interpolateTriLinear( double& value, spatialaggregate::OcTreeNode< CoordType, ValueType >* node, const spatialaggregate::OcTreeKey< CoordType, ValueType >& queryKey, double (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* n ) ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( double& value, spatialaggregate::OcTreeNode< CoordType, ValueType >* node, const spatialaggregate::OcTreeKey< CoordType, ValueType >& queryKey, double (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* n ) )
invResolution	octree.h	/^    inline CoordType invResolution();$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:()
invResolution	octree.hpp	/^inline CoordType spatialaggregate::OcTreeNode< CoordType, ValueType >::invResolution() {$/;"	f	class:spatialaggregate::OcTreeNode	signature:()
inv_minimum_volume_size_	octree.h	/^    CoordType minimum_volume_size_, inv_minimum_volume_size_;$/;"	m	class:spatialaggregate::OcTree	access:public
inv_position_normalizer_	octree.h	/^    Eigen::Matrix< CoordType, 4, 1 > min_position_, position_normalizer_, inv_position_normalizer_;$/;"	m	class:spatialaggregate::OcTree	access:public
inv_resolutions_	octree.h	/^    float inv_resolutions_[MAX_REPRESENTABLE_DEPTH+1];$/;"	m	class:spatialaggregate::OcTree	access:public
isSpaces	XYUtility.h	10;"	d
is_in_subtree	tree.hh	/^		bool     is_in_subtree(const iterator_base& position, const iterator_base& begin, $/;"	p	class:tree	access:public	signature:(const iterator_base& position, const iterator_base& begin, const iterator_base& end) const
is_in_subtree	tree.hh	/^bool tree<T, tree_node_allocator>::is_in_subtree(const iterator_base& it, const iterator_base& begin, $/;"	f	class:tree	signature:(const iterator_base& it, const iterator_base& begin, const iterator_base& end) const
is_valid	tree.hh	/^		bool     is_valid(const iterator_base&) const;$/;"	p	class:tree	access:public	signature:(const iterator_base&) const
is_valid	tree.hh	/^bool tree<T, tree_node_allocator>::is_valid(const iterator_base& it) const$/;"	f	class:tree	signature:(const iterator_base& it) const
iterator	tree.hh	/^		typedef pre_order_iterator            iterator;$/;"	t	class:tree	access:public
iterator_base	tree.hh	/^				iterator_base();$/;"	p	class:tree::iterator_base	access:public	signature:()
iterator_base	tree.hh	/^				iterator_base(tree_node *);$/;"	p	class:tree::iterator_base	access:public	signature:(tree_node *)
iterator_base	tree.hh	/^		class iterator_base : public stlport::bidirectional_iterator<T, ptrdiff_t> {$/;"	c	class:tree	inherits:stlport::bidirectional_iterator	access:public
iterator_base	tree.hh	/^		class iterator_base;$/;"	x
iterator_base	tree.hh	/^tree<T, tree_node_allocator>::iterator_base::iterator_base()$/;"	f	class:tree::iterator_base	signature:()
iterator_base	tree.hh	/^tree<T, tree_node_allocator>::iterator_base::iterator_base(tree_node *tn)$/;"	f	class:tree::iterator_base	signature:(tree_node *tn)
iterator_base_less	tree.hh	/^		class iterator_base_less {$/;"	c	class:tree	access:public
iterator_category	tree.hh	/^				typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	class:tree::iterator_base	access:public
k_B	XYMath.cpp	/^template<> const float CXYMath<float>::k_B = 1.3806505e-23;$/;"	m	class:CXYMath	file:
k_B	XYMath.h	/^	static const Real k_B; \/\/ Boltzmann constant$/;"	m	class:CXYMath	access:public
key	ConfigFile.h	/^		string key;$/;"	m	struct:ConfigFile::key_not_found	access:public
keyExists	ConfigFile.cpp	/^bool ConfigFile::keyExists( const string& key ) const$/;"	f	class:ConfigFile	signature:( const string& key ) const
keyExists	ConfigFile.h	/^	bool keyExists( const string& key ) const;$/;"	p	class:ConfigFile	access:public	signature:( const string& key ) const
key_not_found	ConfigFile.h	/^		key_not_found( const string& key_ = string() )$/;"	f	struct:ConfigFile::key_not_found	access:public	signature:( const string& key_ = string() )
key_not_found	ConfigFile.h	/^	struct key_not_found {  \/\/ thrown only by T read(key) variant of read()$/;"	s	class:ConfigFile	access:public
kp	tree.hh	/^namespace kp {$/;"	n
kp::constructor	tree.hh	/^void constructor(T1* p) $/;"	f	namespace:kp	signature:(T1* p)
kp::constructor	tree.hh	/^void constructor(T1* p, T2& val) $/;"	f	namespace:kp	signature:(T1* p, T2& val)
kp::destructor	tree.hh	/^void destructor(T1* p)$/;"	f	namespace:kp	signature:(T1* p)
kptree	tree_util.hh	/^namespace kptree {$/;"	n
kptree::print_subtree_bracketed	tree_util.hh	/^void print_subtree_bracketed(const tree<T>& t, typename tree<T>::iterator iRoot, $/;"	p	namespace:kptree	signature:(const tree<T>& t, typename tree<T>::iterator iRoot, std::ostream& str=std::cout)
kptree::print_subtree_bracketed	tree_util.hh	/^void print_subtree_bracketed(const tree<T>& t, typename tree<T>::iterator iRoot, std::ostream& str) $/;"	f	namespace:kptree	signature:(const tree<T>& t, typename tree<T>::iterator iRoot, std::ostream& str)
kptree::print_tree_bracketed	tree_util.hh	/^void print_tree_bracketed(const tree<T>& t, std::ostream& str) $/;"	f	namespace:kptree	signature:(const tree<T>& t, std::ostream& str)
kptree::print_tree_bracketed	tree_util.hh	/^void print_tree_bracketed(const tree<T>& t, std::ostream& str=std::cout);$/;"	p	namespace:kptree	signature:(const tree<T>& t, std::ostream& str=std::cout)
last_child	tree.hh	/^	   tree_node_<T> *first_child, *last_child;$/;"	m	class:tree_node_	access:public
last_node_	octree.h	/^    OcTreeNode< CoordType, ValueType >* last_node_;$/;"	m	class:spatialaggregate::OcTreeNodeFixedCountAllocator	access:public
leaf_iterator	tree.hh	/^            leaf_iterator();$/;"	p	class:tree::leaf_iterator	access:public	signature:()
leaf_iterator	tree.hh	/^            leaf_iterator(const iterator_base&);$/;"	p	class:tree::leaf_iterator	access:public	signature:(const iterator_base&)
leaf_iterator	tree.hh	/^            leaf_iterator(const sibling_iterator&);$/;"	p	class:tree::leaf_iterator	access:public	signature:(const sibling_iterator&)
leaf_iterator	tree.hh	/^            leaf_iterator(tree_node *, tree_node *top=0);$/;"	p	class:tree::leaf_iterator	access:public	signature:(tree_node *, tree_node *top=0)
leaf_iterator	tree.hh	/^      class leaf_iterator : public iterator_base {$/;"	c	class:tree	inherits:iterator_base	access:public
leaf_iterator	tree.hh	/^      class leaf_iterator;$/;"	x
leaf_iterator	tree.hh	/^tree<T, tree_node_allocator>::leaf_iterator::leaf_iterator() $/;"	f	class:tree::leaf_iterator	signature:()
leaf_iterator	tree.hh	/^tree<T, tree_node_allocator>::leaf_iterator::leaf_iterator(const iterator_base &other)$/;"	f	class:tree::leaf_iterator	signature:(const iterator_base &other)
leaf_iterator	tree.hh	/^tree<T, tree_node_allocator>::leaf_iterator::leaf_iterator(const sibling_iterator& other)$/;"	f	class:tree::leaf_iterator	signature:(const sibling_iterator& other)
leaf_iterator	tree.hh	/^tree<T, tree_node_allocator>::leaf_iterator::leaf_iterator(tree_node *tn, tree_node *top)$/;"	f	class:tree::leaf_iterator	signature:(tree_node *tn, tree_node *top)
left	MersenneTwister.h	/^	int left;          \/\/ number of values left before reload needed$/;"	m	class:MTRand	access:protected
loBit	MersenneTwister.h	/^	uint32 loBit( const uint32 u ) const { return u & 0x00000001UL; }$/;"	f	class:MTRand	access:protected	signature:( const uint32 u ) const
loBits	MersenneTwister.h	/^	uint32 loBits( const uint32 u ) const { return u & 0x7fffffffUL; }$/;"	f	class:MTRand	access:protected	signature:( const uint32 u ) const
load	MersenneTwister.h	/^	void load( uint32 *const loadArray );  \/\/ from such array$/;"	p	class:MTRand	access:public	signature:( uint32 *const loadArray )
load	MersenneTwister.h	/^inline void MTRand::load( uint32 *const loadArray )$/;"	f	class:MTRand	signature:( uint32 *const loadArray )
log2_inv_	octree.h	/^    double log2_inv_;$/;"	m	class:spatialaggregate::OcTree	access:public
log_minimum_volume_size_	octree.h	/^    double log_minimum_volume_size_;$/;"	m	class:spatialaggregate::OcTree	access:public
m_Dr	XYSIS.h	/^  float m_dr, m_Dr;$/;"	m	class:CXYSIS	access:private
m_Err_Ind	XYSIS.h	/^  vector<pair<float,int> >  m_Err_Ind;$/;"	m	class:CXYSIS	access:private
m_Err_map	XYSIS.h	/^  map<tree<CXYVector<float> >::iterator, float,tree<CXYVector<float> >::iterator_base_less> m_Err_map;$/;"	m	class:CXYSIS	access:private
m_LogWeight	XYEnsemble.h	/^  double m_LogWeight;$/;"	m	class:CXYEnsemble	access:private
m_MContInd	XYEnsemble.h	/^	CXYMatrix<float> m_MContInd; \/\/ vector of contact index$/;"	m	class:CXYEnsemble	access:private
m_MContInd	XYSIS.h	/^  CXYMatrix<int> m_MContInd;$/;"	m	class:CXYSIS	access:private
m_MSegSegPval	XYSIS.h	/^  CXYMatrix<int> m_MSegSegPval;$/;"	m	class:CXYSIS	access:private
m_MSegSegPval_2	XYSIS.h	/^  CXYMatrix<float> m_MSegSegPval_2;$/;"	m	class:CXYSIS	access:private
m_MapOctree	XYSIS.h	/^  Iterator_OcTree_Map m_MapOctree;$/;"	m	class:CXYSIS	access:private
m_PrvSegmentLastTreeit_Vec	XYSIS.h	/^  vector<tree<CXYVector<float> >::iterator> m_PrvSegmentLastTreeit_Vec;$/;"	m	class:CXYSIS	access:private
m_PrvTreeit_Vec	XYSIS.h	/^  vector<tree<CXYVector<float> >::iterator> m_PrvTreeit_Vec;$/;"	m	class:CXYSIS	access:private
m_Treeit_VecpOctree_Map	XYSIS.h	/^  TreeIterator_VecpOcTree_Map m_Treeit_VecpOctree_Map;$/;"	m	class:CXYSIS	access:private
m_Weight_Ind	XYSIS.h	/^  vector<pair<float,int> >  m_Weight_Ind;$/;"	m	class:CXYSIS	access:private
m_a	XYLapack.h	/^	Real* m_a;$/;"	m	class:CXYLapackEigen	access:private
m_aafEntry	XYMatrix.h	/^    Real** m_aafEntry;$/;"	m	class:CXYMatrix	access:private
m_acAltLoc	XYPDBAtom.h	/^	char	m_acAltLoc[2];	\/\/ 17           Character        altLoc     Alternate location indicator.$/;"	m	class:CXYPDBAtom	access:private
m_acAtom	XYPDBAtom.h	/^	char	m_acAtom[5];		\/\/ 13 - 16      Atom             name       Atom name.$/;"	m	class:CXYPDBAtom	access:private
m_acAtomicSym	XYPDBAtom.h	/^	char	m_acAtomicSym[3];	\/\/ 13-14  $/;"	m	class:CXYPDBAtom	access:private
m_acBranchDes	XYPDBAtom.h	/^	char	m_acBranchDes[2]; \/\/ 16$/;"	m	class:CXYPDBAtom	access:private
m_acChainID	XYPDBAtom.h	/^	char	m_acChainID[2];	\/\/ 22           Character        chainID    Chain identifier.$/;"	m	class:CXYPDBAtom	access:private
m_acCharge	XYPDBAtom.h	/^	char	m_acCharge[3];	\/\/ 79 - 80      LString(2)       charge     Charge on the atom.$/;"	m	class:CXYPDBAtom	access:private
m_acElement	XYPDBAtom.h	/^	char	m_acElement[3];	\/\/ 77 - 78      LString(2)       element    Element symbol, right-justified.$/;"	m	class:CXYPDBAtom	access:private
m_acICode	XYPDBAtom.h	/^	char	m_acICode[2];		\/\/ 27           AChar            iCode      Code for insertion of residues.$/;"	m	class:CXYPDBAtom	access:private
m_acRecName	XYPDBAtom.h	/^	char	m_acRecName[7];	\/\/ 1 -  6      Record name      "ATOM    "$/;"	m	class:CXYPDBAtom	access:private
m_acRemoteInd	XYPDBAtom.h	/^	char	m_acRemoteInd[2]; \/\/ 15$/;"	m	class:CXYPDBAtom	access:private
m_acResName	XYPDBAtom.h	/^	char	m_acResName[4];	\/\/ 18 - 20      Residue name     resName    Residue name.$/;"	m	class:CXYPDBAtom	access:private
m_acSegID	XYPDBAtom.h	/^	char	m_acSegID[5];	\/\/ 73 - 76		LString(4)		segment identifier, left-justified. [format version 2.0 and later.]$/;"	m	class:CXYPDBAtom	access:private
m_afData	XYMatrix.h	/^    Real* m_afData;$/;"	m	class:CXYMatrix	access:private
m_afDiag	XYEigen.h	/^    Real* m_afDiag;$/;"	m	class:CXYEigen	access:private
m_afSubd	XYEigen.h	/^    Real* m_afSubd;$/;"	m	class:CXYEigen	access:private
m_afTuple	XYVector.h	/^    Real* m_afTuple;$/;"	m	class:CXYVector	access:private
m_bIsRotation	XYEigen.h	/^    bool m_bIsRotation;$/;"	m	class:CXYEigen	access:private
m_cDistFileName	XYSIS.h	/^  char* m_cDistFileName;$/;"	m	class:CXYSIS	access:private
m_cOutPath	XYEnsemble.h	/^	char* m_cOutPath;$/;"	m	class:CXYEnsemble	access:private
m_cOutPath	XYSIS.h	/^  char* m_cOutPath;$/;"	m	class:CXYSIS	access:private
m_center	XYEnsemble.h	/^  Eigen::Matrix< float, 4, 1 > m_center;$/;"	m	class:CXYEnsemble	access:private
m_center	XYSIS.h	/^  Eigen::Matrix<float, 4, 1> m_center;$/;"	m	class:CXYSIS	access:private
m_dr	XYEnsemble.h	/^  float m_dr;$/;"	m	class:CXYEnsemble	access:private
m_dr	XYSIS.h	/^  float m_dr, m_Dr;$/;"	m	class:CXYSIS	access:private
m_fAdjust	XYSIS.h	/^  float m_fAdjust; \/\/ adjust gamma matrix$/;"	m	class:CXYSIS	access:private
m_fBendingAngleBeg	XYEnsemble.h	/^	float m_fBendingAngleBeg; \/\/ binding angle begin$/;"	m	class:CXYEnsemble	access:private
m_fBendingAngleEnd	XYEnsemble.h	/^	float m_fBendingAngleEnd; \/\/ binding angle end$/;"	m	class:CXYEnsemble	access:private
m_fCollisionLength	XYEnsemble.h	/^	float m_fCollisionLength;   \/\/ collision length$/;"	m	class:CXYEnsemble	access:private
m_fCollisionLength	XYSIS.h	/^  float m_fCollisionLength;   \/\/ collision length$/;"	m	class:CXYSIS	access:private
m_fInvNumber	XYSIS.h	/^  float m_fInvNumber;$/;"	m	class:CXYSIS	access:private
m_fNucleusSphereDiameter	XYEnsemble.h	/^	float m_fNucleusSphereDiameter; $/;"	m	class:CXYEnsemble	access:private
m_fNucleusSphereDiameter	XYSIS.h	/^  float m_fNucleusSphereDiameter; $/;"	m	class:CXYSIS	access:private
m_fOccupancy	XYPDBAtom.h	/^	float	m_fOccupancy;	\/\/ 55 - 60      Real(6.2)        occupancy  Occupancy.$/;"	m	class:CXYPDBAtom	access:private
m_fPackingDensity	XYEnsemble.h	/^	float m_fPackingDensity;   \/\/ packing density$/;"	m	class:CXYEnsemble	access:private
m_fPackingDensity	XYSIS.h	/^  float m_fPackingDensity;   \/\/ packing density$/;"	m	class:CXYSIS	access:private
m_fPersistenceLength	XYEnsemble.h	/^	float m_fPersistenceLength; \/\/ persistence length$/;"	m	class:CXYEnsemble	access:private
m_fPersistenceLength	XYSIS.h	/^  float m_fPersistenceLength; \/\/ persistence length$/;"	m	class:CXYSIS	access:private
m_fRho_1	XYSIS.h	/^  float m_fRho_1, m_fRho_2, m_fRho_3, m_fTau_t; \/\/ function parameter$/;"	m	class:CXYSIS	access:private
m_fRho_2	XYSIS.h	/^  float m_fRho_1, m_fRho_2, m_fRho_3, m_fTau_t; \/\/ function parameter$/;"	m	class:CXYSIS	access:private
m_fRho_3	XYSIS.h	/^  float m_fRho_1, m_fRho_2, m_fRho_3, m_fTau_t; \/\/ function parameter$/;"	m	class:CXYSIS	access:private
m_fTau_t	XYSIS.h	/^  float m_fRho_1, m_fRho_2, m_fRho_3, m_fTau_t; \/\/ function parameter$/;"	m	class:CXYSIS	access:private
m_fTempFactor	XYPDBAtom.h	/^	float	m_fTempFactor;	\/\/ 61 - 66      Real(6.2)        tempFactor Temperature factor.$/;"	m	class:CXYPDBAtom	access:private
m_fTorsionAngleBeg	XYEnsemble.h	/^	float m_fTorsionAngleBeg;	\/\/ torsion angle begin$/;"	m	class:CXYEnsemble	access:private
m_fTorsionAngleEnd	XYEnsemble.h	/^	float m_fTorsionAngleEnd;	\/\/ torsion angle end$/;"	m	class:CXYEnsemble	access:private
m_fX	XYPDBAtom.h	/^	float	m_fX;			\/\/ 31 - 38      Real(8.3)        x          Orthogonal coordinates for X in Angstroms$/;"	m	class:CXYPDBAtom	access:private
m_fY	XYPDBAtom.h	/^	float	m_fY;			\/\/ 39 - 46      Real(8.3)        y          Orthogonal coordinates for Y in Angstroms$/;"	m	class:CXYPDBAtom	access:private
m_fZ	XYPDBAtom.h	/^	float	m_fZ;			\/\/ 47 - 54      Real(8.3)        z          Orthogonal coordinates for Z in Angstroms$/;"	m	class:CXYPDBAtom	access:private
m_iCols	XYMatrix.h	/^	int m_iRows, m_iCols, m_iQuantity;$/;"	m	class:CXYMatrix	access:private
m_iMmax	XYSIS.h	/^  int m_iMmax; \/\/ number of samples selected$/;"	m	class:CXYSIS	access:private
m_iNumBendingAngle	XYEnsemble.h	/^	int   m_iNumBendingAngle; 	\/\/ number of binding angle$/;"	m	class:CXYEnsemble	access:private
m_iNumMiddleEndPoints	XYEnsemble.h	/^  int m_iNumMiddleEndPoints;$/;"	m	class:CXYEnsemble	access:private
m_iNumMiddleEndPoints	XYSIS.h	/^  int m_iNumMiddleEndPoints;$/;"	m	class:CXYSIS	access:private
m_iNumNodes	XYEnsemble.h	/^	int   m_iNumNodes;$/;"	m	class:CXYEnsemble	access:private
m_iNumNodes	XYSIS.h	/^  int   m_iNumNodes;$/;"	m	class:CXYSIS	access:private
m_iNumPoints	XYSO3Sequence.h	/^	int m_iNumPoints;$/;"	m	class:CXYSO3Sequence	access:private
m_iNumSamplePoints	XYEnsemble.h	/^	int   m_iNumSamplePoints;$/;"	m	class:CXYEnsemble	access:private
m_iNumSamplePoints	XYSIS.h	/^  int   m_iNumSamplePoints;$/;"	m	class:CXYSIS	access:private
m_iNumTorsionAngle	XYEnsemble.h	/^	int   m_iNumTorsionAngle; 	\/\/ number of torsion angle$/;"	m	class:CXYEnsemble	access:private
m_iQuantity	XYMatrix.h	/^	int m_iRows, m_iCols, m_iQuantity;$/;"	m	class:CXYMatrix	access:private
m_iResSeq	XYPDBAtom.h	/^	int		m_iResSeq;		\/\/ 23 - 26      Integer          resSeq     Residue sequence number.$/;"	m	class:CXYPDBAtom	access:private
m_iRows	XYMatrix.h	/^	int m_iRows, m_iCols, m_iQuantity;$/;"	m	class:CXYMatrix	access:private
m_iSerial	XYPDBAtom.h	/^	int		m_iSerial;		\/\/ 7 - 11      Integer          serial     Atom serial number.$/;"	m	class:CXYPDBAtom	access:private
m_iSize	XYEigen.h	/^    int m_iSize;$/;"	m	class:CXYEigen	access:private
m_iSize	XYVector.h	/^	int m_iSize;$/;"	m	class:CXYVector	access:private
m_info	XYLapack.h	/^	int m_info;$/;"	m	class:CXYLapackEigen	access:private
m_jobz	XYLapack.h	/^	char* m_jobz;$/;"	m	class:CXYLapackEigen	access:private
m_kMat	XYEigen.h	/^    CXYMatrix<Real> m_kMat;$/;"	m	class:CXYEigen	access:private
m_kMat	XYLapack.h	/^	CXYMatrix<Real> m_kMat;$/;"	m	class:CXYLapackEigen	access:private
m_kPDBAtoms	XYPDB.h	/^	vector<CXYPDBAtom> m_kPDBAtoms;$/;"	m	class:CXYPDB	access:private
m_lda	XYLapack.h	/^	int m_lda;$/;"	m	class:CXYLapackEigen	access:private
m_lwork	XYLapack.h	/^	int m_lwork;$/;"	m	class:CXYLapackEigen	access:private
m_maxDepth	XYEnsemble.h	/^  int m_maxDepth;$/;"	m	class:CXYEnsemble	access:private
m_maxDepth	XYSIS.h	/^  int m_maxDepth;$/;"	m	class:CXYSIS	access:private
m_minimumVolumeSize	XYEnsemble.h	/^  float m_minimumVolumeSize;$/;"	m	class:CXYEnsemble	access:private
m_minimumVolumeSize	XYSIS.h	/^  float m_minimumVolumeSize;$/;"	m	class:CXYSIS	access:private
m_n	XYLapack.h	/^	int m_n;$/;"	m	class:CXYLapackEigen	access:private
m_pMDist	XYSIS.h	/^  CXYMatrix<float>* m_pMDist;$/;"	m	class:CXYSIS	access:private
m_pMSamplesOrg	XYEnsemble.h	/^	CXYMatrix<float>* m_pMSamplesOrg;$/;"	m	class:CXYEnsemble	access:private
m_pMSamplesOrg	XYSIS.h	/^  CXYMatrix<float>* m_pMSamplesOrg;$/;"	m	class:CXYSIS	access:private
m_pMSpherepoints	XYSO3Sequence.h	/^	CXYMatrix<float> *m_pMSpherepoints;$/;"	m	class:CXYSO3Sequence	access:private
m_pOctree	XYEnsemble.h	/^  OcTree<float,int>* m_pOctree;$/;"	m	class:CXYEnsemble	access:private
m_pTChain	XYEnsemble.h	/^	tree< CXYVector<float> >* m_pTChain; \/\/ tree stored coordinates$/;"	m	class:CXYEnsemble	access:private
m_pTChain	XYSIS.h	/^  tree< CXYVector<float> >* m_pTChain; \/\/ tree stored coordinates$/;"	m	class:CXYSIS	access:private
m_pVEColl	XYSIS.h	/^  CXYVector<float>* m_pVEColl;$/;"	m	class:CXYSIS	access:private
m_pVErr	XYSIS.h	/^  CXYVector<float>* m_pVErr;$/;"	m	class:CXYSIS	access:private
m_point	XYPDBAtom.h	/^	CXYPoint3Df m_point;$/;"	m	class:CXYPDBAtom	access:private
m_posInd_Vec	XYSIS.h	/^  vector<tree<CXYVector<float> >::iterator> m_posInd_Vec;$/;"	m	class:CXYSIS	access:private
m_qPrvNodes	XYSIS.h	/^  deque<tree<CXYVector<float> >::iterator> m_qPrvNodes;$/;"	m	class:CXYSIS	access:private
m_uplo	XYLapack.h	/^	char* m_uplo;$/;"	m	class:CXYLapackEigen	access:private
m_vConNodeInd	XYSIS.h	/^  vector<int> m_vConNodeInd; \/\/ unique sorted connection node index$/;"	m	class:CXYSIS	access:private
m_vDistQuantile	XYSIS.h	/^  vector<float> m_vDistQuantile;$/;"	m	class:CXYSIS	access:private
m_vLogWeight	XYEnsemble.h	/^  vector<float> m_vLogWeight;$/;"	m	class:CXYEnsemble	access:private
m_vPoints	XYSO3Sequence.h	/^	vector< vector<double > > m_vPoints;$/;"	m	class:CXYSO3Sequence	access:private
m_vPvalTriple	XYSIS.h	/^  vector<CXYTriple<int,int,int> > m_vPvalTriple;$/;"	m	class:CXYSIS	access:private
m_vSequence_base	XYSO3Sequence.h	/^	vector < int > m_vSequence_base;$/;"	m	class:CXYSO3Sequence	access:private
m_vfSegLength	XYEnsemble.h	/^	vector<float> m_vfSegLength; \/\/ vector of segment length (may different)$/;"	m	class:CXYEnsemble	access:private
m_vfSegLength	XYSIS.h	/^  vector<float> m_vfSegLength; \/\/ vector of segment length (may different)$/;"	m	class:CXYSIS	access:private
m_vtriple	XYSIS.h	/^  vector<CXYTriple<int,int,float> > m_vtriple;$/;"	m	class:CXYSIS	access:private
m_w	XYLapack.h	/^	Real* m_w;$/;"	m	class:CXYLapackEigen	access:private
m_work	XYLapack.h	/^	Real* m_work;$/;"	m	class:CXYLapackEigen	access:private
magic	MersenneTwister.h	/^	uint32 magic( const uint32 u ) const$/;"	f	class:MTRand	access:protected	signature:( const uint32 u ) const
main	MTexample.cpp	/^int main( int argc, char * const argv[] )$/;"	f	signature:( int argc, char * const argv[] )
mapci	ConfigFile.h	/^	typedef std::map<string,string>::const_iterator mapci;$/;"	t	class:ConfigFile	access:protected
mapi	ConfigFile.h	/^	typedef std::map<string,string>::iterator mapi;$/;"	t	class:ConfigFile	access:protected
maxResolutions_	octree.h	/^    float maxResolutions_[MAX_REPRESENTABLE_DEPTH+1];$/;"	m	class:spatialaggregate::OcTree	access:public
maxVolumeSizeForDepth	octree.h	/^    inline CoordType maxVolumeSizeForDepth( int depth ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( int depth )
max_depth	tree.hh	/^		int      max_depth() const;$/;"	p	class:tree	access:public	signature:() const
max_depth	tree.hh	/^		int      max_depth(const iterator_base&) const;$/;"	p	class:tree	access:public	signature:(const iterator_base&) const
max_depth	tree.hh	/^int tree<T, tree_node_allocator>::max_depth() const$/;"	f	class:tree	signature:() const
max_depth	tree.hh	/^int tree<T, tree_node_allocator>::max_depth(const iterator_base& pos) const$/;"	f	class:tree	signature:(const iterator_base& pos) const
max_depth_	octree.h	/^    int max_depth_;$/;"	m	class:spatialaggregate::OcTree	access:public
max_key_	octree.h	/^    OcTreeKey< CoordType, ValueType > pos_key_, min_key_, max_key_;$/;"	m	class:spatialaggregate::OcTreeNode	access:public
maxmasks_	octree.h	/^    uint32_t maxmasks_[MAX_REPRESENTABLE_DEPTH+1];$/;"	m	class:spatialaggregate::OcTree	access:public
merge	tree.hh	/^		void     merge(sibling_iterator, sibling_iterator, sibling_iterator, sibling_iterator, $/;"	p	class:tree	access:public	signature:(sibling_iterator, sibling_iterator, sibling_iterator, sibling_iterator, bool duplicate_leaves=false)
merge	tree.hh	/^void tree<T, tree_node_allocator>::merge(sibling_iterator to1,   sibling_iterator to2,$/;"	f	class:tree	signature:(sibling_iterator to1, sibling_iterator to2, sibling_iterator from1, sibling_iterator from2, bool duplicate_leaves)
minResolutions_	octree.h	/^    float minResolutions_[MAX_REPRESENTABLE_DEPTH+1];$/;"	m	class:spatialaggregate::OcTree	access:public
minVolumeSizeForDepth	octree.h	/^    inline CoordType minVolumeSizeForDepth( int depth ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( int depth )
min_key_	octree.h	/^    OcTreeKey< CoordType, ValueType > pos_key_, min_key_, max_key_;$/;"	m	class:spatialaggregate::OcTreeNode	access:public
min_position_	octree.h	/^    Eigen::Matrix< CoordType, 4, 1 > min_position_, position_normalizer_, inv_position_normalizer_;$/;"	m	class:spatialaggregate::OcTree	access:public
minimum_volume_size_	octree.h	/^    CoordType minimum_volume_size_, inv_minimum_volume_size_;$/;"	m	class:spatialaggregate::OcTree	access:public
minmasks_	octree.h	/^    uint32_t minmasks_[MAX_REPRESENTABLE_DEPTH+1];$/;"	m	class:spatialaggregate::OcTree	access:public
mixBits	MersenneTwister.h	/^	uint32 mixBits( const uint32 u, const uint32 v ) const$/;"	f	class:MTRand	access:protected	signature:( const uint32 u, const uint32 v ) const
mk_pix2xy	XYSO3Sequence.cpp	/^void CXYSO3Sequence::mk_pix2xy(int *pix2x, int *pix2y){$/;"	f	class:CXYSO3Sequence	signature:(int *pix2x, int *pix2y)
mk_pix2xy	XYSO3Sequence.h	/^	void mk_pix2xy(int *pix2x, int *pix2y);$/;"	p	class:CXYSO3Sequence	access:public	signature:(int *pix2x, int *pix2y)
move_after	tree.hh	/^		template<typename iter> iter move_after(iter target, iter source);$/;"	p	class:tree	access:public	signature:(iter target, iter source)
move_after	tree.hh	/^template <typename iter> iter tree<T, tree_node_allocator>::move_after(iter target, iter source)$/;"	f	class:tree	signature:(iter target, iter source)
move_before	tree.hh	/^      sibling_iterator move_before(sibling_iterator target, sibling_iterator source);$/;"	p	class:tree	access:public	signature:(sibling_iterator target, sibling_iterator source)
move_before	tree.hh	/^      template<typename iter> iter move_before(iter target, iter source);$/;"	p	class:tree	access:public	signature:(iter target, iter source)
move_before	tree.hh	/^template <typename iter> iter tree<T, tree_node_allocator>::move_before(iter target, iter source)$/;"	f	class:tree	signature:(iter target, iter source)
move_before	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::move_before(sibling_iterator target, $/;"	f	class:tree	signature:(sibling_iterator target, sibling_iterator source)
move_ontop	tree.hh	/^		template<typename iter> iter move_ontop(iter target, iter source);$/;"	p	class:tree	access:public	signature:(iter target, iter source)
move_ontop	tree.hh	/^template <typename iter> iter tree<T, tree_node_allocator>::move_ontop(iter target, iter source)$/;"	f	class:tree	signature:(iter target, iter source)
myComment	ConfigFile.h	/^	string myComment;    \/\/ separator between value and comments$/;"	m	class:ConfigFile	access:protected
myContents	ConfigFile.h	/^	std::map<string,string> myContents;  \/\/ extracted keys and values$/;"	m	class:ConfigFile	access:protected
myDelimiter	ConfigFile.h	/^	string myDelimiter;  \/\/ separator between key and value$/;"	m	class:ConfigFile	access:protected
mySentry	ConfigFile.h	/^	string mySentry;     \/\/ optional string to signal end of file$/;"	m	class:ConfigFile	access:protected
neighbor_octant_	octree.h	/^    uint32_t neighbor_octant_[8][27];$/;"	m	class:spatialaggregate::OcTree	access:public
neighborhood_m1_map_	octree.h	/^    uint32_t neighborhood_m1_map_[3];$/;"	m	class:spatialaggregate::OcTree	access:public
neighborhood_p1_map_	octree.h	/^    uint32_t neighborhood_p1_map_[3];$/;"	m	class:spatialaggregate::OcTree	access:public
neighbors_	octree.h	/^    OcTreeNode< CoordType, ValueType >* neighbors_[27];$/;"	m	class:spatialaggregate::OcTreeNode	access:public
nextToken	XYFile.h	/^   void nextToken(string& s) {$/;"	f	class:CXYStringTokenizer	access:public	signature:(string& s)
next_at_same_depth	tree.hh	/^		template<typename iter> iter next_at_same_depth(iter) const;$/;"	p	class:tree	access:public	signature:(iter) const
next_at_same_depth	tree.hh	/^iter tree<T, tree_node_allocator>::next_at_same_depth(iter position) const$/;"	f	class:tree	signature:(iter position) const
next_sibling	tree.hh	/^		template<typename iter> iter next_sibling(iter) const;$/;"	p	class:tree	access:public	signature:(iter) const
next_sibling	tree.hh	/^		tree_node_<T> *prev_sibling, *next_sibling;$/;"	m	class:tree_node_	access:public
next_sibling	tree.hh	/^iter tree<T, tree_node_allocator>::next_sibling(iter position) const$/;"	f	class:tree	signature:(iter position) const
node	tree.hh	/^				tree_node *node;$/;"	m	class:tree::iterator_base	access:public
nodes_	octree.h	/^    OcTreeNode< CoordType, ValueType >* nodes_;$/;"	m	class:spatialaggregate::OcTreeNodeFixedCountAllocator	access:public
number_of_children	tree.hh	/^				unsigned int number_of_children() const;$/;"	p	class:tree::iterator_base	access:public	signature:() const
number_of_children	tree.hh	/^		static unsigned int number_of_children(const iterator_base&);$/;"	p	class:tree	access:public	signature:(const iterator_base&)
number_of_children	tree.hh	/^unsigned int tree<T, tree_node_allocator>::iterator_base::number_of_children() const$/;"	f	class:tree::iterator_base	signature:() const
number_of_children	tree.hh	/^unsigned int tree<T, tree_node_allocator>::number_of_children(const iterator_base& it) $/;"	f	class:tree	signature:(const iterator_base& it)
number_of_siblings	tree.hh	/^		unsigned int number_of_siblings(const iterator_base&) const;$/;"	p	class:tree	access:public	signature:(const iterator_base&) const
number_of_siblings	tree.hh	/^unsigned int tree<T, tree_node_allocator>::number_of_siblings(const iterator_base& it) const$/;"	f	class:tree	signature:(const iterator_base& it) const
operator	XYMatrix.h	/^    Real operator( ) (int iRow, int iCol) const;$/;"	p	class:CXYMatrix	access:public	signature:(int iRow, int iCol) const
operator	XYMatrix.h	/^    Real& operator( ) (int iRow, int iCol);$/;"	p	class:CXYMatrix	access:public	signature:(int iRow, int iCol)
operator !=	XYMatrix.h	/^    bool operator!= (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
operator !=	XYMatrix.inl	/^bool CXYMatrix<Real>::operator!= (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
operator !=	XYPoint3D.h	/^    bool operator!= (const CXYPoint3D& rP) const;$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP) const
operator !=	XYPoint3D.inl	/^bool CXYPoint3D<Real>::operator!= (const CXYPoint3D& rP) const$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP) const
operator !=	XYVector.h	/^    bool operator!= (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV) const
operator !=	XYVector.inl	/^bool CXYVector<Real>::operator!= (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
operator !=	tree.hh	/^				bool    operator!=(const breadth_first_queued_iterator&) const;$/;"	p	class:tree::breadth_first_queued_iterator	access:public	signature:(const breadth_first_queued_iterator&) const
operator !=	tree.hh	/^				bool    operator!=(const fixed_depth_iterator&) const;$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(const fixed_depth_iterator&) const
operator !=	tree.hh	/^				bool    operator!=(const post_order_iterator&) const;$/;"	p	class:tree::post_order_iterator	access:public	signature:(const post_order_iterator&) const
operator !=	tree.hh	/^				bool    operator!=(const pre_order_iterator&) const;$/;"	p	class:tree::pre_order_iterator	access:public	signature:(const pre_order_iterator&) const
operator !=	tree.hh	/^				bool    operator!=(const sibling_iterator&) const;$/;"	p	class:tree::sibling_iterator	access:public	signature:(const sibling_iterator&) const
operator !=	tree.hh	/^            bool    operator!=(const leaf_iterator&) const;$/;"	p	class:tree::leaf_iterator	access:public	signature:(const leaf_iterator&) const
operator !=	tree.hh	/^bool tree<T, tree_node_allocator>::breadth_first_queued_iterator::operator!=(const breadth_first_queued_iterator& other) const$/;"	f	class:tree::breadth_first_queued_iterator	signature:(const breadth_first_queued_iterator& other) const
operator !=	tree.hh	/^bool tree<T, tree_node_allocator>::fixed_depth_iterator::operator!=(const fixed_depth_iterator& other) const$/;"	f	class:tree::fixed_depth_iterator	signature:(const fixed_depth_iterator& other) const
operator !=	tree.hh	/^bool tree<T, tree_node_allocator>::leaf_iterator::operator!=(const leaf_iterator& other) const$/;"	f	class:tree::leaf_iterator	signature:(const leaf_iterator& other) const
operator !=	tree.hh	/^bool tree<T, tree_node_allocator>::post_order_iterator::operator!=(const post_order_iterator& other) const$/;"	f	class:tree::post_order_iterator	signature:(const post_order_iterator& other) const
operator !=	tree.hh	/^bool tree<T, tree_node_allocator>::pre_order_iterator::operator!=(const pre_order_iterator& other) const$/;"	f	class:tree::pre_order_iterator	signature:(const pre_order_iterator& other) const
operator !=	tree.hh	/^bool tree<T, tree_node_allocator>::sibling_iterator::operator!=(const sibling_iterator& other) const$/;"	f	class:tree::sibling_iterator	signature:(const sibling_iterator& other) const
operator ()	MersenneTwister.h	/^	double operator()();                  \/\/ same as rand()$/;"	p	class:MTRand	access:public	signature:()
operator ()	MersenneTwister.h	/^inline double MTRand::operator()()$/;"	f	class:MTRand	signature:()
operator ()	XYEigen.cpp	/^Real& CXYEigen<Real>::operator() (int iRow, int iCol)$/;"	f	class:CXYEigen	signature:(int iRow, int iCol)
operator ()	XYEigen.h	/^    Real& operator() (int iRow, int iCol);$/;"	p	class:CXYEigen	access:public	signature:(int iRow, int iCol)
operator ()	XYLapack.cpp	/^Real& CXYLapackEigen<Real>::operator() (int iRow, int iCol)$/;"	f	class:CXYLapackEigen	signature:(int iRow, int iCol)
operator ()	XYLapack.h	/^	Real& operator() (int iRow, int iCol);$/;"	p	class:CXYLapackEigen	access:public	signature:(int iRow, int iCol)
operator ()	XYMatrix.inl	/^Real CXYMatrix<Real>::operator() (int iRow, int iCol) const$/;"	f	class:CXYMatrix	signature:(int iRow, int iCol) const
operator ()	XYMatrix.inl	/^Real& CXYMatrix<Real>::operator() (int iRow, int iCol)$/;"	f	class:CXYMatrix	signature:(int iRow, int iCol)
operator ()	XYSIS.h	/^  bool operator () ( const FloatIntPair& left, const FloatIntPair& right)$/;"	f	struct:FloatIntPairCompare	access:public	signature:( const FloatIntPair& left, const FloatIntPair& right)
operator ()	XYSIS.h	/^  bool operator ()(pair<int, int> const& left, pair<int, int> const& right) {$/;"	f	struct:RefOrder	access:public	signature:(pair<int, int> const& left, pair<int, int> const& right)
operator ()	XYUtility.h	/^	bool operator()(const pair<T1,T2>&left, const pair<T1,T2>&right) {$/;"	f	struct:sort_pair_first_greater	access:public	signature:(const pair<T1,T2>&left, const pair<T1,T2>&right)
operator ()	XYUtility.h	/^	bool operator()(const pair<T1,T2>&left, const pair<T1,T2>&right) {$/;"	f	struct:sort_pair_first_less	access:public	signature:(const pair<T1,T2>&left, const pair<T1,T2>&right)
operator ()	tree.hh	/^				bool operator()(const tree_node *a, const tree_node *b) $/;"	f	class:tree::compare_nodes	access:public	signature:(const tree_node *a, const tree_node *b)
operator ()	tree.hh	/^				bool operator()(const typename tree<T, tree_node_allocator>::iterator_base& one,$/;"	f	class:tree::iterator_base_less	access:public	signature:(const typename tree<T, tree_node_allocator>::iterator_base& one, const typename tree<T, tree_node_allocator>::iterator_base& two) const
operator *	XYMatrix.h	/^    CXYMatrix operator* (Real fScalar) const;$/;"	p	class:CXYMatrix	access:public	signature:(Real fScalar) const
operator *	XYMatrix.h	/^    CXYMatrix operator* (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
operator *	XYMatrix.h	/^    CXYVector<Real> operator* (const CXYVector<Real>& rkV) const;  \/\/ M * v$/;"	p	class:CXYMatrix	access:public	signature:(const CXYVector<Real>& rkV) const
operator *	XYMatrix.h	/^CXYMatrix<Real> operator* (Real fScalar, const CXYMatrix<Real>& rkM);$/;"	p	signature:(Real fScalar, const CXYMatrix<Real>& rkM)
operator *	XYMatrix.h	/^CXYVector<Real> operator* (const CXYVector<Real>& rkV, const CXYMatrix<Real>& rkM);$/;"	p	signature:(const CXYVector<Real>& rkV, const CXYMatrix<Real>& rkM)
operator *	XYMatrix.inl	/^CXYMatrix<Real> CXYMatrix<Real>::operator* (Real fScalar) const$/;"	f	class:CXYMatrix	signature:(Real fScalar) const
operator *	XYMatrix.inl	/^CXYMatrix<Real> CXYMatrix<Real>::operator* (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
operator *	XYMatrix.inl	/^CXYMatrix<Real> operator* (Real fScalar, const CXYMatrix<Real>& rkM)$/;"	f	signature:(Real fScalar, const CXYMatrix<Real>& rkM)
operator *	XYMatrix.inl	/^CXYVector<Real> CXYMatrix<Real>::operator* (const CXYVector<Real>& rkV) const$/;"	f	class:CXYMatrix	signature:(const CXYVector<Real>& rkV) const
operator *	XYMatrix.inl	/^CXYVector<Real> operator* (const CXYVector<Real>& rkV, const CXYMatrix<Real>& rkM)$/;"	f	signature:(const CXYVector<Real>& rkV, const CXYMatrix<Real>& rkM)
operator *	XYPoint3D.h	/^    CXYPoint3D operator* (Real fScalar) const;$/;"	p	class:CXYPoint3D	access:public	signature:(Real fScalar) const
operator *	XYPoint3D.inl	/^CXYPoint3D<Real> CXYPoint3D<Real>::operator* (Real fScalar) const$/;"	f	class:CXYPoint3D	signature:(Real fScalar) const
operator *	XYVector.h	/^    CXYVector operator* (Real fScalar) const;$/;"	p	class:CXYVector	access:public	signature:(Real fScalar) const
operator *	XYVector.h	/^CXYVector<Real> operator* (Real fScalar, const CXYVector<Real>& rkV);$/;"	p	signature:(Real fScalar, const CXYVector<Real>& rkV)
operator *	XYVector.inl	/^CXYVector<Real> CXYVector<Real>::operator* (Real fScalar) const$/;"	f	class:CXYVector	signature:(Real fScalar) const
operator *	XYVector.inl	/^CXYVector<Real> operator* (Real fScalar, const CXYVector<Real>& rkV)$/;"	f	signature:(Real fScalar, const CXYVector<Real>& rkV)
operator *	tree.hh	/^				T&             operator*() const;$/;"	p	class:tree::iterator_base	access:public	signature:() const
operator *	tree.hh	/^T& tree<T, tree_node_allocator>::iterator_base::operator*() const$/;"	f	class:tree::iterator_base	signature:() const
operator *=	XYMatrix.h	/^    CXYMatrix& operator*= (Real fScalar);$/;"	p	class:CXYMatrix	access:public	signature:(Real fScalar)
operator *=	XYMatrix.inl	/^CXYMatrix<Real>& CXYMatrix<Real>::operator*= (Real fScalar)$/;"	f	class:CXYMatrix	signature:(Real fScalar)
operator *=	XYPoint3D.h	/^	CXYPoint3D& operator*= (Real fScalar);$/;"	p	class:CXYPoint3D	access:public	signature:(Real fScalar)
operator *=	XYPoint3D.inl	/^CXYPoint3D<Real>& CXYPoint3D<Real>::operator*= (Real fScalar)$/;"	f	class:CXYPoint3D	signature:(Real fScalar)
operator *=	XYVector.h	/^    CXYVector& operator*= (Real fScalar);$/;"	p	class:CXYVector	access:public	signature:(Real fScalar)
operator *=	XYVector.inl	/^CXYVector<Real>& CXYVector<Real>::operator *= (Real fScalar)$/;"	f	class:CXYVector	signature:(Real fScalar)
operator +	XYMatrix.h	/^    CXYMatrix operator+ (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
operator +	XYMatrix.inl	/^CXYMatrix<Real> CXYMatrix<Real>::operator+ (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
operator +	XYPoint3D.h	/^    CXYPoint3D operator+ (const CXYPoint3D& rP) const;$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP) const
operator +	XYPoint3D.inl	/^CXYPoint3D<Real> CXYPoint3D<Real>::operator+ (const CXYPoint3D& rP) const$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP) const
operator +	XYVector.h	/^    CXYVector operator+ (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV) const
operator +	XYVector.inl	/^CXYVector<Real> CXYVector<Real>::operator+ (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
operator ++	tree.hh	/^				breadth_first_queued_iterator   operator++(int);$/;"	p	class:tree::breadth_first_queued_iterator	access:public	signature:(int)
operator ++	tree.hh	/^				breadth_first_queued_iterator&  operator++();$/;"	p	class:tree::breadth_first_queued_iterator	access:public	signature:()
operator ++	tree.hh	/^				fixed_depth_iterator   operator++(int);$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(int)
operator ++	tree.hh	/^				fixed_depth_iterator&  operator++();$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:()
operator ++	tree.hh	/^				post_order_iterator   operator++(int);$/;"	p	class:tree::post_order_iterator	access:public	signature:(int)
operator ++	tree.hh	/^				post_order_iterator&  operator++();$/;"	p	class:tree::post_order_iterator	access:public	signature:()
operator ++	tree.hh	/^				pre_order_iterator   operator++(int);$/;"	p	class:tree::pre_order_iterator	access:public	signature:(int)
operator ++	tree.hh	/^				pre_order_iterator&  operator++();$/;"	p	class:tree::pre_order_iterator	access:public	signature:()
operator ++	tree.hh	/^				sibling_iterator   operator++(int);$/;"	p	class:tree::sibling_iterator	access:public	signature:(int)
operator ++	tree.hh	/^				sibling_iterator&  operator++();$/;"	p	class:tree::sibling_iterator	access:public	signature:()
operator ++	tree.hh	/^            leaf_iterator   operator++(int);$/;"	p	class:tree::leaf_iterator	access:public	signature:(int)
operator ++	tree.hh	/^            leaf_iterator&  operator++();$/;"	p	class:tree::leaf_iterator	access:public	signature:()
operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::breadth_first_queued_iterator tree<T, tree_node_allocator>::breadth_first_queued_iterator::operator++(int)$/;"	f	class:tree::breadth_first_queued_iterator	signature:(int)
operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::breadth_first_queued_iterator& tree<T, tree_node_allocator>::breadth_first_queued_iterator::operator++()$/;"	f	class:tree::breadth_first_queued_iterator	signature:()
operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator tree<T, tree_node_allocator>::fixed_depth_iterator::operator++(int)$/;"	f	class:tree::fixed_depth_iterator	signature:(int)
operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator& tree<T, tree_node_allocator>::fixed_depth_iterator::operator++()$/;"	f	class:tree::fixed_depth_iterator	signature:()
operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator tree<T, tree_node_allocator>::leaf_iterator::operator++(int)$/;"	f	class:tree::leaf_iterator	signature:(int)
operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator& tree<T, tree_node_allocator>::leaf_iterator::operator++()$/;"	f	class:tree::leaf_iterator	signature:()
operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator tree<T, tree_node_allocator>::post_order_iterator::operator++(int)$/;"	f	class:tree::post_order_iterator	signature:(int)
operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator& tree<T, tree_node_allocator>::post_order_iterator::operator++()$/;"	f	class:tree::post_order_iterator	signature:()
operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator tree<T, tree_node_allocator>::pre_order_iterator::operator++(int)$/;"	f	class:tree::pre_order_iterator	signature:(int)
operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator& tree<T, tree_node_allocator>::pre_order_iterator::operator++()$/;"	f	class:tree::pre_order_iterator	signature:()
operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::sibling_iterator::operator++(int)$/;"	f	class:tree::sibling_iterator	signature:(int)
operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator& tree<T, tree_node_allocator>::sibling_iterator::operator++()$/;"	f	class:tree::sibling_iterator	signature:()
operator +=	XYMatrix.h	/^    CXYMatrix& operator+= (const CXYMatrix& rkM);$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM)
operator +=	XYMatrix.inl	/^CXYMatrix<Real>& CXYMatrix<Real>::operator+= (const CXYMatrix& rkM)$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM)
operator +=	XYPoint3D.h	/^	CXYPoint3D& operator+= (const CXYPoint3D& rP);$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP)
operator +=	XYPoint3D.inl	/^CXYPoint3D<Real>& CXYPoint3D<Real>::operator+= (const CXYPoint3D& rP)$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP)
operator +=	XYVector.h	/^    CXYVector& operator+= (const CXYVector& rkV);$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV)
operator +=	XYVector.inl	/^CXYVector<Real>& CXYVector<Real>::operator += (const CXYVector& rkV)$/;"	f	class:CXYVector	signature:(const CXYVector& rkV)
operator +=	tree.hh	/^				breadth_first_queued_iterator&  operator+=(unsigned int);$/;"	p	class:tree::breadth_first_queued_iterator	access:public	signature:(unsigned int)
operator +=	tree.hh	/^				fixed_depth_iterator&  operator+=(unsigned int);$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(unsigned int)
operator +=	tree.hh	/^				post_order_iterator&  operator+=(unsigned int);$/;"	p	class:tree::post_order_iterator	access:public	signature:(unsigned int)
operator +=	tree.hh	/^				pre_order_iterator&  operator+=(unsigned int);$/;"	p	class:tree::pre_order_iterator	access:public	signature:(unsigned int)
operator +=	tree.hh	/^				sibling_iterator&  operator+=(unsigned int);$/;"	p	class:tree::sibling_iterator	access:public	signature:(unsigned int)
operator +=	tree.hh	/^            leaf_iterator&  operator+=(unsigned int);$/;"	p	class:tree::leaf_iterator	access:public	signature:(unsigned int)
operator +=	tree.hh	/^typename tree<T, tree_node_allocator>::breadth_first_queued_iterator& tree<T, tree_node_allocator>::breadth_first_queued_iterator::operator+=(unsigned int num)$/;"	f	class:tree::breadth_first_queued_iterator	signature:(unsigned int num)
operator +=	tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator& tree<T, tree_node_allocator>::fixed_depth_iterator::operator+=(unsigned int num)$/;"	f	class:tree::fixed_depth_iterator	signature:(unsigned int num)
operator +=	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator& tree<T, tree_node_allocator>::leaf_iterator::operator+=(unsigned int num)$/;"	f	class:tree::leaf_iterator	signature:(unsigned int num)
operator +=	tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator& tree<T, tree_node_allocator>::post_order_iterator::operator+=(unsigned int num)$/;"	f	class:tree::post_order_iterator	signature:(unsigned int num)
operator +=	tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator& tree<T, tree_node_allocator>::pre_order_iterator::operator+=(unsigned int num)$/;"	f	class:tree::pre_order_iterator	signature:(unsigned int num)
operator +=	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator& tree<T, tree_node_allocator>::sibling_iterator::operator+=(unsigned int num)$/;"	f	class:tree::sibling_iterator	signature:(unsigned int num)
operator -	XYMatrix.h	/^    CXYMatrix operator- () const;$/;"	p	class:CXYMatrix	access:public	signature:() const
operator -	XYMatrix.h	/^    CXYMatrix operator- (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
operator -	XYMatrix.inl	/^CXYMatrix<Real> CXYMatrix<Real>::operator- () const$/;"	f	class:CXYMatrix	signature:() const
operator -	XYMatrix.inl	/^CXYMatrix<Real> CXYMatrix<Real>::operator- (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
operator -	XYPoint3D.h	/^    CXYPoint3D operator- () const;$/;"	p	class:CXYPoint3D	access:public	signature:() const
operator -	XYPoint3D.h	/^    CXYPoint3D operator- (const CXYPoint3D& rP) const;$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP) const
operator -	XYPoint3D.inl	/^CXYPoint3D<Real> CXYPoint3D<Real>::operator- () const$/;"	f	class:CXYPoint3D	signature:() const
operator -	XYPoint3D.inl	/^CXYPoint3D<Real> CXYPoint3D<Real>::operator- (const CXYPoint3D& rP) const$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP) const
operator -	XYVector.h	/^    CXYVector operator- () const;$/;"	p	class:CXYVector	access:public	signature:() const
operator -	XYVector.h	/^    CXYVector operator- (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV) const
operator -	XYVector.inl	/^CXYVector<Real> CXYVector<Real>::operator -() const$/;"	f	class:CXYVector	signature:() const
operator -	XYVector.inl	/^CXYVector<Real> CXYVector<Real>::operator- (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
operator --	tree.hh	/^				fixed_depth_iterator   operator--(int);$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(int)
operator --	tree.hh	/^				post_order_iterator   operator--(int);$/;"	p	class:tree::post_order_iterator	access:public	signature:(int)
operator --	tree.hh	/^				pre_order_iterator   operator--(int);$/;"	p	class:tree::pre_order_iterator	access:public	signature:(int)
operator --	tree.hh	/^				sibling_iterator   operator--(int);$/;"	p	class:tree::sibling_iterator	access:public	signature:(int)
operator --	tree.hh	/^				sibling_iterator&  operator--();$/;"	p	class:tree::sibling_iterator	access:public	signature:()
operator --	tree.hh	/^			   fixed_depth_iterator&  operator--();$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:()
operator --	tree.hh	/^			   post_order_iterator&  operator--();$/;"	p	class:tree::post_order_iterator	access:public	signature:()
operator --	tree.hh	/^			   pre_order_iterator&  operator--();$/;"	p	class:tree::pre_order_iterator	access:public	signature:()
operator --	tree.hh	/^            leaf_iterator   operator--(int);$/;"	p	class:tree::leaf_iterator	access:public	signature:(int)
operator --	tree.hh	/^            leaf_iterator&  operator--();$/;"	p	class:tree::leaf_iterator	access:public	signature:()
operator --	tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator tree<T, tree_node_allocator>::fixed_depth_iterator::operator--(int)$/;"	f	class:tree::fixed_depth_iterator	signature:(int)
operator --	tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator& tree<T, tree_node_allocator>::fixed_depth_iterator::operator--()$/;"	f	class:tree::fixed_depth_iterator	signature:()
operator --	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator tree<T, tree_node_allocator>::leaf_iterator::operator--(int)$/;"	f	class:tree::leaf_iterator	signature:(int)
operator --	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator& tree<T, tree_node_allocator>::leaf_iterator::operator--()$/;"	f	class:tree::leaf_iterator	signature:()
operator --	tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator tree<T, tree_node_allocator>::post_order_iterator::operator--(int)$/;"	f	class:tree::post_order_iterator	signature:(int)
operator --	tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator& tree<T, tree_node_allocator>::post_order_iterator::operator--()$/;"	f	class:tree::post_order_iterator	signature:()
operator --	tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator tree<T, tree_node_allocator>::pre_order_iterator::operator--(int)$/;"	f	class:tree::pre_order_iterator	signature:(int)
operator --	tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator& tree<T, tree_node_allocator>::pre_order_iterator::operator--()$/;"	f	class:tree::pre_order_iterator	signature:()
operator --	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::sibling_iterator::operator--(int)$/;"	f	class:tree::sibling_iterator	signature:(int)
operator --	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator& tree<T, tree_node_allocator>::sibling_iterator::operator--()$/;"	f	class:tree::sibling_iterator	signature:()
operator -=	XYMatrix.h	/^    CXYMatrix& operator-= (const CXYMatrix& rkM);$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM)
operator -=	XYMatrix.inl	/^CXYMatrix<Real>& CXYMatrix<Real>::operator-= (const CXYMatrix& rkM)$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM)
operator -=	XYPoint3D.h	/^	CXYPoint3D& operator-= (const CXYPoint3D& rP);$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP)
operator -=	XYPoint3D.inl	/^CXYPoint3D<Real>& CXYPoint3D<Real>::operator-= (const CXYPoint3D& rP)$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP)
operator -=	XYVector.h	/^    CXYVector& operator-= (const CXYVector& rkV);$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV)
operator -=	XYVector.inl	/^CXYVector<Real>& CXYVector<Real>::operator -= (const CXYVector& rkV)$/;"	f	class:CXYVector	signature:(const CXYVector& rkV)
operator -=	tree.hh	/^				fixed_depth_iterator&  operator-=(unsigned int);$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(unsigned int)
operator -=	tree.hh	/^				post_order_iterator&  operator-=(unsigned int);$/;"	p	class:tree::post_order_iterator	access:public	signature:(unsigned int)
operator -=	tree.hh	/^				pre_order_iterator&  operator-=(unsigned int);$/;"	p	class:tree::pre_order_iterator	access:public	signature:(unsigned int)
operator -=	tree.hh	/^				sibling_iterator&  operator-=(unsigned int);$/;"	p	class:tree::sibling_iterator	access:public	signature:(unsigned int)
operator -=	tree.hh	/^            leaf_iterator&  operator-=(unsigned int);$/;"	p	class:tree::leaf_iterator	access:public	signature:(unsigned int)
operator -=	tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator& tree<T, tree_node_allocator>::fixed_depth_iterator::operator-=(unsigned int num)$/;"	f	class:tree::fixed_depth_iterator	signature:(unsigned int num)
operator -=	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator& tree<T, tree_node_allocator>::leaf_iterator::operator-=(unsigned int num)$/;"	f	class:tree::leaf_iterator	signature:(unsigned int num)
operator -=	tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator& tree<T, tree_node_allocator>::post_order_iterator::operator-=(unsigned int num)$/;"	f	class:tree::post_order_iterator	signature:(unsigned int num)
operator -=	tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator& tree<T, tree_node_allocator>::pre_order_iterator::operator-=(unsigned int num)$/;"	f	class:tree::pre_order_iterator	signature:(unsigned int num)
operator -=	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator& tree<T, tree_node_allocator>::sibling_iterator::operator-=(unsigned int num)$/;"	f	class:tree::sibling_iterator	signature:(unsigned int num)
operator ->	tree.hh	/^				T*             operator->() const;$/;"	p	class:tree::iterator_base	access:public	signature:() const
operator ->	tree.hh	/^T* tree<T, tree_node_allocator>::iterator_base::operator->() const$/;"	f	class:tree::iterator_base	signature:() const
operator /	XYMatrix.h	/^    CXYMatrix operator\/ (Real fScalar) const;$/;"	p	class:CXYMatrix	access:public	signature:(Real fScalar) const
operator /	XYMatrix.inl	/^CXYMatrix<Real> CXYMatrix<Real>::operator\/ (Real fScalar) const$/;"	f	class:CXYMatrix	signature:(Real fScalar) const
operator /	XYPoint3D.h	/^    CXYPoint3D operator\/ (Real fScalar) const;$/;"	p	class:CXYPoint3D	access:public	signature:(Real fScalar) const
operator /	XYPoint3D.inl	/^CXYPoint3D<Real> CXYPoint3D<Real>::operator\/ (Real fScalar) const$/;"	f	class:CXYPoint3D	signature:(Real fScalar) const
operator /	XYVector.h	/^    CXYVector operator\/ (Real fScalar) const;$/;"	p	class:CXYVector	access:public	signature:(Real fScalar) const
operator /	XYVector.inl	/^CXYVector<Real> CXYVector<Real>::operator\/ (Real fScalar) const$/;"	f	class:CXYVector	signature:(Real fScalar) const
operator /=	XYMatrix.h	/^    CXYMatrix& operator\/= (Real fScalar);$/;"	p	class:CXYMatrix	access:public	signature:(Real fScalar)
operator /=	XYMatrix.inl	/^CXYMatrix<Real>& CXYMatrix<Real>::operator\/= (Real fScalar)$/;"	f	class:CXYMatrix	signature:(Real fScalar)
operator /=	XYPoint3D.h	/^	CXYPoint3D& operator\/= (Real fScalar);$/;"	p	class:CXYPoint3D	access:public	signature:(Real fScalar)
operator /=	XYPoint3D.inl	/^CXYPoint3D<Real>& CXYPoint3D<Real>::operator\/= (Real fScalar)$/;"	f	class:CXYPoint3D	signature:(Real fScalar)
operator /=	XYVector.h	/^    CXYVector& operator\/= (Real fScalar);$/;"	p	class:CXYVector	access:public	signature:(Real fScalar)
operator /=	XYVector.inl	/^CXYVector<Real>& CXYVector<Real>::operator \/= (Real fScalar)$/;"	f	class:CXYVector	signature:(Real fScalar)
operator <	XYMatrix.h	/^    bool operator<  (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
operator <	XYMatrix.inl	/^bool CXYMatrix<Real>::operator<  (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
operator <	XYPoint3D.h	/^    bool operator<  (const CXYPoint3D& rP) const;$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP) const
operator <	XYPoint3D.inl	/^bool CXYPoint3D<Real>::operator< (const CXYPoint3D& rP) const$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP) const
operator <	XYVector.h	/^    bool operator<  (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV) const
operator <	XYVector.inl	/^bool CXYVector<Real>::operator< (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
operator <<	ConfigFile.cpp	/^std::ostream& operator<<( std::ostream& os, const ConfigFile& cf )$/;"	f	signature:( std::ostream& os, const ConfigFile& cf )
operator <<	ConfigFile.h	/^	friend std::ostream& operator<<( std::ostream& os, const ConfigFile& cf );$/;"	p	class:ConfigFile	access:friend	signature:( std::ostream& os, const ConfigFile& cf )
operator <<	MersenneTwister.h	/^	friend std::ostream& operator<<( std::ostream& os, const MTRand& mtrand );$/;"	p	class:MTRand	access:friend	signature:( std::ostream& os, const MTRand& mtrand )
operator <<	MersenneTwister.h	/^inline std::ostream& operator<<( std::ostream& os, const MTRand& mtrand )$/;"	f	signature:( std::ostream& os, const MTRand& mtrand )
operator <=	XYMatrix.h	/^    bool operator<= (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
operator <=	XYMatrix.inl	/^bool CXYMatrix<Real>::operator<= (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
operator <=	XYPoint3D.h	/^    bool operator<= (const CXYPoint3D& rP) const;$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP) const
operator <=	XYPoint3D.inl	/^bool CXYPoint3D<Real>::operator<= (const CXYPoint3D& rP) const$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP) const
operator <=	XYVector.h	/^    bool operator<= (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV) const
operator <=	XYVector.inl	/^bool CXYVector<Real>::operator<= (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
operator =	MersenneTwister.h	/^	MTRand& operator=( const MTRand& o );$/;"	p	class:MTRand	access:public	signature:( const MTRand& o )
operator =	MersenneTwister.h	/^inline MTRand& MTRand::operator=( const MTRand& o )$/;"	f	class:MTRand	signature:( const MTRand& o )
operator =	XYEigen.cpp	/^CXYEigen<Real>& CXYEigen<Real>::operator= (const CXYMatrix<Real>& rkM)$/;"	f	class:CXYEigen	signature:(const CXYMatrix<Real>& rkM)
operator =	XYEigen.h	/^    CXYEigen& operator= (const CXYMatrix<Real>& rkM);$/;"	p	class:CXYEigen	access:public	signature:(const CXYMatrix<Real>& rkM)
operator =	XYLapack.cpp	/^CXYLapackEigen<Real>& CXYLapackEigen<Real>::operator= (const CXYMatrix<Real>& rkM)$/;"	f	class:CXYLapackEigen	signature:(const CXYMatrix<Real>& rkM)
operator =	XYLapack.h	/^	CXYLapackEigen& operator= (const CXYMatrix<Real>& rkM);$/;"	p	class:CXYLapackEigen	access:public	signature:(const CXYMatrix<Real>& rkM)
operator =	XYMatrix.h	/^    CXYMatrix& operator= (const CXYMatrix& rkM);$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM)
operator =	XYMatrix.inl	/^CXYMatrix<Real>& CXYMatrix<Real>::operator= (const CXYMatrix& rkM)$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM)
operator =	XYPDB.cpp	/^CXYPDB& CXYPDB::operator= (const CXYPDB& rkPDB)$/;"	f	class:CXYPDB	signature:(const CXYPDB& rkPDB)
operator =	XYPDB.h	/^	CXYPDB& operator= (const CXYPDB& rkPDB);$/;"	p	class:CXYPDB	access:public	signature:(const CXYPDB& rkPDB)
operator =	XYPoint3D.h	/^    CXYPoint3D& operator= (const CXYPoint3D& rP);$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP)
operator =	XYPoint3D.inl	/^CXYPoint3D<Real>& CXYPoint3D<Real>::operator= (const CXYPoint3D& rP)$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP)
operator =	XYVector.h	/^    CXYVector& operator= (const CXYVector& rkV);$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV)
operator =	XYVector.inl	/^CXYVector<Real>& CXYVector<Real>::operator= (const CXYVector& rkV)$/;"	f	class:CXYVector	signature:(const CXYVector& rkV)
operator =	tree.hh	/^		void operator=(const tree<T, tree_node_allocator>&);$/;"	p	class:tree	access:public	signature:(const tree<T, tree_node_allocator>&)
operator =	tree.hh	/^void tree<T, tree_node_allocator>::operator=(const tree<T, tree_node_allocator>& other)$/;"	f	class:tree	signature:(const tree<T, tree_node_allocator>& other)
operator ==	XYMatrix.h	/^    bool operator== (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
operator ==	XYMatrix.inl	/^bool CXYMatrix<Real>::operator== (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
operator ==	XYPoint3D.h	/^    bool operator== (const CXYPoint3D& rP) const;$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP) const
operator ==	XYPoint3D.inl	/^bool CXYPoint3D<Real>::operator== (const CXYPoint3D& rP) const$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP) const
operator ==	XYVector.h	/^    bool operator== (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV) const
operator ==	XYVector.inl	/^bool CXYVector<Real>::operator== (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
operator ==	octree.h	/^    inline bool operator==(const OcTreeKey &rhs) {$/;"	f	class:spatialaggregate::OcTreeKey	access:public	signature:(const OcTreeKey &rhs)
operator ==	tree.hh	/^				bool    operator==(const breadth_first_queued_iterator&) const;$/;"	p	class:tree::breadth_first_queued_iterator	access:public	signature:(const breadth_first_queued_iterator&) const
operator ==	tree.hh	/^				bool    operator==(const fixed_depth_iterator&) const;$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(const fixed_depth_iterator&) const
operator ==	tree.hh	/^				bool    operator==(const post_order_iterator&) const;$/;"	p	class:tree::post_order_iterator	access:public	signature:(const post_order_iterator&) const
operator ==	tree.hh	/^				bool    operator==(const pre_order_iterator&) const;$/;"	p	class:tree::pre_order_iterator	access:public	signature:(const pre_order_iterator&) const
operator ==	tree.hh	/^				bool    operator==(const sibling_iterator&) const;$/;"	p	class:tree::sibling_iterator	access:public	signature:(const sibling_iterator&) const
operator ==	tree.hh	/^            bool    operator==(const leaf_iterator&) const;$/;"	p	class:tree::leaf_iterator	access:public	signature:(const leaf_iterator&) const
operator ==	tree.hh	/^bool tree<T, tree_node_allocator>::breadth_first_queued_iterator::operator==(const breadth_first_queued_iterator& other) const$/;"	f	class:tree::breadth_first_queued_iterator	signature:(const breadth_first_queued_iterator& other) const
operator ==	tree.hh	/^bool tree<T, tree_node_allocator>::fixed_depth_iterator::operator==(const fixed_depth_iterator& other) const$/;"	f	class:tree::fixed_depth_iterator	signature:(const fixed_depth_iterator& other) const
operator ==	tree.hh	/^bool tree<T, tree_node_allocator>::leaf_iterator::operator==(const leaf_iterator& other) const$/;"	f	class:tree::leaf_iterator	signature:(const leaf_iterator& other) const
operator ==	tree.hh	/^bool tree<T, tree_node_allocator>::post_order_iterator::operator==(const post_order_iterator& other) const$/;"	f	class:tree::post_order_iterator	signature:(const post_order_iterator& other) const
operator ==	tree.hh	/^bool tree<T, tree_node_allocator>::pre_order_iterator::operator==(const pre_order_iterator& other) const$/;"	f	class:tree::pre_order_iterator	signature:(const pre_order_iterator& other) const
operator ==	tree.hh	/^bool tree<T, tree_node_allocator>::sibling_iterator::operator==(const sibling_iterator& other) const$/;"	f	class:tree::sibling_iterator	signature:(const sibling_iterator& other) const
operator >	XYMatrix.h	/^    bool operator>  (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
operator >	XYMatrix.inl	/^bool CXYMatrix<Real>::operator>  (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
operator >	XYPoint3D.h	/^    bool operator>  (const CXYPoint3D& rP) const;$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP) const
operator >	XYPoint3D.inl	/^bool CXYPoint3D<Real>::operator> (const CXYPoint3D& rP) const$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP) const
operator >	XYVector.h	/^    bool operator>  (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV) const
operator >	XYVector.inl	/^bool CXYVector<Real>::operator> (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
operator >=	XYMatrix.h	/^    bool operator>= (const CXYMatrix& rkM) const;$/;"	p	class:CXYMatrix	access:public	signature:(const CXYMatrix& rkM) const
operator >=	XYMatrix.inl	/^bool CXYMatrix<Real>::operator>= (const CXYMatrix& rkM) const$/;"	f	class:CXYMatrix	signature:(const CXYMatrix& rkM) const
operator >=	XYPoint3D.h	/^    bool operator>= (const CXYPoint3D& rP) const;$/;"	p	class:CXYPoint3D	access:public	signature:(const CXYPoint3D& rP) const
operator >=	XYPoint3D.inl	/^bool CXYPoint3D<Real>::operator>= (const CXYPoint3D& rP) const$/;"	f	class:CXYPoint3D	signature:(const CXYPoint3D& rP) const
operator >=	XYVector.h	/^    bool operator>= (const CXYVector& rkV) const;$/;"	p	class:CXYVector	access:public	signature:(const CXYVector& rkV) const
operator >=	XYVector.inl	/^bool CXYVector<Real>::operator>= (const CXYVector& rkV) const$/;"	f	class:CXYVector	signature:(const CXYVector& rkV) const
operator >>	ConfigFile.cpp	/^std::istream& operator>>( std::istream& is, ConfigFile& cf )$/;"	f	signature:( std::istream& is, ConfigFile& cf )
operator >>	ConfigFile.h	/^	friend std::istream& operator>>( std::istream& is, ConfigFile& cf );$/;"	p	class:ConfigFile	access:friend	signature:( std::istream& is, ConfigFile& cf )
operator >>	MersenneTwister.h	/^	friend std::istream& operator>>( std::istream& is, MTRand& mtrand );$/;"	p	class:MTRand	access:friend	signature:( std::istream& is, MTRand& mtrand )
operator >>	MersenneTwister.h	/^inline std::istream& operator>>( std::istream& is, MTRand& mtrand )$/;"	f	signature:( std::istream& is, MTRand& mtrand )
operator Real*	XYMatrix.h	/^    operator Real* ();$/;"	p	class:CXYMatrix	access:public	signature:()
operator Real*	XYMatrix.inl	/^CXYMatrix<Real>::operator Real* ()$/;"	f	class:CXYMatrix	signature:()
operator Real*	XYPoint3D.h	/^	operator Real* ();$/;"	p	class:CXYPoint3D	access:public	signature:()
operator Real*	XYPoint3D.inl	/^CXYPoint3D<Real>::operator Real* ()$/;"	f	class:CXYPoint3D	signature:()
operator Real*	XYVector.h	/^    operator Real* ();$/;"	p	class:CXYVector	access:public	signature:()
operator Real*	XYVector.inl	/^CXYVector<Real>::operator Real* ()$/;"	f	class:CXYVector	signature:()
operator []	XYMatrix.h	/^    Real* operator[] (int iRow);$/;"	p	class:CXYMatrix	access:public	signature:(int iRow)
operator []	XYMatrix.h	/^    const Real* operator[] (int iRow) const;$/;"	p	class:CXYMatrix	access:public	signature:(int iRow) const
operator []	XYMatrix.inl	/^Real* CXYMatrix<Real>::operator[] (int iRow)$/;"	f	class:CXYMatrix	signature:(int iRow)
operator []	XYMatrix.inl	/^const Real* CXYMatrix<Real>::operator[] (int iRow) const$/;"	f	class:CXYMatrix	signature:(int iRow) const
operator []	XYPDB.cpp	/^CXYPDBAtom* CXYPDB::operator[] (int iInd)$/;"	f	class:CXYPDB	signature:(int iInd)
operator []	XYPDB.cpp	/^const CXYPDBAtom* CXYPDB::operator[] (int iInd) const$/;"	f	class:CXYPDB	signature:(int iInd) const
operator []	XYPDB.h	/^	CXYPDBAtom* operator[] (int iInd);$/;"	p	class:CXYPDB	access:public	signature:(int iInd)
operator []	XYPDB.h	/^	const CXYPDBAtom* operator[] (int iInd) const;$/;"	p	class:CXYPDB	access:public	signature:(int iInd) const
operator []	XYPoint3D.h	/^	Real operator[] (int i) const;$/;"	p	class:CXYPoint3D	access:public	signature:(int i) const
operator []	XYPoint3D.h	/^	Real& operator[] (int i);$/;"	p	class:CXYPoint3D	access:public	signature:(int i)
operator []	XYPoint3D.inl	/^Real CXYPoint3D<Real>::operator[] (int i) const$/;"	f	class:CXYPoint3D	signature:(int i) const
operator []	XYPoint3D.inl	/^Real& CXYPoint3D<Real>::operator[] (int i)$/;"	f	class:CXYPoint3D	signature:(int i)
operator []	XYVector.h	/^    Real operator[] (int i) const;$/;"	p	class:CXYVector	access:public	signature:(int i) const
operator []	XYVector.h	/^    Real& operator[] (int i);$/;"	p	class:CXYVector	access:public	signature:(int i)
operator []	XYVector.inl	/^Real CXYVector<Real>::operator[] (int i) const$/;"	f	class:CXYVector	signature:(int i) const
operator []	XYVector.inl	/^Real& CXYVector<Real>::operator[] (int i)$/;"	f	class:CXYVector	signature:(int i)
operator const Real*	XYMatrix.h	/^	operator const Real* () const;$/;"	p	class:CXYMatrix	access:public	signature:() const
operator const Real*	XYMatrix.inl	/^CXYMatrix<Real>::operator const Real* () const$/;"	f	class:CXYMatrix	signature:() const
operator const Real*	XYPoint3D.h	/^	operator const Real* () const;$/;"	p	class:CXYPoint3D	access:public	signature:() const
operator const Real*	XYPoint3D.inl	/^CXYPoint3D<Real>::operator const Real* () const$/;"	f	class:CXYPoint3D	signature:() const
operator const Real*	XYVector.h	/^    operator const Real* () const;$/;"	p	class:CXYVector	access:public	signature:() const
operator const Real*	XYVector.inl	/^CXYVector<Real>::operator const Real* () const$/;"	f	class:CXYVector	signature:() const
overlap	octree.h	/^    inline bool overlap( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition )
overlap	octree.hpp	/^inline bool spatialaggregate::OcTreeNode< CoordType, ValueType >::overlap( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition )
pNext	MersenneTwister.h	/^	uint32 *pNext;     \/\/ next value to get from state$/;"	m	class:MTRand	access:protected
parent	tree.hh	/^		template<typename	iter> static iter parent(iter);$/;"	p	class:tree	access:public	signature:(iter)
parent	tree.hh	/^		tree_node_<T> *parent;$/;"	m	class:tree_node_	access:public
parent	tree.hh	/^iter tree<T, tree_node_allocator>::parent(iter position) $/;"	f	class:tree	signature:(iter position)
parent_	octree.h	/^    OcTreeNode< CoordType, ValueType >* parent_;$/;"	m	class:spatialaggregate::OcTreeNode	access:public
parent_	tree.hh	/^				tree_node *parent_;$/;"	m	class:tree::sibling_iterator	access:public
parent_neighbor_	octree.h	/^    uint32_t parent_neighbor_[8][27];$/;"	m	class:spatialaggregate::OcTree	access:public
phi	XYSO3Sequence.h	/^	double phi;		\/\/ yaw$/;"	m	struct:EulerAngle	access:public
pix2ang_nest	XYSO3Sequence.cpp	/^void CXYSO3Sequence::pix2ang_nest(long nside, long ipix, double *theta, double *phi){$/;"	f	class:CXYSO3Sequence	signature:(long nside, long ipix, double *theta, double *phi)
pix2ang_nest	XYSO3Sequence.h	/^	void pix2ang_nest(long nside, long ipix, double *theta, double *phi);$/;"	p	class:CXYSO3Sequence	access:public	signature:(long nside, long ipix, double *theta, double *phi)
point_	XYPoint3D.h	/^	Real point_[3];$/;"	m	class:CXYPoint3D	access:private
pointer	tree.hh	/^				typedef T*                              pointer;$/;"	t	class:tree::iterator_base	access:public
pool_	octree.h	/^    Pool pool_;$/;"	m	class:spatialaggregate::DynamicAllocator	access:public
pool_iterator_	octree.h	/^    PoolIterator pool_iterator_;$/;"	m	class:spatialaggregate::DynamicAllocator	access:public
pos_key_	octree.h	/^    OcTreeKey< CoordType, ValueType > pos_key_, min_key_, max_key_;$/;"	m	class:spatialaggregate::OcTreeNode	access:public
position_normalizer_	octree.h	/^    Eigen::Matrix< CoordType, 4, 1 > min_position_, position_normalizer_, inv_position_normalizer_;$/;"	m	class:spatialaggregate::OcTree	access:public
post_order_iterator	tree.hh	/^				post_order_iterator();$/;"	p	class:tree::post_order_iterator	access:public	signature:()
post_order_iterator	tree.hh	/^				post_order_iterator(const iterator_base&);$/;"	p	class:tree::post_order_iterator	access:public	signature:(const iterator_base&)
post_order_iterator	tree.hh	/^				post_order_iterator(const sibling_iterator&);$/;"	p	class:tree::post_order_iterator	access:public	signature:(const sibling_iterator&)
post_order_iterator	tree.hh	/^				post_order_iterator(tree_node *);$/;"	p	class:tree::post_order_iterator	access:public	signature:(tree_node *)
post_order_iterator	tree.hh	/^		class post_order_iterator : public iterator_base {$/;"	c	class:tree	inherits:iterator_base	access:public
post_order_iterator	tree.hh	/^		class post_order_iterator;$/;"	x
post_order_iterator	tree.hh	/^tree<T, tree_node_allocator>::post_order_iterator::post_order_iterator() $/;"	f	class:tree::post_order_iterator	signature:()
post_order_iterator	tree.hh	/^tree<T, tree_node_allocator>::post_order_iterator::post_order_iterator(const iterator_base &other)$/;"	f	class:tree::post_order_iterator	signature:(const iterator_base &other)
post_order_iterator	tree.hh	/^tree<T, tree_node_allocator>::post_order_iterator::post_order_iterator(const sibling_iterator& other)$/;"	f	class:tree::post_order_iterator	signature:(const sibling_iterator& other)
post_order_iterator	tree.hh	/^tree<T, tree_node_allocator>::post_order_iterator::post_order_iterator(tree_node *tn)$/;"	f	class:tree::post_order_iterator	signature:(tree_node *tn)
pre_order_iterator	tree.hh	/^				pre_order_iterator();$/;"	p	class:tree::pre_order_iterator	access:public	signature:()
pre_order_iterator	tree.hh	/^				pre_order_iterator(const iterator_base&);$/;"	p	class:tree::pre_order_iterator	access:public	signature:(const iterator_base&)
pre_order_iterator	tree.hh	/^				pre_order_iterator(const sibling_iterator&);$/;"	p	class:tree::pre_order_iterator	access:public	signature:(const sibling_iterator&)
pre_order_iterator	tree.hh	/^				pre_order_iterator(tree_node *);$/;"	p	class:tree::pre_order_iterator	access:public	signature:(tree_node *)
pre_order_iterator	tree.hh	/^		class pre_order_iterator : public iterator_base { $/;"	c	class:tree	inherits:iterator_base	access:public
pre_order_iterator	tree.hh	/^		class pre_order_iterator;$/;"	x
pre_order_iterator	tree.hh	/^tree<T, tree_node_allocator>::pre_order_iterator::pre_order_iterator() $/;"	f	class:tree::pre_order_iterator	signature:()
pre_order_iterator	tree.hh	/^tree<T, tree_node_allocator>::pre_order_iterator::pre_order_iterator(const iterator_base &other)$/;"	f	class:tree::pre_order_iterator	signature:(const iterator_base &other)
pre_order_iterator	tree.hh	/^tree<T, tree_node_allocator>::pre_order_iterator::pre_order_iterator(const sibling_iterator& other)$/;"	f	class:tree::pre_order_iterator	signature:(const sibling_iterator& other)
pre_order_iterator	tree.hh	/^tree<T, tree_node_allocator>::pre_order_iterator::pre_order_iterator(tree_node *tn)$/;"	f	class:tree::pre_order_iterator	signature:(tree_node *tn)
prepend_child	tree.hh	/^		template<typename iter> iter prepend_child(iter position); $/;"	p	class:tree	access:public	signature:(iter position)
prepend_child	tree.hh	/^		template<typename iter> iter prepend_child(iter position, const T& x);$/;"	p	class:tree	access:public	signature:(iter position, const T& x)
prepend_child	tree.hh	/^		template<typename iter> iter prepend_child(iter position, iter other_position);$/;"	p	class:tree	access:public	signature:(iter position, iter other_position)
prepend_child	tree.hh	/^iter tree<T, tree_node_allocator>::prepend_child(iter position)$/;"	f	class:tree	signature:(iter position)
prepend_child	tree.hh	/^iter tree<T, tree_node_allocator>::prepend_child(iter position, const T& x)$/;"	f	class:tree	signature:(iter position, const T& x)
prepend_child	tree.hh	/^iter tree<T, tree_node_allocator>::prepend_child(iter position, iter other)$/;"	f	class:tree	signature:(iter position, iter other)
prepend_children	tree.hh	/^		template<typename iter> iter prepend_children(iter position, sibling_iterator from, sibling_iterator to);$/;"	p	class:tree	access:public	signature:(iter position, sibling_iterator from, sibling_iterator to)
prepend_children	tree.hh	/^iter tree<T, tree_node_allocator>::prepend_children(iter position, sibling_iterator from, sibling_iterator to)$/;"	f	class:tree	signature:(iter position, sibling_iterator from, sibling_iterator to)
prev_sibling	tree.hh	/^		tree_node_<T> *prev_sibling, *next_sibling;$/;"	m	class:tree_node_	access:public
previous_sibling	tree.hh	/^		template<typename iter> iter previous_sibling(iter) const;$/;"	p	class:tree	access:public	signature:(iter) const
previous_sibling	tree.hh	/^iter tree<T, tree_node_allocator>::previous_sibling(iter position) const$/;"	f	class:tree	signature:(iter position) const
printSO3Sequence	XYSO3Sequence.cpp	/^void CXYSO3Sequence::printSO3Sequence(){$/;"	f	class:CXYSO3Sequence	signature:()
printSO3Sequence	XYSO3Sequence.h	/^	void printSO3Sequence();$/;"	p	class:CXYSO3Sequence	access:public	signature:()
print_subtree_bracketed	tree_util.hh	/^void print_subtree_bracketed(const tree<T>& t, typename tree<T>::iterator iRoot, $/;"	p	namespace:kptree	signature:(const tree<T>& t, typename tree<T>::iterator iRoot, std::ostream& str=std::cout)
print_subtree_bracketed	tree_util.hh	/^void print_subtree_bracketed(const tree<T>& t, typename tree<T>::iterator iRoot, std::ostream& str) $/;"	f	namespace:kptree	signature:(const tree<T>& t, typename tree<T>::iterator iRoot, std::ostream& str)
print_tree_bracketed	tree_util.hh	/^void print_tree_bracketed(const tree<T>& t, std::ostream& str) $/;"	f	namespace:kptree	signature:(const tree<T>& t, std::ostream& str)
print_tree_bracketed	tree_util.hh	/^void print_tree_bracketed(const tree<T>& t, std::ostream& str=std::cout);$/;"	p	namespace:kptree	signature:(const tree<T>& t, std::ostream& str=std::cout)
psi	XYSO3Sequence.h	/^	double psi;		\/\/ roll$/;"	m	struct:EulerAngle	access:public
quat2vector	XYSO3Sequence.h	/^	void quat2vector(Quaternion quat, double oldpoint_xyz[], double newpoint_xyz[]);$/;"	p	class:CXYSO3Sequence	access:public	signature:(Quaternion quat, double oldpoint_xyz[], double newpoint_xyz[])
rand	MersenneTwister.h	/^	double rand( const double n );        \/\/ real number in [0,n]$/;"	p	class:MTRand	access:public	signature:( const double n )
rand	MersenneTwister.h	/^	double rand();                        \/\/ real number in [0,1]$/;"	p	class:MTRand	access:public	signature:()
rand	MersenneTwister.h	/^inline double MTRand::rand( const double n )$/;"	f	class:MTRand	signature:( const double n )
rand	MersenneTwister.h	/^inline double MTRand::rand()$/;"	f	class:MTRand	signature:()
rand53	MersenneTwister.h	/^	double rand53();  \/\/ real number in [0,1)$/;"	p	class:MTRand	access:public	signature:()
rand53	MersenneTwister.h	/^inline double MTRand::rand53()$/;"	f	class:MTRand	signature:()
randDblExc	MersenneTwister.h	/^	double randDblExc( const double n );  \/\/ real number in (0,n)$/;"	p	class:MTRand	access:public	signature:( const double n )
randDblExc	MersenneTwister.h	/^	double randDblExc();                  \/\/ real number in (0,1)$/;"	p	class:MTRand	access:public	signature:()
randDblExc	MersenneTwister.h	/^inline double MTRand::randDblExc( const double n )$/;"	f	class:MTRand	signature:( const double n )
randDblExc	MersenneTwister.h	/^inline double MTRand::randDblExc()$/;"	f	class:MTRand	signature:()
randExc	MersenneTwister.h	/^	double randExc( const double n );     \/\/ real number in [0,n)$/;"	p	class:MTRand	access:public	signature:( const double n )
randExc	MersenneTwister.h	/^	double randExc();                     \/\/ real number in [0,1)$/;"	p	class:MTRand	access:public	signature:()
randExc	MersenneTwister.h	/^inline double MTRand::randExc( const double n )$/;"	f	class:MTRand	signature:( const double n )
randExc	MersenneTwister.h	/^inline double MTRand::randExc()$/;"	f	class:MTRand	signature:()
randInt	MersenneTwister.h	/^	uint32 randInt( const uint32 n );     \/\/ integer in [0,n] for n < 2^32$/;"	p	class:MTRand	access:public	signature:( const uint32 n )
randInt	MersenneTwister.h	/^	uint32 randInt();                     \/\/ integer in [0,2^32-1]$/;"	p	class:MTRand	access:public	signature:()
randInt	MersenneTwister.h	/^inline MTRand::uint32 MTRand::randInt( const uint32 n )$/;"	f	class:MTRand	signature:( const uint32 n )
randInt	MersenneTwister.h	/^inline MTRand::uint32 MTRand::randInt()$/;"	f	class:MTRand	signature:()
randNorm	MersenneTwister.h	/^	double randNorm( const double mean = 0.0, const double stddev = 1.0 );$/;"	p	class:MTRand	access:public	signature:( const double mean = 0.0, const double stddev = 1.0 )
randNorm	MersenneTwister.h	/^inline double MTRand::randNorm( const double mean, const double stddev )$/;"	f	class:MTRand	signature:( const double mean, const double stddev )
range_first	tree.hh	/^				tree_node *range_first() const;$/;"	p	class:tree::sibling_iterator	access:public	signature:() const
range_first	tree.hh	/^typename tree<T, tree_node_allocator>::tree_node *tree<T, tree_node_allocator>::sibling_iterator::range_first() const$/;"	f	class:tree::sibling_iterator	signature:() const
range_last	tree.hh	/^				tree_node *range_last() const;$/;"	p	class:tree::sibling_iterator	access:public	signature:() const
range_last	tree.hh	/^typename tree<T, tree_node_allocator>::tree_node *tree<T, tree_node_allocator>::sibling_iterator::range_last() const$/;"	f	class:tree::sibling_iterator	signature:() const
read	ConfigFile.h	/^	template<class T> T read( const string& key ) const;  \/\/ call as read<T>$/;"	p	class:ConfigFile	access:public	signature:( const string& key ) const
read	ConfigFile.h	/^	template<class T> T read( const string& key, const T& value ) const;$/;"	p	class:ConfigFile	access:public	signature:( const string& key, const T& value ) const
read	ConfigFile.h	/^T ConfigFile::read( const string& key ) const$/;"	f	class:ConfigFile	signature:( const string& key ) const
read	ConfigFile.h	/^T ConfigFile::read( const string& key, const T& value ) const$/;"	f	class:ConfigFile	signature:( const string& key, const T& value ) const
readInto	ConfigFile.h	/^	bool readInto( T& var, const string& key, const T& value ) const;$/;"	p	class:ConfigFile	access:public	signature:( T& var, const string& key, const T& value ) const
readInto	ConfigFile.h	/^	template<class T> bool readInto( T& var, const string& key ) const;$/;"	p	class:ConfigFile	access:public	signature:( T& var, const string& key ) const
readInto	ConfigFile.h	/^bool ConfigFile::readInto( T& var, const string& key ) const$/;"	f	class:ConfigFile	signature:( T& var, const string& key ) const
readInto	ConfigFile.h	/^bool ConfigFile::readInto( T& var, const string& key, const T& value ) const$/;"	f	class:ConfigFile	signature:( T& var, const string& key, const T& value ) const
reduce1By2	octree.h	/^    inline uint64_t reduce1By2( uint64_t x );$/;"	p	class:spatialaggregate::OcTreeKey	access:public	signature:( uint64_t x )
reduce1By2	octree.hpp	/^inline uint64_t spatialaggregate::OcTreeKey< CoordType, ValueType >::reduce1By2( uint64_t x ) {$/;"	f	class:spatialaggregate::OcTreeKey	signature:( uint64_t x )
reference	tree.hh	/^				typedef T&                              reference;$/;"	t	class:tree::iterator_base	access:public
regionContained	octree.h	/^    inline bool regionContained( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition )
regionContained	octree.hpp	/^inline bool spatialaggregate::OcTreeNode< CoordType, ValueType >::regionContained( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition )
reload	MersenneTwister.h	/^	void reload();$/;"	p	class:MTRand	access:protected	signature:()
reload	MersenneTwister.h	/^inline void MTRand::reload()$/;"	f	class:MTRand	signature:()
remove	ConfigFile.cpp	/^void ConfigFile::remove( const string& key )$/;"	f	class:ConfigFile	signature:( const string& key )
remove	ConfigFile.h	/^	void remove( const string& key );$/;"	p	class:ConfigFile	access:public	signature:( const string& key )
reparent	tree.hh	/^		template<typename iter> iter reparent(iter position, iter from);$/;"	p	class:tree	access:public	signature:(iter position, iter from)
reparent	tree.hh	/^		template<typename iter> iter reparent(iter position, sibling_iterator begin, sibling_iterator end);$/;"	p	class:tree	access:public	signature:(iter position, sibling_iterator begin, sibling_iterator end)
reparent	tree.hh	/^iter tree<T, tree_node_allocator>::reparent(iter position, sibling_iterator begin, sibling_iterator end)$/;"	f	class:tree	signature:(iter position, sibling_iterator begin, sibling_iterator end)
reparent	tree.hh	/^template <typename iter> iter tree<T, tree_node_allocator>::reparent(iter position, iter from)$/;"	f	class:tree	signature:(iter position, iter from)
replace	tree.hh	/^		sibling_iterator replace(sibling_iterator orig_begin, sibling_iterator orig_end, $/;"	p	class:tree	access:public	signature:(sibling_iterator orig_begin, sibling_iterator orig_end, sibling_iterator new_begin, sibling_iterator new_end)
replace	tree.hh	/^		template<typename iter> iter replace(iter position, const T& x);$/;"	p	class:tree	access:public	signature:(iter position, const T& x)
replace	tree.hh	/^		template<typename iter> iter replace(iter position, const iterator_base& from);$/;"	p	class:tree	access:public	signature:(iter position, const iterator_base& from)
replace	tree.hh	/^iter tree<T, tree_node_allocator>::replace(iter position, const T& x)$/;"	f	class:tree	signature:(iter position, const T& x)
replace	tree.hh	/^iter tree<T, tree_node_allocator>::replace(iter position, const iterator_base& from)$/;"	f	class:tree	signature:(iter position, const iterator_base& from)
replace	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::replace($/;"	f	class:tree	signature:( sibling_iterator orig_begin, sibling_iterator orig_end, sibling_iterator new_begin, sibling_iterator new_end)
reset	octree.h	/^    inline virtual void reset() {$/;"	f	class:spatialaggregate::OcTreeNodeDynamicAllocator	access:public	signature:()
reset	octree.h	/^    inline virtual void reset() {$/;"	f	class:spatialaggregate::OcTreeNodeFixedCountAllocator	access:public	signature:()
reset	octree.h	/^    inline virtual void reset() {}$/;"	f	class:spatialaggregate::OcTreeNodeAllocator	access:public	signature:()
reset	octree.h	/^    void reset() {$/;"	f	class:spatialaggregate::DynamicAllocator	access:public	signature:()
resolution	octree.h	/^    inline CoordType resolution();$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:()
resolution	octree.hpp	/^inline CoordType spatialaggregate::OcTreeNode< CoordType, ValueType >::resolution() {$/;"	f	class:spatialaggregate::OcTreeNode	signature:()
resolutions_	octree.h	/^    float resolutions_[MAX_REPRESENTABLE_DEPTH+1];$/;"	m	class:spatialaggregate::OcTree	access:public
root_	octree.h	/^    OcTreeNode< CoordType, ValueType >* root_;$/;"	m	class:spatialaggregate::OcTree	access:public
save	MersenneTwister.h	/^	void save( uint32* saveArray ) const;  \/\/ to array of size SAVE$/;"	p	class:MTRand	access:public	signature:( uint32* saveArray ) const
save	MersenneTwister.h	/^inline void MTRand::save( uint32* saveArray ) const$/;"	f	class:MTRand	signature:( uint32* saveArray ) const
scale_depth_table_	octree.h	/^    double scale_depth_table_[65536];$/;"	m	class:spatialaggregate::OcTree	access:public
second	XYUtility.h	/^	T2 second;$/;"	m	class:CXYTriple	access:public
seed	MersenneTwister.h	/^	void seed( const uint32 oneSeed );$/;"	p	class:MTRand	access:public	signature:( const uint32 oneSeed )
seed	MersenneTwister.h	/^	void seed( uint32 *const bigSeed, const uint32 seedLength = N );$/;"	p	class:MTRand	access:public	signature:( uint32 *const bigSeed, const uint32 seedLength = N )
seed	MersenneTwister.h	/^	void seed();$/;"	p	class:MTRand	access:public	signature:()
seed	MersenneTwister.h	/^inline void MTRand::seed( const uint32 oneSeed )$/;"	f	class:MTRand	signature:( const uint32 oneSeed )
seed	MersenneTwister.h	/^inline void MTRand::seed( uint32 *const bigSeed, const uint32 seedLength )$/;"	f	class:MTRand	signature:( uint32 *const bigSeed, const uint32 seedLength )
seed	MersenneTwister.h	/^inline void MTRand::seed()$/;"	f	class:MTRand	signature:()
setComment	ConfigFile.h	/^	string setComment( const string& s )$/;"	f	class:ConfigFile	access:public	signature:( const string& s )
setDelimiter	ConfigFile.h	/^	string setDelimiter( const string& s )$/;"	f	class:ConfigFile	access:public	signature:( const string& s )
setKey	octree.h	/^    inline void setKey( const CoordType& x, const CoordType& y, const CoordType& z, OcTree< CoordType, ValueType >* tree ) {$/;"	f	class:spatialaggregate::OcTreeKey	access:public	signature:( const CoordType& x, const CoordType& y, const CoordType& z, OcTree< CoordType, ValueType >* tree )
setKey	octree.h	/^    inline void setKey( const Eigen::Matrix< CoordType, 4, 1 >& position, OcTree< CoordType, ValueType >* tree );$/;"	p	class:spatialaggregate::OcTreeKey	access:public	signature:( const Eigen::Matrix< CoordType, 4, 1 >& position, OcTree< CoordType, ValueType >* tree )
setKey	octree.hpp	/^inline void spatialaggregate::OcTreeKey< CoordType, ValueType >::setKey( const Eigen::Matrix< CoordType, 4, 1 >& position, OcTree< CoordType, ValueType >* tree ) {$/;"	f	class:spatialaggregate::OcTreeKey	signature:( const Eigen::Matrix< CoordType, 4, 1 >& position, OcTree< CoordType, ValueType >* tree )
set_head	tree.hh	/^		pre_order_iterator set_head(const T& x);$/;"	p	class:tree	access:public	signature:(const T& x)
set_head	tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator tree<T, tree_node_allocator>::set_head(const T& x)$/;"	f	class:tree	signature:(const T& x)
set_parent_	tree.hh	/^				void set_parent_();$/;"	p	class:tree::sibling_iterator	access:private	signature:()
set_parent_	tree.hh	/^void tree<T, tree_node_allocator>::sibling_iterator::set_parent_()$/;"	f	class:tree::sibling_iterator	signature:()
sibling	tree.hh	/^		sibling_iterator sibling(const iterator_base& position, unsigned int);  				$/;"	p	class:tree	access:public	signature:(const iterator_base& position, unsigned int)
sibling	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::sibling(const iterator_base& it, unsigned int num)$/;"	f	class:tree	signature:(const iterator_base& it, unsigned int num)
sibling_iterator	tree.hh	/^				sibling_iterator();$/;"	p	class:tree::sibling_iterator	access:public	signature:()
sibling_iterator	tree.hh	/^				sibling_iterator(const iterator_base&);$/;"	p	class:tree::sibling_iterator	access:public	signature:(const iterator_base&)
sibling_iterator	tree.hh	/^				sibling_iterator(const sibling_iterator&);$/;"	p	class:tree::sibling_iterator	access:public	signature:(const sibling_iterator&)
sibling_iterator	tree.hh	/^				sibling_iterator(tree_node *);$/;"	p	class:tree::sibling_iterator	access:public	signature:(tree_node *)
sibling_iterator	tree.hh	/^		class sibling_iterator : public iterator_base {$/;"	c	class:tree	inherits:iterator_base	access:public
sibling_iterator	tree.hh	/^		class sibling_iterator;$/;"	x
sibling_iterator	tree.hh	/^tree<T, tree_node_allocator>::sibling_iterator::sibling_iterator() $/;"	f	class:tree::sibling_iterator	signature:()
sibling_iterator	tree.hh	/^tree<T, tree_node_allocator>::sibling_iterator::sibling_iterator(const iterator_base& other)$/;"	f	class:tree::sibling_iterator	signature:(const iterator_base& other)
sibling_iterator	tree.hh	/^tree<T, tree_node_allocator>::sibling_iterator::sibling_iterator(const sibling_iterator& other)$/;"	f	class:tree::sibling_iterator	signature:(const sibling_iterator& other)
sibling_iterator	tree.hh	/^tree<T, tree_node_allocator>::sibling_iterator::sibling_iterator(tree_node *tn)$/;"	f	class:tree::sibling_iterator	signature:(tree_node *tn)
size	tree.hh	/^		size_t   size() const;$/;"	p	class:tree	access:public	signature:() const
size	tree.hh	/^		size_t   size(const iterator_base&) const;$/;"	p	class:tree	access:public	signature:(const iterator_base&) const
size	tree.hh	/^size_t tree<T, tree_node_allocator>::size() const$/;"	f	class:tree	signature:() const
size	tree.hh	/^size_t tree<T, tree_node_allocator>::size(const iterator_base& top) const$/;"	f	class:tree	signature:(const iterator_base& top) const
size_type	tree.hh	/^				typedef size_t                          size_type;$/;"	t	class:tree::iterator_base	access:public
skip_children	tree.hh	/^				void         skip_children();$/;"	p	class:tree::iterator_base	access:public	signature:()
skip_children	tree.hh	/^				void         skip_children(bool skip);$/;"	p	class:tree::iterator_base	access:public	signature:(bool skip)
skip_children	tree.hh	/^void tree<T, tree_node_allocator>::iterator_base::skip_children()$/;"	f	class:tree::iterator_base	signature:()
skip_children	tree.hh	/^void tree<T, tree_node_allocator>::iterator_base::skip_children(bool skip)$/;"	f	class:tree::iterator_base	signature:(bool skip)
skip_current_children_	tree.hh	/^				bool skip_current_children_;$/;"	m	class:tree::iterator_base	access:protected
sort	tree.hh	/^		void     sort(sibling_iterator from, sibling_iterator to, StrictWeakOrdering comp, bool deep=false);$/;"	p	class:tree	access:public	signature:(sibling_iterator from, sibling_iterator to, StrictWeakOrdering comp, bool deep=false)
sort	tree.hh	/^		void     sort(sibling_iterator from, sibling_iterator to, bool deep=false);$/;"	p	class:tree	access:public	signature:(sibling_iterator from, sibling_iterator to, bool deep=false)
sort	tree.hh	/^void tree<T, tree_node_allocator>::sort(sibling_iterator from, sibling_iterator to, $/;"	f	class:tree	signature:(sibling_iterator from, sibling_iterator to, StrictWeakOrdering comp, bool deep)
sort	tree.hh	/^void tree<T, tree_node_allocator>::sort(sibling_iterator from, sibling_iterator to, bool deep)$/;"	f	class:tree	signature:(sibling_iterator from, sibling_iterator to, bool deep)
sort_pair_first_greater	XYUtility.h	/^struct sort_pair_first_greater {$/;"	s
sort_pair_first_greater::operator ()	XYUtility.h	/^	bool operator()(const pair<T1,T2>&left, const pair<T1,T2>&right) {$/;"	f	struct:sort_pair_first_greater	access:public	signature:(const pair<T1,T2>&left, const pair<T1,T2>&right)
sort_pair_first_less	XYUtility.h	/^struct sort_pair_first_less {$/;"	s
sort_pair_first_less::operator ()	XYUtility.h	/^	bool operator()(const pair<T1,T2>&left, const pair<T1,T2>&right) {$/;"	f	struct:sort_pair_first_less	access:public	signature:(const pair<T1,T2>&left, const pair<T1,T2>&right)
spatialaggregate	octree.h	/^namespace spatialaggregate {$/;"	n
spatialaggregate::DynamicAllocator	octree.h	/^  class DynamicAllocator {$/;"	c	namespace:spatialaggregate
spatialaggregate::DynamicAllocator::DynamicAllocator	octree.h	/^    DynamicAllocator( int block_size ) {$/;"	f	class:spatialaggregate::DynamicAllocator	access:public	signature:( int block_size )
spatialaggregate::DynamicAllocator::Pool	octree.h	/^    typedef typename std::list< std::vector< T, Eigen::aligned_allocator< T > > > Pool;$/;"	t	class:spatialaggregate::DynamicAllocator	access:public
spatialaggregate::DynamicAllocator::PoolIterator	octree.h	/^    typedef typename std::list< std::vector< T, Eigen::aligned_allocator< T > > >::iterator PoolIterator;$/;"	t	class:spatialaggregate::DynamicAllocator	access:public
spatialaggregate::DynamicAllocator::allocate	octree.h	/^    T* allocate() {$/;"	f	class:spatialaggregate::DynamicAllocator	access:public	signature:()
spatialaggregate::DynamicAllocator::block_size_	octree.h	/^    int block_size_;$/;"	m	class:spatialaggregate::DynamicAllocator	access:public
spatialaggregate::DynamicAllocator::curr_idx_	octree.h	/^    int curr_idx_;$/;"	m	class:spatialaggregate::DynamicAllocator	access:public
spatialaggregate::DynamicAllocator::pool_	octree.h	/^    Pool pool_;$/;"	m	class:spatialaggregate::DynamicAllocator	access:public
spatialaggregate::DynamicAllocator::pool_iterator_	octree.h	/^    PoolIterator pool_iterator_;$/;"	m	class:spatialaggregate::DynamicAllocator	access:public
spatialaggregate::DynamicAllocator::reset	octree.h	/^    void reset() {$/;"	f	class:spatialaggregate::DynamicAllocator	access:public	signature:()
spatialaggregate::DynamicAllocator::~DynamicAllocator	octree.h	/^    ~DynamicAllocator() {$/;"	f	class:spatialaggregate::DynamicAllocator	access:public	signature:()
spatialaggregate::NUM_OCTREE_NODE_TYPES	octree.h	/^    NUM_OCTREE_NODE_TYPES,$/;"	e	enum:spatialaggregate::OcTreeNodeType
spatialaggregate::OCTREE_BRANCHING_NODE	octree.h	/^    OCTREE_BRANCHING_NODE,$/;"	e	enum:spatialaggregate::OcTreeNodeType
spatialaggregate::OCTREE_LEAF_NODE	octree.h	/^    OCTREE_LEAF_NODE,$/;"	e	enum:spatialaggregate::OcTreeNodeType
spatialaggregate::OcTree	octree.h	/^  class OcTree {$/;"	c	namespace:spatialaggregate
spatialaggregate::OcTree	octree.h	/^  template< typename CoordType, typename ValueType > class OcTree;$/;"	x
spatialaggregate::OcTree::EIGEN_MAKE_ALIGNED_OPERATOR_NEW	octree.h	/^        EIGEN_MAKE_ALIGNED_OPERATOR_NEW;$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::OcTree	octree.h	/^		OcTree( const Eigen::Matrix< CoordType, 4, 1 >& center, CoordType minimumVolumeSize, CoordType maxDistance, boost::shared_ptr< OcTreeNodeAllocator< CoordType, ValueType > > allocator );$/;"	p	class:spatialaggregate::OcTree	access:public	signature:( const Eigen::Matrix< CoordType, 4, 1 >& center, CoordType minimumVolumeSize, CoordType maxDistance, boost::shared_ptr< OcTreeNodeAllocator< CoordType, ValueType > > allocator )
spatialaggregate::OcTree::OcTree	octree.hpp	/^spatialaggregate::OcTree< CoordType, ValueType >::OcTree( const Eigen::Matrix< CoordType, 4, 1 >& center, CoordType minimumVolumeSize, CoordType maxDistance, boost::shared_ptr< spatialaggregate::OcTreeNodeAllocator< CoordType, ValueType > > allocator ) {$/;"	f	class:spatialaggregate::OcTree	signature:( const Eigen::Matrix< CoordType, 4, 1 >& center, CoordType minimumVolumeSize, CoordType maxDistance, boost::shared_ptr< spatialaggregate::OcTreeNodeAllocator< CoordType, ValueType > > allocator )
spatialaggregate::OcTree::acquire	octree.h	/^    inline void acquire( OcTreeNode< CoordType, ValueType >* node ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( OcTreeNode< CoordType, ValueType >* node )
spatialaggregate::OcTree::addPoint	octree.h	/^    inline OcTreeNode< CoordType, ValueType >* addPoint( const CoordType& x, const CoordType& y, const CoordType& z, const ValueType& value, int maxDepth ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( const CoordType& x, const CoordType& y, const CoordType& z, const ValueType& value, int maxDepth )
spatialaggregate::OcTree::addPoint	octree.h	/^    inline OcTreeNode< CoordType, ValueType >* addPoint( const Eigen::Matrix< CoordType, 4, 1 >& position, const ValueType& value, int maxDepth ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( const Eigen::Matrix< CoordType, 4, 1 >& position, const ValueType& value, int maxDepth )
spatialaggregate::OcTree::allocator_	octree.h	/^    boost::shared_ptr< OcTreeNodeAllocator< CoordType, ValueType > > allocator_;$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::depthForVolumeSize	octree.h	/^    inline double depthForVolumeSize( CoordType volumeSize ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( CoordType volumeSize )
spatialaggregate::OcTree::depth_masks_	octree.h	/^    uint32_t depth_masks_[MAX_REPRESENTABLE_DEPTH+1];$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::findRepresentative	octree.h	/^    inline OcTreeNode< CoordType, ValueType >* findRepresentative( const Eigen::Matrix< CoordType, 4, 1 >& position, int maxDepth ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( const Eigen::Matrix< CoordType, 4, 1 >& position, int maxDepth )
spatialaggregate::OcTree::getAllNodesInVolumeOnDepth	octree.h	/^    inline void getAllNodesInVolumeOnDepth( std::list< OcTreeNode< CoordType, ValueType >* >& nodes, const Eigen::Matrix< CoordType, 4, 1 >& minPosition, const Eigen::Matrix< CoordType, 4, 1 >& maxPosition, int depth, bool lowerDepthLeaves ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( std::list< OcTreeNode< CoordType, ValueType >* >& nodes, const Eigen::Matrix< CoordType, 4, 1 >& minPosition, const Eigen::Matrix< CoordType, 4, 1 >& maxPosition, int depth, bool lowerDepthLeaves )
spatialaggregate::OcTree::getAllNodesInVolumeOnDepth	octree.h	/^    inline void getAllNodesInVolumeOnDepth( std::vector< OcTreeNode< CoordType, ValueType >* >& nodes, const Eigen::Matrix< CoordType, 4, 1 >& minPosition, const Eigen::Matrix< CoordType, 4, 1 >& maxPosition, int depth, bool lowerDepthLeaves ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( std::vector< OcTreeNode< CoordType, ValueType >* >& nodes, const Eigen::Matrix< CoordType, 4, 1 >& minPosition, const Eigen::Matrix< CoordType, 4, 1 >& maxPosition, int depth, bool lowerDepthLeaves )
spatialaggregate::OcTree::getKey	octree.h	/^    inline OcTreeKey< CoordType, ValueType > getKey( const CoordType& x, const CoordType& y, const CoordType& z ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( const CoordType& x, const CoordType& y, const CoordType& z )
spatialaggregate::OcTree::getKey	octree.h	/^    inline OcTreeKey< CoordType, ValueType > getKey( const Eigen::Matrix< CoordType, 4, 1 >& position ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( const Eigen::Matrix< CoordType, 4, 1 >& position )
spatialaggregate::OcTree::initialize	octree.h	/^    inline void initialize( const Eigen::Matrix< CoordType, 4, 1 >& dimensions, const Eigen::Matrix< CoordType, 4, 1 >& center, CoordType minimumVolumeSize );$/;"	p	class:spatialaggregate::OcTree	access:public	signature:( const Eigen::Matrix< CoordType, 4, 1 >& dimensions, const Eigen::Matrix< CoordType, 4, 1 >& center, CoordType minimumVolumeSize )
spatialaggregate::OcTree::inv_minimum_volume_size_	octree.h	/^    CoordType minimum_volume_size_, inv_minimum_volume_size_;$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::inv_position_normalizer_	octree.h	/^    Eigen::Matrix< CoordType, 4, 1 > min_position_, position_normalizer_, inv_position_normalizer_;$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::inv_resolutions_	octree.h	/^    float inv_resolutions_[MAX_REPRESENTABLE_DEPTH+1];$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::log2_inv_	octree.h	/^    double log2_inv_;$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::log_minimum_volume_size_	octree.h	/^    double log_minimum_volume_size_;$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::maxResolutions_	octree.h	/^    float maxResolutions_[MAX_REPRESENTABLE_DEPTH+1];$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::maxVolumeSizeForDepth	octree.h	/^    inline CoordType maxVolumeSizeForDepth( int depth ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( int depth )
spatialaggregate::OcTree::max_depth_	octree.h	/^    int max_depth_;$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::maxmasks_	octree.h	/^    uint32_t maxmasks_[MAX_REPRESENTABLE_DEPTH+1];$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::minResolutions_	octree.h	/^    float minResolutions_[MAX_REPRESENTABLE_DEPTH+1];$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::minVolumeSizeForDepth	octree.h	/^    inline CoordType minVolumeSizeForDepth( int depth ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( int depth )
spatialaggregate::OcTree::min_position_	octree.h	/^    Eigen::Matrix< CoordType, 4, 1 > min_position_, position_normalizer_, inv_position_normalizer_;$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::minimum_volume_size_	octree.h	/^    CoordType minimum_volume_size_, inv_minimum_volume_size_;$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::minmasks_	octree.h	/^    uint32_t minmasks_[MAX_REPRESENTABLE_DEPTH+1];$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::neighbor_octant_	octree.h	/^    uint32_t neighbor_octant_[8][27];$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::neighborhood_m1_map_	octree.h	/^    uint32_t neighborhood_m1_map_[3];$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::neighborhood_p1_map_	octree.h	/^    uint32_t neighborhood_p1_map_[3];$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::parent_neighbor_	octree.h	/^    uint32_t parent_neighbor_[8][27];$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::position_normalizer_	octree.h	/^    Eigen::Matrix< CoordType, 4, 1 > min_position_, position_normalizer_, inv_position_normalizer_;$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::resolutions_	octree.h	/^    float resolutions_[MAX_REPRESENTABLE_DEPTH+1];$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::root_	octree.h	/^    OcTreeNode< CoordType, ValueType >* root_;$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::scale_depth_table_	octree.h	/^    double scale_depth_table_[65536];$/;"	m	class:spatialaggregate::OcTree	access:public
spatialaggregate::OcTree::volumeSizeForDepth	octree.h	/^    inline CoordType volumeSizeForDepth( int depth ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( int depth )
spatialaggregate::OcTree::~OcTree	octree.h	/^    ~OcTree();$/;"	p	class:spatialaggregate::OcTree	access:public	signature:()
spatialaggregate::OcTree::~OcTree	octree.hpp	/^spatialaggregate::OcTree< CoordType, ValueType >::~OcTree() {$/;"	f	class:spatialaggregate::OcTree	signature:()
spatialaggregate::OcTreeKey	octree.h	/^  class OcTreeKey {$/;"	c	namespace:spatialaggregate
spatialaggregate::OcTreeKey::EIGEN_MAKE_ALIGNED_OPERATOR_NEW	octree.h	/^        EIGEN_MAKE_ALIGNED_OPERATOR_NEW;$/;"	m	class:spatialaggregate::OcTreeKey	access:public
spatialaggregate::OcTreeKey::OcTreeKey	octree.h	/^    OcTreeKey( const CoordType& x, const CoordType& y, const CoordType& z, OcTree< CoordType, ValueType >* tree ) {$/;"	f	class:spatialaggregate::OcTreeKey	access:public	signature:( const CoordType& x, const CoordType& y, const CoordType& z, OcTree< CoordType, ValueType >* tree )
spatialaggregate::OcTreeKey::OcTreeKey	octree.h	/^    OcTreeKey( const Eigen::Matrix< CoordType, 4, 1 >& position, OcTree< CoordType, ValueType >* tree ) {$/;"	f	class:spatialaggregate::OcTreeKey	access:public	signature:( const Eigen::Matrix< CoordType, 4, 1 >& position, OcTree< CoordType, ValueType >* tree )
spatialaggregate::OcTreeKey::OcTreeKey	octree.h	/^    OcTreeKey( uint32_t x, uint32_t y, uint32_t z )$/;"	f	class:spatialaggregate::OcTreeKey	access:public	signature:( uint32_t x, uint32_t y, uint32_t z )
spatialaggregate::OcTreeKey::OcTreeKey	octree.h	/^    OcTreeKey() {}$/;"	f	class:spatialaggregate::OcTreeKey	access:public	signature:()
spatialaggregate::OcTreeKey::decodeMorton48	octree.h	/^    inline void decodeMorton48( uint64_t key, uint64_t& x, uint64_t& y, uint64_t& z );$/;"	p	class:spatialaggregate::OcTreeKey	access:public	signature:( uint64_t key, uint64_t& x, uint64_t& y, uint64_t& z )
spatialaggregate::OcTreeKey::decodeMorton48	octree.hpp	/^inline void spatialaggregate::OcTreeKey< CoordType, ValueType >::decodeMorton48( uint64_t key, uint64_t& x, uint64_t& y, uint64_t& z ) {$/;"	f	class:spatialaggregate::OcTreeKey	signature:( uint64_t key, uint64_t& x, uint64_t& y, uint64_t& z )
spatialaggregate::OcTreeKey::dilate1By2	octree.h	/^    inline uint64_t dilate1By2( uint64_t x );$/;"	p	class:spatialaggregate::OcTreeKey	access:public	signature:( uint64_t x )
spatialaggregate::OcTreeKey::dilate1By2	octree.hpp	/^inline uint64_t spatialaggregate::OcTreeKey< CoordType, ValueType >::dilate1By2( uint64_t x ) {$/;"	f	class:spatialaggregate::OcTreeKey	signature:( uint64_t x )
spatialaggregate::OcTreeKey::encodeMorton48	octree.h	/^    inline uint64_t encodeMorton48( uint64_t x, uint64_t y, uint64_t z );$/;"	p	class:spatialaggregate::OcTreeKey	access:public	signature:( uint64_t x, uint64_t y, uint64_t z )
spatialaggregate::OcTreeKey::encodeMorton48	octree.hpp	/^inline uint64_t spatialaggregate::OcTreeKey< CoordType, ValueType >::encodeMorton48( uint64_t x, uint64_t y, uint64_t z ) {$/;"	f	class:spatialaggregate::OcTreeKey	signature:( uint64_t x, uint64_t y, uint64_t z )
spatialaggregate::OcTreeKey::getPosition	octree.h	/^    inline Eigen::Matrix< CoordType, 4, 1 > getPosition( OcTree< CoordType, ValueType >* tree ) const;$/;"	p	class:spatialaggregate::OcTreeKey	access:public	signature:( OcTree< CoordType, ValueType >* tree ) const
spatialaggregate::OcTreeKey::getPosition	octree.hpp	/^inline Eigen::Matrix< CoordType, 4, 1 > spatialaggregate::OcTreeKey< CoordType, ValueType >::getPosition( OcTree< CoordType, ValueType >* tree ) const {$/;"	f	class:spatialaggregate::OcTreeKey	signature:( OcTree< CoordType, ValueType >* tree ) const
spatialaggregate::OcTreeKey::operator ==	octree.h	/^    inline bool operator==(const OcTreeKey &rhs) {$/;"	f	class:spatialaggregate::OcTreeKey	access:public	signature:(const OcTreeKey &rhs)
spatialaggregate::OcTreeKey::reduce1By2	octree.h	/^    inline uint64_t reduce1By2( uint64_t x );$/;"	p	class:spatialaggregate::OcTreeKey	access:public	signature:( uint64_t x )
spatialaggregate::OcTreeKey::reduce1By2	octree.hpp	/^inline uint64_t spatialaggregate::OcTreeKey< CoordType, ValueType >::reduce1By2( uint64_t x ) {$/;"	f	class:spatialaggregate::OcTreeKey	signature:( uint64_t x )
spatialaggregate::OcTreeKey::setKey	octree.h	/^    inline void setKey( const CoordType& x, const CoordType& y, const CoordType& z, OcTree< CoordType, ValueType >* tree ) {$/;"	f	class:spatialaggregate::OcTreeKey	access:public	signature:( const CoordType& x, const CoordType& y, const CoordType& z, OcTree< CoordType, ValueType >* tree )
spatialaggregate::OcTreeKey::setKey	octree.h	/^    inline void setKey( const Eigen::Matrix< CoordType, 4, 1 >& position, OcTree< CoordType, ValueType >* tree );$/;"	p	class:spatialaggregate::OcTreeKey	access:public	signature:( const Eigen::Matrix< CoordType, 4, 1 >& position, OcTree< CoordType, ValueType >* tree )
spatialaggregate::OcTreeKey::setKey	octree.hpp	/^inline void spatialaggregate::OcTreeKey< CoordType, ValueType >::setKey( const Eigen::Matrix< CoordType, 4, 1 >& position, OcTree< CoordType, ValueType >* tree ) {$/;"	f	class:spatialaggregate::OcTreeKey	signature:( const Eigen::Matrix< CoordType, 4, 1 >& position, OcTree< CoordType, ValueType >* tree )
spatialaggregate::OcTreeKey::x_	octree.h	/^    uint32_t x_, y_, z_;$/;"	m	class:spatialaggregate::OcTreeKey	access:public
spatialaggregate::OcTreeKey::y_	octree.h	/^    uint32_t x_, y_, z_;$/;"	m	class:spatialaggregate::OcTreeKey	access:public
spatialaggregate::OcTreeKey::z_	octree.h	/^    uint32_t x_, y_, z_;$/;"	m	class:spatialaggregate::OcTreeKey	access:public
spatialaggregate::OcTreeKey::~OcTreeKey	octree.h	/^    ~OcTreeKey() {}$/;"	f	class:spatialaggregate::OcTreeKey	access:public	signature:()
spatialaggregate::OcTreeNode	octree.h	/^  class OcTreeNode {$/;"	c	namespace:spatialaggregate
spatialaggregate::OcTreeNode::EIGEN_MAKE_ALIGNED_OPERATOR_NEW	octree.h	/^        EIGEN_MAKE_ALIGNED_OPERATOR_NEW;$/;"	m	class:spatialaggregate::OcTreeNode	access:public
spatialaggregate::OcTreeNode::OcTreeNode	octree.h	/^    OcTreeNode( OcTreeNodeType type ) { $/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:( OcTreeNodeType type )
spatialaggregate::OcTreeNode::OcTreeNode	octree.h	/^    OcTreeNode( OcTreeNodeType type, boost::shared_ptr< OcTree< CoordType, ValueType > > tree ) {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:( OcTreeNodeType type, boost::shared_ptr< OcTree< CoordType, ValueType > > tree )
spatialaggregate::OcTreeNode::OcTreeNode	octree.h	/^    OcTreeNode() { $/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:()
spatialaggregate::OcTreeNode::addPoint	octree.h	/^    inline OcTreeNode< CoordType, ValueType >* addPoint( const OcTreeKey< CoordType, ValueType >& position, const ValueType& value, int maxDepth );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& position, const ValueType& value, int maxDepth )
spatialaggregate::OcTreeNode::addPoint	octree.hpp	/^inline spatialaggregate::OcTreeNode< CoordType, ValueType >* spatialaggregate::OcTreeNode< CoordType, ValueType >::addPoint( const OcTreeKey< CoordType, ValueType >& position, const ValueType& value, int maxDepth ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const OcTreeKey< CoordType, ValueType >& position, const ValueType& value, int maxDepth )
spatialaggregate::OcTreeNode::applyOperatorInVolume	octree.h	/^    inline void applyOperatorInVolume( ValueType& value, void* data, void (*f)( ValueType& v, OcTreeNode< CoordType, ValueType >* current, void* data ), const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( ValueType& value, void* data, void (*f)( ValueType& v, OcTreeNode< CoordType, ValueType >* current, void* data ), const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth )
spatialaggregate::OcTreeNode::applyOperatorInVolume	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::applyOperatorInVolume( ValueType& value, void* data, void (*f)( ValueType& v, spatialaggregate::OcTreeNode< CoordType, ValueType >* current, void* data ), const spatialaggregate::OcTreeKey< CoordType, ValueType >& minPosition, const spatialaggregate::OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( ValueType& value, void* data, void (*f)( ValueType& v, spatialaggregate::OcTreeNode< CoordType, ValueType >* current, void* data ), const spatialaggregate::OcTreeKey< CoordType, ValueType >& minPosition, const spatialaggregate::OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth )
spatialaggregate::OcTreeNode::children_	octree.h	/^    OcTreeNode< CoordType, ValueType >* children_[8];$/;"	m	class:spatialaggregate::OcTreeNode	access:public
spatialaggregate::OcTreeNode::containedInRegion	octree.h	/^    inline bool containedInRegion( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition )
spatialaggregate::OcTreeNode::containedInRegion	octree.hpp	/^inline bool spatialaggregate::OcTreeNode< CoordType, ValueType >::containedInRegion( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition )
spatialaggregate::OcTreeNode::countNodes	octree.h	/^    inline unsigned int countNodes() {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:()
spatialaggregate::OcTreeNode::depth_	octree.h	/^    int depth_;$/;"	m	class:spatialaggregate::OcTreeNode	access:public
spatialaggregate::OcTreeNode::establishNeighbors	octree.h	/^    inline void establishNeighbors();$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:()
spatialaggregate::OcTreeNode::establishNeighbors	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::establishNeighbors() {$/;"	f	class:spatialaggregate::OcTreeNode	signature:()
spatialaggregate::OcTreeNode::findClosestNode	octree.h	/^    inline OcTreeNode< CoordType, ValueType >* findClosestNode( const Eigen::Matrix< CoordType, 4, 1 >& position, int depth, int& dist ) {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:( const Eigen::Matrix< CoordType, 4, 1 >& position, int depth, int& dist )
spatialaggregate::OcTreeNode::findClosestNode	octree.h	/^    inline OcTreeNode< CoordType, ValueType >* findClosestNode( const OcTreeKey< CoordType, ValueType >& position, int depth, int& dist );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& position, int depth, int& dist )
spatialaggregate::OcTreeNode::findClosestNode	octree.hpp	/^inline spatialaggregate::OcTreeNode< CoordType, ValueType >* spatialaggregate::OcTreeNode< CoordType, ValueType >::findClosestNode( const OcTreeKey< CoordType, ValueType >& position, int depth, int& dist ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const OcTreeKey< CoordType, ValueType >& position, int depth, int& dist )
spatialaggregate::OcTreeNode::findRepresentative	octree.h	/^    inline OcTreeNode< CoordType, ValueType >* findRepresentative( const Eigen::Matrix< CoordType, 4, 1 >& position, int maxDepth ) {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:( const Eigen::Matrix< CoordType, 4, 1 >& position, int maxDepth )
spatialaggregate::OcTreeNode::findRepresentative	octree.h	/^    inline OcTreeNode< CoordType, ValueType >* findRepresentative( const OcTreeKey< CoordType, ValueType >& position, int maxDepth );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& position, int maxDepth )
spatialaggregate::OcTreeNode::findRepresentative	octree.hpp	/^inline spatialaggregate::OcTreeNode< CoordType, ValueType >* spatialaggregate::OcTreeNode< CoordType, ValueType >::findRepresentative( const OcTreeKey< CoordType, ValueType >& position, int maxDepth ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const OcTreeKey< CoordType, ValueType >& position, int maxDepth )
spatialaggregate::OcTreeNode::finishBranch	octree.h	/^    inline void finishBranch();$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:()
spatialaggregate::OcTreeNode::finishBranch	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::finishBranch() {$/;"	f	class:spatialaggregate::OcTreeNode	signature:()
spatialaggregate::OcTreeNode::getAllLeaves	octree.h	/^    inline void getAllLeaves( std::list< OcTreeNode< CoordType, ValueType >* >& nodes );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( std::list< OcTreeNode< CoordType, ValueType >* >& nodes )
spatialaggregate::OcTreeNode::getAllLeaves	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::getAllLeaves( std::list< spatialaggregate::OcTreeNode< CoordType, ValueType >* >& points ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( std::list< spatialaggregate::OcTreeNode< CoordType, ValueType >* >& points )
spatialaggregate::OcTreeNode::getAllLeavesInVolume	octree.h	/^    inline void getAllLeavesInVolume( std::list< OcTreeNode< CoordType, ValueType >* >& nodes, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( std::list< OcTreeNode< CoordType, ValueType >* >& nodes, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth )
spatialaggregate::OcTreeNode::getAllLeavesInVolume	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::getAllLeavesInVolume( std::list< spatialaggregate::OcTreeNode< CoordType, ValueType >* >& points, const spatialaggregate::OcTreeKey< CoordType, ValueType >& minPosition, const spatialaggregate::OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( std::list< spatialaggregate::OcTreeNode< CoordType, ValueType >* >& points, const spatialaggregate::OcTreeKey< CoordType, ValueType >& minPosition, const spatialaggregate::OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth )
spatialaggregate::OcTreeNode::getAllNodesInVolumeOnDepth	octree.h	/^    inline void getAllNodesInVolumeOnDepth( std::list< OcTreeNode< CoordType, ValueType >* >& nodes, const Eigen::Matrix< CoordType, 4, 1 >& minPosition, const Eigen::Matrix< CoordType, 4, 1 >& maxPosition, int depth, bool lowerDepthLeaves ) {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:( std::list< OcTreeNode< CoordType, ValueType >* >& nodes, const Eigen::Matrix< CoordType, 4, 1 >& minPosition, const Eigen::Matrix< CoordType, 4, 1 >& maxPosition, int depth, bool lowerDepthLeaves )
spatialaggregate::OcTreeNode::getAllNodesInVolumeOnDepth	octree.h	/^    inline void getAllNodesInVolumeOnDepth( std::list< OcTreeNode< CoordType, ValueType >* >& nodes, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int depth, bool lowerDepthLeaves );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( std::list< OcTreeNode< CoordType, ValueType >* >& nodes, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int depth, bool lowerDepthLeaves )
spatialaggregate::OcTreeNode::getAllNodesInVolumeOnDepth	octree.h	/^    inline void getAllNodesInVolumeOnDepth( std::vector< OcTreeNode< CoordType, ValueType >* >& nodes, const Eigen::Matrix< CoordType, 4, 1 >& minPosition, const Eigen::Matrix< CoordType, 4, 1 >& maxPosition, int depth, bool lowerDepthLeaves ) {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:( std::vector< OcTreeNode< CoordType, ValueType >* >& nodes, const Eigen::Matrix< CoordType, 4, 1 >& minPosition, const Eigen::Matrix< CoordType, 4, 1 >& maxPosition, int depth, bool lowerDepthLeaves )
spatialaggregate::OcTreeNode::getAllNodesInVolumeOnDepth	octree.h	/^    inline void getAllNodesInVolumeOnDepth( std::vector< OcTreeNode< CoordType, ValueType >* >& nodes, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int depth, bool lowerDepthLeaves );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( std::vector< OcTreeNode< CoordType, ValueType >* >& nodes, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int depth, bool lowerDepthLeaves )
spatialaggregate::OcTreeNode::getAllNodesInVolumeOnDepth	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::getAllNodesInVolumeOnDepth( std::list< OcTreeNode< CoordType, ValueType >* >& points, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth, bool higherDepthLeaves ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( std::list< OcTreeNode< CoordType, ValueType >* >& points, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth, bool higherDepthLeaves )
spatialaggregate::OcTreeNode::getAllNodesInVolumeOnDepth	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::getAllNodesInVolumeOnDepth( std::vector< OcTreeNode< CoordType, ValueType >* >& points, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth, bool higherDepthLeaves ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( std::vector< OcTreeNode< CoordType, ValueType >* >& points, const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth, bool higherDepthLeaves )
spatialaggregate::OcTreeNode::getCenterKey	octree.h	/^    inline void getCenterKey( OcTreeKey< CoordType, ValueType >& center_key ) const;$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( OcTreeKey< CoordType, ValueType >& center_key ) const
spatialaggregate::OcTreeNode::getCenterKey	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::getCenterKey( OcTreeKey< CoordType, ValueType >& center_key ) const {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( OcTreeKey< CoordType, ValueType >& center_key ) const
spatialaggregate::OcTreeNode::getCenterPosition	octree.h	/^    inline Eigen::Matrix< CoordType, 4, 1 > getCenterPosition() const {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:() const
spatialaggregate::OcTreeNode::getFiniteBackwardDifference	octree.h	/^    inline double getFiniteBackwardDifference( int dim, double (*f)( OcTreeNode< CoordType, ValueType >* n ) );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( int dim, double (*f)( OcTreeNode< CoordType, ValueType >* n ) )
spatialaggregate::OcTreeNode::getFiniteBackwardDifference	octree.hpp	/^inline double spatialaggregate::OcTreeNode< CoordType, ValueType >::getFiniteBackwardDifference( int dim, double (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* n ) ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( int dim, double (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* n ) )
spatialaggregate::OcTreeNode::getFiniteCentralDifference	octree.h	/^    inline double getFiniteCentralDifference( int dim, double (*f)( OcTreeNode< CoordType, ValueType >* n ) );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( int dim, double (*f)( OcTreeNode< CoordType, ValueType >* n ) )
spatialaggregate::OcTreeNode::getFiniteCentralDifference	octree.hpp	/^inline double spatialaggregate::OcTreeNode< CoordType, ValueType >::getFiniteCentralDifference( int dim, double (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* n ) ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( int dim, double (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* n ) )
spatialaggregate::OcTreeNode::getFiniteForwardDifference	octree.h	/^    inline double getFiniteForwardDifference( int dim, double (*f)( OcTreeNode< CoordType, ValueType >* n ) );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( int dim, double (*f)( OcTreeNode< CoordType, ValueType >* n ) )
spatialaggregate::OcTreeNode::getFiniteForwardDifference	octree.hpp	/^inline double spatialaggregate::OcTreeNode< CoordType, ValueType >::getFiniteForwardDifference( int dim, double (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* n ) ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( int dim, double (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* n ) )
spatialaggregate::OcTreeNode::getMaxPosition	octree.h	/^    inline Eigen::Matrix< CoordType, 4, 1 > getMaxPosition() const {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:() const
spatialaggregate::OcTreeNode::getMinPosition	octree.h	/^    inline Eigen::Matrix< CoordType, 4, 1 > getMinPosition() const {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:() const
spatialaggregate::OcTreeNode::getNeighbor	octree.h	/^    inline OcTreeNode< CoordType, ValueType >* getNeighbor( int dx, int dy, int dz );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( int dx, int dy, int dz )
spatialaggregate::OcTreeNode::getNeighbor	octree.hpp	/^inline spatialaggregate::OcTreeNode< CoordType, ValueType >* spatialaggregate::OcTreeNode< CoordType, ValueType >::getNeighbor( int dx, int dy, int dz ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( int dx, int dy, int dz )
spatialaggregate::OcTreeNode::getNeighbors	octree.h	/^    inline void getNeighbors( std::list< OcTreeNode< CoordType, ValueType >* >& neighbors );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( std::list< OcTreeNode< CoordType, ValueType >* >& neighbors )
spatialaggregate::OcTreeNode::getNeighbors	octree.h	/^    inline void getNeighbors( std::vector< OcTreeNode< CoordType, ValueType >* >& neighbors );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( std::vector< OcTreeNode< CoordType, ValueType >* >& neighbors )
spatialaggregate::OcTreeNode::getNeighbors	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::getNeighbors( std::list< OcTreeNode< CoordType, ValueType >* >& neighbors ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( std::list< OcTreeNode< CoordType, ValueType >* >& neighbors )
spatialaggregate::OcTreeNode::getNeighbors	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::getNeighbors( std::vector< OcTreeNode< CoordType, ValueType >* >& neighbors ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( std::vector< OcTreeNode< CoordType, ValueType >* >& neighbors )
spatialaggregate::OcTreeNode::getOctant	octree.h	/^    inline unsigned int getOctant( const OcTreeKey< CoordType, ValueType >& position );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& position )
spatialaggregate::OcTreeNode::getOctant	octree.hpp	/^inline unsigned int spatialaggregate::OcTreeNode< CoordType, ValueType >::getOctant( const spatialaggregate::OcTreeKey< CoordType, ValueType >& query ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const spatialaggregate::OcTreeKey< CoordType, ValueType >& query )
spatialaggregate::OcTreeNode::getPosition	octree.h	/^    inline Eigen::Matrix< CoordType, 4, 1 > getPosition() const {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:() const
spatialaggregate::OcTreeNode::getValueInVolume	octree.h	/^    inline ValueType getValueInVolume( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth )
spatialaggregate::OcTreeNode::getValueInVolume	octree.hpp	/^inline ValueType spatialaggregate::OcTreeNode< CoordType, ValueType >::getValueInVolume( const spatialaggregate::OcTreeKey< CoordType, ValueType >& minPosition, const spatialaggregate::OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const spatialaggregate::OcTreeKey< CoordType, ValueType >& minPosition, const spatialaggregate::OcTreeKey< CoordType, ValueType >& maxPosition, int maxDepth )
spatialaggregate::OcTreeNode::inRegion	octree.h	/^    inline bool inRegion( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition )
spatialaggregate::OcTreeNode::inRegion	octree.h	/^    inline bool inRegion( const OcTreeKey< CoordType, ValueType >& position );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& position )
spatialaggregate::OcTreeNode::inRegion	octree.hpp	/^inline bool spatialaggregate::OcTreeNode< CoordType, ValueType >::inRegion( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition )
spatialaggregate::OcTreeNode::inRegion	octree.hpp	/^inline bool spatialaggregate::OcTreeNode< CoordType, ValueType >::inRegion( const OcTreeKey< CoordType, ValueType >& position ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const OcTreeKey< CoordType, ValueType >& position )
spatialaggregate::OcTreeNode::initialize	octree.h	/^    inline void initialize( OcTreeNodeType type, const OcTreeKey< CoordType, ValueType >& key, const ValueType& value, int depth, OcTreeNode< CoordType, ValueType >* parent, OcTree< CoordType, ValueType >* tree );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( OcTreeNodeType type, const OcTreeKey< CoordType, ValueType >& key, const ValueType& value, int depth, OcTreeNode< CoordType, ValueType >* parent, OcTree< CoordType, ValueType >* tree )
spatialaggregate::OcTreeNode::initialize	octree.h	/^    void initialize( OcTreeNode* node ) {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:( OcTreeNode* node )
spatialaggregate::OcTreeNode::initialize	octree.h	/^    void initialize() {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:()
spatialaggregate::OcTreeNode::initialize	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::initialize( OcTreeNodeType type, const OcTreeKey< CoordType, ValueType >& key, const ValueType& value, int depth, OcTreeNode< CoordType, ValueType >* parent, OcTree< CoordType, ValueType >* tree ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( OcTreeNodeType type, const OcTreeKey< CoordType, ValueType >& key, const ValueType& value, int depth, OcTreeNode< CoordType, ValueType >* parent, OcTree< CoordType, ValueType >* tree )
spatialaggregate::OcTreeNode::interpolateTriLinear	octree.h	/^    inline bool interpolateTriLinear( double& value, OcTreeNode< CoordType, ValueType >* node, const OcTreeKey< CoordType, ValueType >& queryKey, double (*f)( OcTreeNode< CoordType, ValueType >* n ) );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( double& value, OcTreeNode< CoordType, ValueType >* node, const OcTreeKey< CoordType, ValueType >& queryKey, double (*f)( OcTreeNode< CoordType, ValueType >* n ) )
spatialaggregate::OcTreeNode::interpolateTriLinear	octree.hpp	/^inline bool spatialaggregate::OcTreeNode< CoordType, ValueType >::interpolateTriLinear( double& value, spatialaggregate::OcTreeNode< CoordType, ValueType >* node, const spatialaggregate::OcTreeKey< CoordType, ValueType >& queryKey, double (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* n ) ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( double& value, spatialaggregate::OcTreeNode< CoordType, ValueType >* node, const spatialaggregate::OcTreeKey< CoordType, ValueType >& queryKey, double (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* n ) )
spatialaggregate::OcTreeNode::invResolution	octree.h	/^    inline CoordType invResolution();$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:()
spatialaggregate::OcTreeNode::invResolution	octree.hpp	/^inline CoordType spatialaggregate::OcTreeNode< CoordType, ValueType >::invResolution() {$/;"	f	class:spatialaggregate::OcTreeNode	signature:()
spatialaggregate::OcTreeNode::max_key_	octree.h	/^    OcTreeKey< CoordType, ValueType > pos_key_, min_key_, max_key_;$/;"	m	class:spatialaggregate::OcTreeNode	access:public
spatialaggregate::OcTreeNode::min_key_	octree.h	/^    OcTreeKey< CoordType, ValueType > pos_key_, min_key_, max_key_;$/;"	m	class:spatialaggregate::OcTreeNode	access:public
spatialaggregate::OcTreeNode::neighbors_	octree.h	/^    OcTreeNode< CoordType, ValueType >* neighbors_[27];$/;"	m	class:spatialaggregate::OcTreeNode	access:public
spatialaggregate::OcTreeNode::overlap	octree.h	/^    inline bool overlap( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition )
spatialaggregate::OcTreeNode::overlap	octree.hpp	/^inline bool spatialaggregate::OcTreeNode< CoordType, ValueType >::overlap( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition )
spatialaggregate::OcTreeNode::parent_	octree.h	/^    OcTreeNode< CoordType, ValueType >* parent_;$/;"	m	class:spatialaggregate::OcTreeNode	access:public
spatialaggregate::OcTreeNode::pos_key_	octree.h	/^    OcTreeKey< CoordType, ValueType > pos_key_, min_key_, max_key_;$/;"	m	class:spatialaggregate::OcTreeNode	access:public
spatialaggregate::OcTreeNode::regionContained	octree.h	/^    inline bool regionContained( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition )
spatialaggregate::OcTreeNode::regionContained	octree.hpp	/^inline bool spatialaggregate::OcTreeNode< CoordType, ValueType >::regionContained( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( const OcTreeKey< CoordType, ValueType >& minPosition, const OcTreeKey< CoordType, ValueType >& maxPosition )
spatialaggregate::OcTreeNode::resolution	octree.h	/^    inline CoordType resolution();$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:()
spatialaggregate::OcTreeNode::resolution	octree.hpp	/^inline CoordType spatialaggregate::OcTreeNode< CoordType, ValueType >::resolution() {$/;"	f	class:spatialaggregate::OcTreeNode	signature:()
spatialaggregate::OcTreeNode::sweepDown	octree.h	/^    inline void sweepDown( void* data, void (*f)( OcTreeNode< CoordType, ValueType >* current, OcTreeNode< CoordType, ValueType >* next, void* data ) );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( void* data, void (*f)( OcTreeNode< CoordType, ValueType >* current, OcTreeNode< CoordType, ValueType >* next, void* data ) )
spatialaggregate::OcTreeNode::sweepDown	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::sweepDown( void* data, void (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* current, spatialaggregate::OcTreeNode< CoordType, ValueType >* next, void* data ) ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( void* data, void (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* current, spatialaggregate::OcTreeNode< CoordType, ValueType >* next, void* data ) )
spatialaggregate::OcTreeNode::sweepUp	octree.h	/^    inline void sweepUp( void* data, void (*f)( OcTreeNode< CoordType, ValueType >* current, OcTreeNode< CoordType, ValueType >* next, void* data ) );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( void* data, void (*f)( OcTreeNode< CoordType, ValueType >* current, OcTreeNode< CoordType, ValueType >* next, void* data ) )
spatialaggregate::OcTreeNode::sweepUp	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::sweepUp( void* data, void (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* current, spatialaggregate::OcTreeNode< CoordType, ValueType >* next, void* data ) ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( void* data, void (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* current, spatialaggregate::OcTreeNode< CoordType, ValueType >* next, void* data ) )
spatialaggregate::OcTreeNode::tree_	octree.h	/^    OcTree< CoordType, ValueType >* tree_;$/;"	m	class:spatialaggregate::OcTreeNode	access:public
spatialaggregate::OcTreeNode::type_	octree.h	/^    OcTreeNodeType type_;$/;"	m	class:spatialaggregate::OcTreeNode	access:public
spatialaggregate::OcTreeNode::value_	octree.h	/^    ValueType value_;$/;"	m	class:spatialaggregate::OcTreeNode	access:public
spatialaggregate::OcTreeNode::~OcTreeNode	octree.h	/^    ~OcTreeNode() {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:()
spatialaggregate::OcTreeNodeAllocator	octree.h	/^  class OcTreeNodeAllocator : public boost::enable_shared_from_this< OcTreeNodeAllocator< CoordType, ValueType > > {$/;"	c	namespace:spatialaggregate	inherits:boost::enable_shared_from_this
spatialaggregate::OcTreeNodeAllocator	octree.h	/^  template< typename CoordType, typename ValueType > class OcTreeNodeAllocator;$/;"	x
spatialaggregate::OcTreeNodeAllocator::EIGEN_MAKE_ALIGNED_OPERATOR_NEW	octree.h	/^        EIGEN_MAKE_ALIGNED_OPERATOR_NEW;$/;"	m	class:spatialaggregate::OcTreeNodeAllocator	access:public
spatialaggregate::OcTreeNodeAllocator::OcTreeNodeAllocator	octree.h	/^    OcTreeNodeAllocator() {}$/;"	f	class:spatialaggregate::OcTreeNodeAllocator	access:public	signature:()
spatialaggregate::OcTreeNodeAllocator::allocateNode	octree.h	/^    inline virtual OcTreeNode< CoordType, ValueType >* allocateNode() { return new OcTreeNode< CoordType, ValueType >(); }$/;"	f	class:spatialaggregate::OcTreeNodeAllocator	access:public	signature:()
spatialaggregate::OcTreeNodeAllocator::deallocateNode	octree.h	/^    inline virtual void deallocateNode( OcTreeNode< CoordType, ValueType >* node ) { delete node; }$/;"	f	class:spatialaggregate::OcTreeNodeAllocator	access:public	signature:( OcTreeNode< CoordType, ValueType >* node )
spatialaggregate::OcTreeNodeAllocator::reset	octree.h	/^    inline virtual void reset() {}$/;"	f	class:spatialaggregate::OcTreeNodeAllocator	access:public	signature:()
spatialaggregate::OcTreeNodeAllocator::~OcTreeNodeAllocator	octree.h	/^    virtual ~OcTreeNodeAllocator() {}$/;"	f	class:spatialaggregate::OcTreeNodeAllocator	access:public	signature:()
spatialaggregate::OcTreeNodeDynamicAllocator	octree.h	/^  class OcTreeNodeDynamicAllocator : public OcTreeNodeAllocator< CoordType, ValueType > {$/;"	c	namespace:spatialaggregate	inherits:OcTreeNodeAllocator
spatialaggregate::OcTreeNodeDynamicAllocator::AllocPoolIterator	octree.h	/^    typedef typename DynamicAllocator< OcTreeNode< CoordType, ValueType > >::PoolIterator AllocPoolIterator;$/;"	t	class:spatialaggregate::OcTreeNodeDynamicAllocator	access:public
spatialaggregate::OcTreeNodeDynamicAllocator::EIGEN_MAKE_ALIGNED_OPERATOR_NEW	octree.h	/^        EIGEN_MAKE_ALIGNED_OPERATOR_NEW;$/;"	m	class:spatialaggregate::OcTreeNodeDynamicAllocator	access:public
spatialaggregate::OcTreeNodeDynamicAllocator::OcTreeNodeDynamicAllocator	octree.h	/^    OcTreeNodeDynamicAllocator( unsigned int block_size )$/;"	f	class:spatialaggregate::OcTreeNodeDynamicAllocator	access:public	signature:( unsigned int block_size )
spatialaggregate::OcTreeNodeDynamicAllocator::alloc_	octree.h	/^    DynamicAllocator< OcTreeNode< CoordType, ValueType > > alloc_;$/;"	m	class:spatialaggregate::OcTreeNodeDynamicAllocator	access:public
spatialaggregate::OcTreeNodeDynamicAllocator::allocateNode	octree.h	/^    inline virtual OcTreeNode< CoordType, ValueType >* allocateNode() {$/;"	f	class:spatialaggregate::OcTreeNodeDynamicAllocator	access:public	signature:()
spatialaggregate::OcTreeNodeDynamicAllocator::deallocateNode	octree.h	/^    inline virtual void deallocateNode( OcTreeNode< CoordType, ValueType >* node ) {}$/;"	f	class:spatialaggregate::OcTreeNodeDynamicAllocator	access:public	signature:( OcTreeNode< CoordType, ValueType >* node )
spatialaggregate::OcTreeNodeDynamicAllocator::reset	octree.h	/^    inline virtual void reset() {$/;"	f	class:spatialaggregate::OcTreeNodeDynamicAllocator	access:public	signature:()
spatialaggregate::OcTreeNodeDynamicAllocator::~OcTreeNodeDynamicAllocator	octree.h	/^    virtual ~OcTreeNodeDynamicAllocator() {$/;"	f	class:spatialaggregate::OcTreeNodeDynamicAllocator	access:public	signature:()
spatialaggregate::OcTreeNodeFixedCountAllocator	octree.h	/^  class OcTreeNodeFixedCountAllocator : public OcTreeNodeAllocator< CoordType, ValueType > {$/;"	c	namespace:spatialaggregate	inherits:OcTreeNodeAllocator
spatialaggregate::OcTreeNodeFixedCountAllocator::EIGEN_MAKE_ALIGNED_OPERATOR_NEW	octree.h	/^        EIGEN_MAKE_ALIGNED_OPERATOR_NEW;$/;"	m	class:spatialaggregate::OcTreeNodeFixedCountAllocator	access:public
spatialaggregate::OcTreeNodeFixedCountAllocator::OcTreeNodeFixedCountAllocator	octree.h	/^    OcTreeNodeFixedCountAllocator( unsigned int numPoints ) {$/;"	f	class:spatialaggregate::OcTreeNodeFixedCountAllocator	access:public	signature:( unsigned int numPoints )
spatialaggregate::OcTreeNodeFixedCountAllocator::allocateNode	octree.h	/^    inline virtual OcTreeNode< CoordType, ValueType >* allocateNode() {$/;"	f	class:spatialaggregate::OcTreeNodeFixedCountAllocator	access:public	signature:()
spatialaggregate::OcTreeNodeFixedCountAllocator::current_node_	octree.h	/^    OcTreeNode< CoordType, ValueType >* current_node_;$/;"	m	class:spatialaggregate::OcTreeNodeFixedCountAllocator	access:public
spatialaggregate::OcTreeNodeFixedCountAllocator::deallocateNode	octree.h	/^    inline virtual void deallocateNode( OcTreeNode< CoordType, ValueType >* node ) {}$/;"	f	class:spatialaggregate::OcTreeNodeFixedCountAllocator	access:public	signature:( OcTreeNode< CoordType, ValueType >* node )
spatialaggregate::OcTreeNodeFixedCountAllocator::last_node_	octree.h	/^    OcTreeNode< CoordType, ValueType >* last_node_;$/;"	m	class:spatialaggregate::OcTreeNodeFixedCountAllocator	access:public
spatialaggregate::OcTreeNodeFixedCountAllocator::nodes_	octree.h	/^    OcTreeNode< CoordType, ValueType >* nodes_;$/;"	m	class:spatialaggregate::OcTreeNodeFixedCountAllocator	access:public
spatialaggregate::OcTreeNodeFixedCountAllocator::reset	octree.h	/^    inline virtual void reset() {$/;"	f	class:spatialaggregate::OcTreeNodeFixedCountAllocator	access:public	signature:()
spatialaggregate::OcTreeNodeFixedCountAllocator::~OcTreeNodeFixedCountAllocator	octree.h	/^    virtual ~OcTreeNodeFixedCountAllocator() {$/;"	f	class:spatialaggregate::OcTreeNodeFixedCountAllocator	access:public	signature:()
spatialaggregate::OcTreeNodeType	octree.h	/^  enum OcTreeNodeType {$/;"	g	namespace:spatialaggregate
spotri_	XYLapack.cpp	/^	extern "C" int spotri_(char *uplo, int *n, float *a, int *lda, int *info);$/;"	p	file:	signature:(char *uplo, int *n, float *a, int *lda, int *info)
ssyev_	XYLapack.cpp	/^	extern "C"  int ssyev_(char *jobz, char *uplo, int *n, float *a, $/;"	p	file:	signature:(char *jobz, char *uplo, int *n, float *a, int *lda, float *w, float *work, int *lwork, int *info)
state	MersenneTwister.h	/^	uint32 state[N];   \/\/ internal state$/;"	m	class:MTRand	access:protected
str_	XYFile.h	/^   string str_;$/;"	m	class:CXYStringTokenizer	access:private
string_as_T	ConfigFile.h	/^	template<class T> static T string_as_T( const string& s );$/;"	p	class:ConfigFile	access:protected	signature:( const string& s )
string_as_T	ConfigFile.h	/^T ConfigFile::string_as_T( const string& s )$/;"	f	class:ConfigFile	signature:( const string& s )
string_as_T	ConfigFile.h	/^inline bool ConfigFile::string_as_T<bool>( const string& s )$/;"	f	class:ConfigFile	signature:( const string& s )
string_as_T	ConfigFile.h	/^inline string ConfigFile::string_as_T<string>( const string& s )$/;"	f	class:ConfigFile	signature:( const string& s )
subtree	tree.hh	/^		tree     subtree(sibling_iterator from, sibling_iterator to) const;$/;"	p	class:tree	access:public	signature:(sibling_iterator from, sibling_iterator to) const
subtree	tree.hh	/^		void     subtree(tree&, sibling_iterator from, sibling_iterator to) const;$/;"	p	class:tree	access:public	signature:(tree&, sibling_iterator from, sibling_iterator to) const
subtree	tree.hh	/^tree<T, tree_node_allocator> tree<T, tree_node_allocator>::subtree(sibling_iterator from, sibling_iterator to) const$/;"	f	class:tree	signature:(sibling_iterator from, sibling_iterator to) const
subtree	tree.hh	/^void tree<T, tree_node_allocator>::subtree(tree& tmp, sibling_iterator from, sibling_iterator to) const$/;"	f	class:tree	signature:(tree& tmp, sibling_iterator from, sibling_iterator to) const
swap	tree.hh	/^		void     swap(sibling_iterator it);$/;"	p	class:tree	access:public	signature:(sibling_iterator it)
swap	tree.hh	/^	   void     swap(iterator, iterator);$/;"	p	class:tree	access:public	signature:(iterator, iterator)
swap	tree.hh	/^void tree<T, tree_node_allocator>::swap(iterator one, iterator two)$/;"	f	class:tree	signature:(iterator one, iterator two)
swap	tree.hh	/^void tree<T, tree_node_allocator>::swap(sibling_iterator it)$/;"	f	class:tree	signature:(sibling_iterator it)
sweepDown	octree.h	/^    inline void sweepDown( void* data, void (*f)( OcTreeNode< CoordType, ValueType >* current, OcTreeNode< CoordType, ValueType >* next, void* data ) );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( void* data, void (*f)( OcTreeNode< CoordType, ValueType >* current, OcTreeNode< CoordType, ValueType >* next, void* data ) )
sweepDown	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::sweepDown( void* data, void (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* current, spatialaggregate::OcTreeNode< CoordType, ValueType >* next, void* data ) ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( void* data, void (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* current, spatialaggregate::OcTreeNode< CoordType, ValueType >* next, void* data ) )
sweepUp	octree.h	/^    inline void sweepUp( void* data, void (*f)( OcTreeNode< CoordType, ValueType >* current, OcTreeNode< CoordType, ValueType >* next, void* data ) );$/;"	p	class:spatialaggregate::OcTreeNode	access:public	signature:( void* data, void (*f)( OcTreeNode< CoordType, ValueType >* current, OcTreeNode< CoordType, ValueType >* next, void* data ) )
sweepUp	octree.hpp	/^inline void spatialaggregate::OcTreeNode< CoordType, ValueType >::sweepUp( void* data, void (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* current, spatialaggregate::OcTreeNode< CoordType, ValueType >* next, void* data ) ) {$/;"	f	class:spatialaggregate::OcTreeNode	signature:( void* data, void (*f)( spatialaggregate::OcTreeNode< CoordType, ValueType >* current, spatialaggregate::OcTreeNode< CoordType, ValueType >* next, void* data ) )
theta	XYSO3Sequence.h	/^	double theta; \/\/ pitch$/;"	m	struct:EulerAngle	access:public
third	XYUtility.h	/^	T3 third;$/;"	m	class:CXYTriple	access:public
top_node	tree.hh	/^				tree_node *top_node;$/;"	m	class:tree::fixed_depth_iterator	access:public
top_node	tree.hh	/^				tree_node *top_node;$/;"	m	class:tree::leaf_iterator	access:private
traversal_queue	tree.hh	/^				std::queue<tree_node *> traversal_queue;$/;"	m	class:tree::breadth_first_queued_iterator	access:private
tree	tree.hh	/^		tree();$/;"	p	class:tree	access:public	signature:()
tree	tree.hh	/^		tree(const T&);$/;"	p	class:tree	access:public	signature:(const T&)
tree	tree.hh	/^		tree(const iterator_base&);$/;"	p	class:tree	access:public	signature:(const iterator_base&)
tree	tree.hh	/^		tree(const tree<T, tree_node_allocator>&);$/;"	p	class:tree	access:public	signature:(const tree<T, tree_node_allocator>&)
tree	tree.hh	/^class tree {$/;"	c
tree	tree.hh	/^tree<T, tree_node_allocator>::tree() $/;"	f	class:tree	signature:()
tree	tree.hh	/^tree<T, tree_node_allocator>::tree(const T& x) $/;"	f	class:tree	signature:(const T& x)
tree	tree.hh	/^tree<T, tree_node_allocator>::tree(const iterator_base& other)$/;"	f	class:tree	signature:(const iterator_base& other)
tree	tree.hh	/^tree<T, tree_node_allocator>::tree(const tree<T, tree_node_allocator>& other)$/;"	f	class:tree	signature:(const tree<T, tree_node_allocator>& other)
tree::alloc_	tree.hh	/^		tree_node_allocator alloc_;$/;"	m	class:tree	access:private
tree::append_child	tree.hh	/^		template<typename iter> iter append_child(iter position); $/;"	p	class:tree	access:public	signature:(iter position)
tree::append_child	tree.hh	/^		template<typename iter> iter append_child(iter position, const T& x);$/;"	p	class:tree	access:public	signature:(iter position, const T& x)
tree::append_child	tree.hh	/^		template<typename iter> iter append_child(iter position, iter other_position);$/;"	p	class:tree	access:public	signature:(iter position, iter other_position)
tree::append_child	tree.hh	/^iter tree<T, tree_node_allocator>::append_child(iter position)$/;"	f	class:tree	signature:(iter position)
tree::append_child	tree.hh	/^iter tree<T, tree_node_allocator>::append_child(iter position, const T& x)$/;"	f	class:tree	signature:(iter position, const T& x)
tree::append_child	tree.hh	/^iter tree<T, tree_node_allocator>::append_child(iter position, iter other)$/;"	f	class:tree	signature:(iter position, iter other)
tree::append_children	tree.hh	/^		template<typename iter> iter append_children(iter position, sibling_iterator from, sibling_iterator to);$/;"	p	class:tree	access:public	signature:(iter position, sibling_iterator from, sibling_iterator to)
tree::append_children	tree.hh	/^iter tree<T, tree_node_allocator>::append_children(iter position, sibling_iterator from, sibling_iterator to)$/;"	f	class:tree	signature:(iter position, sibling_iterator from, sibling_iterator to)
tree::begin	tree.hh	/^		inline pre_order_iterator   begin() const;$/;"	p	class:tree	access:public	signature:() const
tree::begin	tree.hh	/^		sibling_iterator     begin(const iterator_base&) const;$/;"	p	class:tree	access:public	signature:(const iterator_base&) const
tree::begin	tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator tree<T, tree_node_allocator>::begin() const$/;"	f	class:tree	signature:() const
tree::begin	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::begin(const iterator_base& pos) const$/;"	f	class:tree	signature:(const iterator_base& pos) const
tree::begin_breadth_first	tree.hh	/^		breadth_first_queued_iterator begin_breadth_first() const;$/;"	p	class:tree	access:public	signature:() const
tree::begin_breadth_first	tree.hh	/^typename tree<T, tree_node_allocator>::breadth_first_queued_iterator tree<T, tree_node_allocator>::begin_breadth_first() const$/;"	f	class:tree	signature:() const
tree::begin_fixed	tree.hh	/^		fixed_depth_iterator begin_fixed(const iterator_base&, unsigned int) const;$/;"	p	class:tree	access:public	signature:(const iterator_base&, unsigned int) const
tree::begin_fixed	tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator tree<T, tree_node_allocator>::begin_fixed(const iterator_base& pos, unsigned int dp) const$/;"	f	class:tree	signature:(const iterator_base& pos, unsigned int dp) const
tree::begin_leaf	tree.hh	/^      leaf_iterator   begin_leaf() const;$/;"	p	class:tree	access:public	signature:() const
tree::begin_leaf	tree.hh	/^      leaf_iterator   begin_leaf(const iterator_base& top) const;$/;"	p	class:tree	access:public	signature:(const iterator_base& top) const
tree::begin_leaf	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator tree<T, tree_node_allocator>::begin_leaf() const$/;"	f	class:tree	signature:() const
tree::begin_leaf	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator tree<T, tree_node_allocator>::begin_leaf(const iterator_base& top) const$/;"	f	class:tree	signature:(const iterator_base& top) const
tree::begin_post	tree.hh	/^		post_order_iterator  begin_post() const;$/;"	p	class:tree	access:public	signature:() const
tree::begin_post	tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator tree<T, tree_node_allocator>::begin_post() const$/;"	f	class:tree	signature:() const
tree::breadth_first_iterator	tree.hh	/^		typedef breadth_first_queued_iterator breadth_first_iterator;$/;"	t	class:tree	access:public
tree::breadth_first_queued_iterator	tree.hh	/^		class breadth_first_queued_iterator : public iterator_base {$/;"	c	class:tree	inherits:iterator_base	access:public
tree::breadth_first_queued_iterator::breadth_first_queued_iterator	tree.hh	/^				breadth_first_queued_iterator();$/;"	p	class:tree::breadth_first_queued_iterator	access:public	signature:()
tree::breadth_first_queued_iterator::breadth_first_queued_iterator	tree.hh	/^				breadth_first_queued_iterator(const iterator_base&);$/;"	p	class:tree::breadth_first_queued_iterator	access:public	signature:(const iterator_base&)
tree::breadth_first_queued_iterator::breadth_first_queued_iterator	tree.hh	/^				breadth_first_queued_iterator(tree_node *);$/;"	p	class:tree::breadth_first_queued_iterator	access:public	signature:(tree_node *)
tree::breadth_first_queued_iterator::breadth_first_queued_iterator	tree.hh	/^tree<T, tree_node_allocator>::breadth_first_queued_iterator::breadth_first_queued_iterator()$/;"	f	class:tree::breadth_first_queued_iterator	signature:()
tree::breadth_first_queued_iterator::breadth_first_queued_iterator	tree.hh	/^tree<T, tree_node_allocator>::breadth_first_queued_iterator::breadth_first_queued_iterator(const iterator_base& other)$/;"	f	class:tree::breadth_first_queued_iterator	signature:(const iterator_base& other)
tree::breadth_first_queued_iterator::breadth_first_queued_iterator	tree.hh	/^tree<T, tree_node_allocator>::breadth_first_queued_iterator::breadth_first_queued_iterator(tree_node *tn)$/;"	f	class:tree::breadth_first_queued_iterator	signature:(tree_node *tn)
tree::breadth_first_queued_iterator::operator !=	tree.hh	/^				bool    operator!=(const breadth_first_queued_iterator&) const;$/;"	p	class:tree::breadth_first_queued_iterator	access:public	signature:(const breadth_first_queued_iterator&) const
tree::breadth_first_queued_iterator::operator !=	tree.hh	/^bool tree<T, tree_node_allocator>::breadth_first_queued_iterator::operator!=(const breadth_first_queued_iterator& other) const$/;"	f	class:tree::breadth_first_queued_iterator	signature:(const breadth_first_queued_iterator& other) const
tree::breadth_first_queued_iterator::operator ++	tree.hh	/^				breadth_first_queued_iterator   operator++(int);$/;"	p	class:tree::breadth_first_queued_iterator	access:public	signature:(int)
tree::breadth_first_queued_iterator::operator ++	tree.hh	/^				breadth_first_queued_iterator&  operator++();$/;"	p	class:tree::breadth_first_queued_iterator	access:public	signature:()
tree::breadth_first_queued_iterator::operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::breadth_first_queued_iterator tree<T, tree_node_allocator>::breadth_first_queued_iterator::operator++(int)$/;"	f	class:tree::breadth_first_queued_iterator	signature:(int)
tree::breadth_first_queued_iterator::operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::breadth_first_queued_iterator& tree<T, tree_node_allocator>::breadth_first_queued_iterator::operator++()$/;"	f	class:tree::breadth_first_queued_iterator	signature:()
tree::breadth_first_queued_iterator::operator +=	tree.hh	/^				breadth_first_queued_iterator&  operator+=(unsigned int);$/;"	p	class:tree::breadth_first_queued_iterator	access:public	signature:(unsigned int)
tree::breadth_first_queued_iterator::operator +=	tree.hh	/^typename tree<T, tree_node_allocator>::breadth_first_queued_iterator& tree<T, tree_node_allocator>::breadth_first_queued_iterator::operator+=(unsigned int num)$/;"	f	class:tree::breadth_first_queued_iterator	signature:(unsigned int num)
tree::breadth_first_queued_iterator::operator ==	tree.hh	/^				bool    operator==(const breadth_first_queued_iterator&) const;$/;"	p	class:tree::breadth_first_queued_iterator	access:public	signature:(const breadth_first_queued_iterator&) const
tree::breadth_first_queued_iterator::operator ==	tree.hh	/^bool tree<T, tree_node_allocator>::breadth_first_queued_iterator::operator==(const breadth_first_queued_iterator& other) const$/;"	f	class:tree::breadth_first_queued_iterator	signature:(const breadth_first_queued_iterator& other) const
tree::breadth_first_queued_iterator::traversal_queue	tree.hh	/^				std::queue<tree_node *> traversal_queue;$/;"	m	class:tree::breadth_first_queued_iterator	access:private
tree::child	tree.hh	/^		static sibling_iterator child(const iterator_base& position, unsigned int);$/;"	p	class:tree	access:public	signature:(const iterator_base& position, unsigned int)
tree::child	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::child(const iterator_base& it, unsigned int num) $/;"	f	class:tree	signature:(const iterator_base& it, unsigned int num)
tree::clear	tree.hh	/^		void     clear();$/;"	p	class:tree	access:public	signature:()
tree::clear	tree.hh	/^void tree<T, tree_node_allocator>::clear()$/;"	f	class:tree	signature:()
tree::compare_nodes	tree.hh	/^		class compare_nodes {$/;"	c	class:tree	access:private
tree::compare_nodes::comp_	tree.hh	/^				StrictWeakOrdering comp_;$/;"	m	class:tree::compare_nodes	access:private
tree::compare_nodes::compare_nodes	tree.hh	/^				compare_nodes(StrictWeakOrdering comp) : comp_(comp) {};$/;"	f	class:tree::compare_nodes	access:public	signature:(StrictWeakOrdering comp)
tree::compare_nodes::operator ()	tree.hh	/^				bool operator()(const tree_node *a, const tree_node *b) $/;"	f	class:tree::compare_nodes	access:public	signature:(const tree_node *a, const tree_node *b)
tree::copy_	tree.hh	/^		void copy_(const tree<T, tree_node_allocator>& other);$/;"	p	class:tree	access:private	signature:(const tree<T, tree_node_allocator>& other)
tree::copy_	tree.hh	/^void tree<T, tree_node_allocator>::copy_(const tree<T, tree_node_allocator>& other) $/;"	f	class:tree	signature:(const tree<T, tree_node_allocator>& other)
tree::depth	tree.hh	/^		static int depth(const iterator_base&);$/;"	p	class:tree	access:public	signature:(const iterator_base&)
tree::depth	tree.hh	/^		static int depth(const iterator_base&, const iterator_base&);$/;"	p	class:tree	access:public	signature:(const iterator_base&, const iterator_base&)
tree::depth	tree.hh	/^int tree<T, tree_node_allocator>::depth(const iterator_base& it) $/;"	f	class:tree	signature:(const iterator_base& it)
tree::depth	tree.hh	/^int tree<T, tree_node_allocator>::depth(const iterator_base& it, const iterator_base& root) $/;"	f	class:tree	signature:(const iterator_base& it, const iterator_base& root)
tree::empty	tree.hh	/^		bool     empty() const;$/;"	p	class:tree	access:public	signature:() const
tree::empty	tree.hh	/^bool tree<T, tree_node_allocator>::empty() const$/;"	f	class:tree	signature:() const
tree::end	tree.hh	/^		inline pre_order_iterator   end() const;$/;"	p	class:tree	access:public	signature:() const
tree::end	tree.hh	/^		sibling_iterator     end(const iterator_base&) const;$/;"	p	class:tree	access:public	signature:(const iterator_base&) const
tree::end	tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator tree<T, tree_node_allocator>::end() const$/;"	f	class:tree	signature:() const
tree::end	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::end(const iterator_base& pos) const$/;"	f	class:tree	signature:(const iterator_base& pos) const
tree::end_breadth_first	tree.hh	/^		breadth_first_queued_iterator end_breadth_first() const;$/;"	p	class:tree	access:public	signature:() const
tree::end_breadth_first	tree.hh	/^typename tree<T, tree_node_allocator>::breadth_first_queued_iterator tree<T, tree_node_allocator>::end_breadth_first() const$/;"	f	class:tree	signature:() const
tree::end_fixed	tree.hh	/^		fixed_depth_iterator end_fixed(const iterator_base&, unsigned int) const;$/;"	p	class:tree	access:public	signature:(const iterator_base&, unsigned int) const
tree::end_fixed	tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator tree<T, tree_node_allocator>::end_fixed(const iterator_base& pos, unsigned int dp) const$/;"	f	class:tree	signature:(const iterator_base& pos, unsigned int dp) const
tree::end_leaf	tree.hh	/^      leaf_iterator   end_leaf() const;$/;"	p	class:tree	access:public	signature:() const
tree::end_leaf	tree.hh	/^      leaf_iterator   end_leaf(const iterator_base& top) const;$/;"	p	class:tree	access:public	signature:(const iterator_base& top) const
tree::end_leaf	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator tree<T, tree_node_allocator>::end_leaf() const$/;"	f	class:tree	signature:() const
tree::end_leaf	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator tree<T, tree_node_allocator>::end_leaf(const iterator_base& top) const$/;"	f	class:tree	signature:(const iterator_base& top) const
tree::end_post	tree.hh	/^		post_order_iterator  end_post() const;$/;"	p	class:tree	access:public	signature:() const
tree::end_post	tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator tree<T, tree_node_allocator>::end_post() const$/;"	f	class:tree	signature:() const
tree::equal	tree.hh	/^		bool     equal(const iter& one, const iter& two, const iter& three) const;$/;"	p	class:tree	access:public	signature:(const iter& one, const iter& two, const iter& three) const
tree::equal	tree.hh	/^		bool     equal(const iter& one, const iter& two, const iter& three, BinaryPredicate) const;$/;"	p	class:tree	access:public	signature:(const iter& one, const iter& two, const iter& three, BinaryPredicate) const
tree::equal	tree.hh	/^bool tree<T, tree_node_allocator>::equal(const iter& one_, const iter& two, const iter& three_) const$/;"	f	class:tree	signature:(const iter& one_, const iter& two, const iter& three_) const
tree::equal	tree.hh	/^bool tree<T, tree_node_allocator>::equal(const iter& one_, const iter& two, const iter& three_, BinaryPredicate fun) const$/;"	f	class:tree	signature:(const iter& one_, const iter& two, const iter& three_, BinaryPredicate fun) const
tree::equal_subtree	tree.hh	/^		bool     equal_subtree(const iter& one, const iter& two) const;$/;"	p	class:tree	access:public	signature:(const iter& one, const iter& two) const
tree::equal_subtree	tree.hh	/^		bool     equal_subtree(const iter& one, const iter& two, BinaryPredicate) const;$/;"	p	class:tree	access:public	signature:(const iter& one, const iter& two, BinaryPredicate) const
tree::equal_subtree	tree.hh	/^bool tree<T, tree_node_allocator>::equal_subtree(const iter& one_, const iter& two_) const$/;"	f	class:tree	signature:(const iter& one_, const iter& two_) const
tree::equal_subtree	tree.hh	/^bool tree<T, tree_node_allocator>::equal_subtree(const iter& one_, const iter& two_, BinaryPredicate fun) const$/;"	f	class:tree	signature:(const iter& one_, const iter& two_, BinaryPredicate fun) const
tree::erase	tree.hh	/^		template<typename iter> iter erase(iter);$/;"	p	class:tree	access:public	signature:(iter)
tree::erase	tree.hh	/^iter tree<T, tree_node_allocator>::erase(iter it)$/;"	f	class:tree	signature:(iter it)
tree::erase_children	tree.hh	/^		void     erase_children(const iterator_base&);$/;"	p	class:tree	access:public	signature:(const iterator_base&)
tree::erase_children	tree.hh	/^void tree<T, tree_node_allocator>::erase_children(const iterator_base& it)$/;"	f	class:tree	signature:(const iterator_base& it)
tree::feet	tree.hh	/^		tree_node *head, *feet;    \/\/ head\/feet are always dummy; if an iterator points to them it is invalid$/;"	m	class:tree	access:public
tree::fixed_depth_iterator	tree.hh	/^		class fixed_depth_iterator : public iterator_base {$/;"	c	class:tree	inherits:iterator_base	access:public
tree::fixed_depth_iterator::fixed_depth_iterator	tree.hh	/^				fixed_depth_iterator();$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:()
tree::fixed_depth_iterator::fixed_depth_iterator	tree.hh	/^				fixed_depth_iterator(const fixed_depth_iterator&);$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(const fixed_depth_iterator&)
tree::fixed_depth_iterator::fixed_depth_iterator	tree.hh	/^				fixed_depth_iterator(const iterator_base&);$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(const iterator_base&)
tree::fixed_depth_iterator::fixed_depth_iterator	tree.hh	/^				fixed_depth_iterator(const sibling_iterator&);$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(const sibling_iterator&)
tree::fixed_depth_iterator::fixed_depth_iterator	tree.hh	/^				fixed_depth_iterator(tree_node *);$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(tree_node *)
tree::fixed_depth_iterator::fixed_depth_iterator	tree.hh	/^tree<T, tree_node_allocator>::fixed_depth_iterator::fixed_depth_iterator()$/;"	f	class:tree::fixed_depth_iterator	signature:()
tree::fixed_depth_iterator::fixed_depth_iterator	tree.hh	/^tree<T, tree_node_allocator>::fixed_depth_iterator::fixed_depth_iterator(const fixed_depth_iterator& other)$/;"	f	class:tree::fixed_depth_iterator	signature:(const fixed_depth_iterator& other)
tree::fixed_depth_iterator::fixed_depth_iterator	tree.hh	/^tree<T, tree_node_allocator>::fixed_depth_iterator::fixed_depth_iterator(const iterator_base& other)$/;"	f	class:tree::fixed_depth_iterator	signature:(const iterator_base& other)
tree::fixed_depth_iterator::fixed_depth_iterator	tree.hh	/^tree<T, tree_node_allocator>::fixed_depth_iterator::fixed_depth_iterator(const sibling_iterator& other)$/;"	f	class:tree::fixed_depth_iterator	signature:(const sibling_iterator& other)
tree::fixed_depth_iterator::fixed_depth_iterator	tree.hh	/^tree<T, tree_node_allocator>::fixed_depth_iterator::fixed_depth_iterator(tree_node *tn)$/;"	f	class:tree::fixed_depth_iterator	signature:(tree_node *tn)
tree::fixed_depth_iterator::operator !=	tree.hh	/^				bool    operator!=(const fixed_depth_iterator&) const;$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(const fixed_depth_iterator&) const
tree::fixed_depth_iterator::operator !=	tree.hh	/^bool tree<T, tree_node_allocator>::fixed_depth_iterator::operator!=(const fixed_depth_iterator& other) const$/;"	f	class:tree::fixed_depth_iterator	signature:(const fixed_depth_iterator& other) const
tree::fixed_depth_iterator::operator ++	tree.hh	/^				fixed_depth_iterator   operator++(int);$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(int)
tree::fixed_depth_iterator::operator ++	tree.hh	/^				fixed_depth_iterator&  operator++();$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:()
tree::fixed_depth_iterator::operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator tree<T, tree_node_allocator>::fixed_depth_iterator::operator++(int)$/;"	f	class:tree::fixed_depth_iterator	signature:(int)
tree::fixed_depth_iterator::operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator& tree<T, tree_node_allocator>::fixed_depth_iterator::operator++()$/;"	f	class:tree::fixed_depth_iterator	signature:()
tree::fixed_depth_iterator::operator +=	tree.hh	/^				fixed_depth_iterator&  operator+=(unsigned int);$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(unsigned int)
tree::fixed_depth_iterator::operator +=	tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator& tree<T, tree_node_allocator>::fixed_depth_iterator::operator+=(unsigned int num)$/;"	f	class:tree::fixed_depth_iterator	signature:(unsigned int num)
tree::fixed_depth_iterator::operator --	tree.hh	/^				fixed_depth_iterator   operator--(int);$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(int)
tree::fixed_depth_iterator::operator --	tree.hh	/^			   fixed_depth_iterator&  operator--();$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:()
tree::fixed_depth_iterator::operator --	tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator tree<T, tree_node_allocator>::fixed_depth_iterator::operator--(int)$/;"	f	class:tree::fixed_depth_iterator	signature:(int)
tree::fixed_depth_iterator::operator --	tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator& tree<T, tree_node_allocator>::fixed_depth_iterator::operator--()$/;"	f	class:tree::fixed_depth_iterator	signature:()
tree::fixed_depth_iterator::operator -=	tree.hh	/^				fixed_depth_iterator&  operator-=(unsigned int);$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(unsigned int)
tree::fixed_depth_iterator::operator -=	tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator& tree<T, tree_node_allocator>::fixed_depth_iterator::operator-=(unsigned int num)$/;"	f	class:tree::fixed_depth_iterator	signature:(unsigned int num)
tree::fixed_depth_iterator::operator ==	tree.hh	/^				bool    operator==(const fixed_depth_iterator&) const;$/;"	p	class:tree::fixed_depth_iterator	access:public	signature:(const fixed_depth_iterator&) const
tree::fixed_depth_iterator::operator ==	tree.hh	/^bool tree<T, tree_node_allocator>::fixed_depth_iterator::operator==(const fixed_depth_iterator& other) const$/;"	f	class:tree::fixed_depth_iterator	signature:(const fixed_depth_iterator& other) const
tree::fixed_depth_iterator::top_node	tree.hh	/^				tree_node *top_node;$/;"	m	class:tree::fixed_depth_iterator	access:public
tree::flatten	tree.hh	/^		template<typename iter> iter flatten(iter position);$/;"	p	class:tree	access:public	signature:(iter position)
tree::flatten	tree.hh	/^iter tree<T, tree_node_allocator>::flatten(iter position)$/;"	f	class:tree	signature:(iter position)
tree::head	tree.hh	/^		tree_node *head, *feet;    \/\/ head\/feet are always dummy; if an iterator points to them it is invalid$/;"	m	class:tree	access:public
tree::head_initialise_	tree.hh	/^		void head_initialise_();$/;"	p	class:tree	access:private	signature:()
tree::head_initialise_	tree.hh	/^void tree<T, tree_node_allocator>::head_initialise_() $/;"	f	class:tree	signature:()
tree::index	tree.hh	/^		unsigned int index(sibling_iterator it) const;$/;"	p	class:tree	access:public	signature:(sibling_iterator it) const
tree::index	tree.hh	/^unsigned int tree<T, tree_node_allocator>::index(sibling_iterator it) const$/;"	f	class:tree	signature:(sibling_iterator it) const
tree::insert	tree.hh	/^		sibling_iterator insert(sibling_iterator position, const T& x);$/;"	p	class:tree	access:public	signature:(sibling_iterator position, const T& x)
tree::insert	tree.hh	/^		template<typename iter> iter insert(iter position, const T& x);$/;"	p	class:tree	access:public	signature:(iter position, const T& x)
tree::insert	tree.hh	/^iter tree<T, tree_node_allocator>::insert(iter position, const T& x)$/;"	f	class:tree	signature:(iter position, const T& x)
tree::insert	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::insert(sibling_iterator position, const T& x)$/;"	f	class:tree	signature:(sibling_iterator position, const T& x)
tree::insert_after	tree.hh	/^		template<typename iter> iter insert_after(iter position, const T& x);$/;"	p	class:tree	access:public	signature:(iter position, const T& x)
tree::insert_after	tree.hh	/^iter tree<T, tree_node_allocator>::insert_after(iter position, const T& x)$/;"	f	class:tree	signature:(iter position, const T& x)
tree::insert_subtree	tree.hh	/^		template<typename iter> iter insert_subtree(iter position, const iterator_base& subtree);$/;"	p	class:tree	access:public	signature:(iter position, const iterator_base& subtree)
tree::insert_subtree	tree.hh	/^iter tree<T, tree_node_allocator>::insert_subtree(iter position, const iterator_base& subtree)$/;"	f	class:tree	signature:(iter position, const iterator_base& subtree)
tree::insert_subtree_after	tree.hh	/^		template<typename iter> iter insert_subtree_after(iter position, const iterator_base& subtree);$/;"	p	class:tree	access:public	signature:(iter position, const iterator_base& subtree)
tree::insert_subtree_after	tree.hh	/^iter tree<T, tree_node_allocator>::insert_subtree_after(iter position, const iterator_base& subtree)$/;"	f	class:tree	signature:(iter position, const iterator_base& subtree)
tree::is_in_subtree	tree.hh	/^		bool     is_in_subtree(const iterator_base& position, const iterator_base& begin, $/;"	p	class:tree	access:public	signature:(const iterator_base& position, const iterator_base& begin, const iterator_base& end) const
tree::is_in_subtree	tree.hh	/^bool tree<T, tree_node_allocator>::is_in_subtree(const iterator_base& it, const iterator_base& begin, $/;"	f	class:tree	signature:(const iterator_base& it, const iterator_base& begin, const iterator_base& end) const
tree::is_valid	tree.hh	/^		bool     is_valid(const iterator_base&) const;$/;"	p	class:tree	access:public	signature:(const iterator_base&) const
tree::is_valid	tree.hh	/^bool tree<T, tree_node_allocator>::is_valid(const iterator_base& it) const$/;"	f	class:tree	signature:(const iterator_base& it) const
tree::iterator	tree.hh	/^		typedef pre_order_iterator            iterator;$/;"	t	class:tree	access:public
tree::iterator_base	tree.hh	/^		class iterator_base : public stlport::bidirectional_iterator<T, ptrdiff_t> {$/;"	c	class:tree	inherits:stlport::bidirectional_iterator	access:public
tree::iterator_base	tree.hh	/^		class iterator_base;$/;"	x
tree::iterator_base::begin	tree.hh	/^				sibling_iterator begin() const;$/;"	p	class:tree::iterator_base	access:public	signature:() const
tree::iterator_base::begin	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::iterator_base::begin() const$/;"	f	class:tree::iterator_base	signature:() const
tree::iterator_base::difference_type	tree.hh	/^				typedef ptrdiff_t                       difference_type;$/;"	t	class:tree::iterator_base	access:public
tree::iterator_base::end	tree.hh	/^				sibling_iterator end() const;$/;"	p	class:tree::iterator_base	access:public	signature:() const
tree::iterator_base::end	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::iterator_base::end() const$/;"	f	class:tree::iterator_base	signature:() const
tree::iterator_base::iterator_base	tree.hh	/^				iterator_base();$/;"	p	class:tree::iterator_base	access:public	signature:()
tree::iterator_base::iterator_base	tree.hh	/^				iterator_base(tree_node *);$/;"	p	class:tree::iterator_base	access:public	signature:(tree_node *)
tree::iterator_base::iterator_base	tree.hh	/^tree<T, tree_node_allocator>::iterator_base::iterator_base()$/;"	f	class:tree::iterator_base	signature:()
tree::iterator_base::iterator_base	tree.hh	/^tree<T, tree_node_allocator>::iterator_base::iterator_base(tree_node *tn)$/;"	f	class:tree::iterator_base	signature:(tree_node *tn)
tree::iterator_base::iterator_category	tree.hh	/^				typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	class:tree::iterator_base	access:public
tree::iterator_base::node	tree.hh	/^				tree_node *node;$/;"	m	class:tree::iterator_base	access:public
tree::iterator_base::number_of_children	tree.hh	/^				unsigned int number_of_children() const;$/;"	p	class:tree::iterator_base	access:public	signature:() const
tree::iterator_base::number_of_children	tree.hh	/^unsigned int tree<T, tree_node_allocator>::iterator_base::number_of_children() const$/;"	f	class:tree::iterator_base	signature:() const
tree::iterator_base::operator *	tree.hh	/^				T&             operator*() const;$/;"	p	class:tree::iterator_base	access:public	signature:() const
tree::iterator_base::operator *	tree.hh	/^T& tree<T, tree_node_allocator>::iterator_base::operator*() const$/;"	f	class:tree::iterator_base	signature:() const
tree::iterator_base::operator ->	tree.hh	/^				T*             operator->() const;$/;"	p	class:tree::iterator_base	access:public	signature:() const
tree::iterator_base::operator ->	tree.hh	/^T* tree<T, tree_node_allocator>::iterator_base::operator->() const$/;"	f	class:tree::iterator_base	signature:() const
tree::iterator_base::pointer	tree.hh	/^				typedef T*                              pointer;$/;"	t	class:tree::iterator_base	access:public
tree::iterator_base::reference	tree.hh	/^				typedef T&                              reference;$/;"	t	class:tree::iterator_base	access:public
tree::iterator_base::size_type	tree.hh	/^				typedef size_t                          size_type;$/;"	t	class:tree::iterator_base	access:public
tree::iterator_base::skip_children	tree.hh	/^				void         skip_children();$/;"	p	class:tree::iterator_base	access:public	signature:()
tree::iterator_base::skip_children	tree.hh	/^				void         skip_children(bool skip);$/;"	p	class:tree::iterator_base	access:public	signature:(bool skip)
tree::iterator_base::skip_children	tree.hh	/^void tree<T, tree_node_allocator>::iterator_base::skip_children()$/;"	f	class:tree::iterator_base	signature:()
tree::iterator_base::skip_children	tree.hh	/^void tree<T, tree_node_allocator>::iterator_base::skip_children(bool skip)$/;"	f	class:tree::iterator_base	signature:(bool skip)
tree::iterator_base::skip_current_children_	tree.hh	/^				bool skip_current_children_;$/;"	m	class:tree::iterator_base	access:protected
tree::iterator_base::value_type	tree.hh	/^				typedef T                               value_type;$/;"	t	class:tree::iterator_base	access:public
tree::iterator_base_less	tree.hh	/^		class iterator_base_less {$/;"	c	class:tree	access:public
tree::iterator_base_less::operator ()	tree.hh	/^				bool operator()(const typename tree<T, tree_node_allocator>::iterator_base& one,$/;"	f	class:tree::iterator_base_less	access:public	signature:(const typename tree<T, tree_node_allocator>::iterator_base& one, const typename tree<T, tree_node_allocator>::iterator_base& two) const
tree::leaf_iterator	tree.hh	/^      class leaf_iterator : public iterator_base {$/;"	c	class:tree	inherits:iterator_base	access:public
tree::leaf_iterator	tree.hh	/^      class leaf_iterator;$/;"	x
tree::leaf_iterator::leaf_iterator	tree.hh	/^            leaf_iterator();$/;"	p	class:tree::leaf_iterator	access:public	signature:()
tree::leaf_iterator::leaf_iterator	tree.hh	/^            leaf_iterator(const iterator_base&);$/;"	p	class:tree::leaf_iterator	access:public	signature:(const iterator_base&)
tree::leaf_iterator::leaf_iterator	tree.hh	/^            leaf_iterator(const sibling_iterator&);$/;"	p	class:tree::leaf_iterator	access:public	signature:(const sibling_iterator&)
tree::leaf_iterator::leaf_iterator	tree.hh	/^            leaf_iterator(tree_node *, tree_node *top=0);$/;"	p	class:tree::leaf_iterator	access:public	signature:(tree_node *, tree_node *top=0)
tree::leaf_iterator::leaf_iterator	tree.hh	/^tree<T, tree_node_allocator>::leaf_iterator::leaf_iterator() $/;"	f	class:tree::leaf_iterator	signature:()
tree::leaf_iterator::leaf_iterator	tree.hh	/^tree<T, tree_node_allocator>::leaf_iterator::leaf_iterator(const iterator_base &other)$/;"	f	class:tree::leaf_iterator	signature:(const iterator_base &other)
tree::leaf_iterator::leaf_iterator	tree.hh	/^tree<T, tree_node_allocator>::leaf_iterator::leaf_iterator(const sibling_iterator& other)$/;"	f	class:tree::leaf_iterator	signature:(const sibling_iterator& other)
tree::leaf_iterator::leaf_iterator	tree.hh	/^tree<T, tree_node_allocator>::leaf_iterator::leaf_iterator(tree_node *tn, tree_node *top)$/;"	f	class:tree::leaf_iterator	signature:(tree_node *tn, tree_node *top)
tree::leaf_iterator::operator !=	tree.hh	/^            bool    operator!=(const leaf_iterator&) const;$/;"	p	class:tree::leaf_iterator	access:public	signature:(const leaf_iterator&) const
tree::leaf_iterator::operator !=	tree.hh	/^bool tree<T, tree_node_allocator>::leaf_iterator::operator!=(const leaf_iterator& other) const$/;"	f	class:tree::leaf_iterator	signature:(const leaf_iterator& other) const
tree::leaf_iterator::operator ++	tree.hh	/^            leaf_iterator   operator++(int);$/;"	p	class:tree::leaf_iterator	access:public	signature:(int)
tree::leaf_iterator::operator ++	tree.hh	/^            leaf_iterator&  operator++();$/;"	p	class:tree::leaf_iterator	access:public	signature:()
tree::leaf_iterator::operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator tree<T, tree_node_allocator>::leaf_iterator::operator++(int)$/;"	f	class:tree::leaf_iterator	signature:(int)
tree::leaf_iterator::operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator& tree<T, tree_node_allocator>::leaf_iterator::operator++()$/;"	f	class:tree::leaf_iterator	signature:()
tree::leaf_iterator::operator +=	tree.hh	/^            leaf_iterator&  operator+=(unsigned int);$/;"	p	class:tree::leaf_iterator	access:public	signature:(unsigned int)
tree::leaf_iterator::operator +=	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator& tree<T, tree_node_allocator>::leaf_iterator::operator+=(unsigned int num)$/;"	f	class:tree::leaf_iterator	signature:(unsigned int num)
tree::leaf_iterator::operator --	tree.hh	/^            leaf_iterator   operator--(int);$/;"	p	class:tree::leaf_iterator	access:public	signature:(int)
tree::leaf_iterator::operator --	tree.hh	/^            leaf_iterator&  operator--();$/;"	p	class:tree::leaf_iterator	access:public	signature:()
tree::leaf_iterator::operator --	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator tree<T, tree_node_allocator>::leaf_iterator::operator--(int)$/;"	f	class:tree::leaf_iterator	signature:(int)
tree::leaf_iterator::operator --	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator& tree<T, tree_node_allocator>::leaf_iterator::operator--()$/;"	f	class:tree::leaf_iterator	signature:()
tree::leaf_iterator::operator -=	tree.hh	/^            leaf_iterator&  operator-=(unsigned int);$/;"	p	class:tree::leaf_iterator	access:public	signature:(unsigned int)
tree::leaf_iterator::operator -=	tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator& tree<T, tree_node_allocator>::leaf_iterator::operator-=(unsigned int num)$/;"	f	class:tree::leaf_iterator	signature:(unsigned int num)
tree::leaf_iterator::operator ==	tree.hh	/^            bool    operator==(const leaf_iterator&) const;$/;"	p	class:tree::leaf_iterator	access:public	signature:(const leaf_iterator&) const
tree::leaf_iterator::operator ==	tree.hh	/^bool tree<T, tree_node_allocator>::leaf_iterator::operator==(const leaf_iterator& other) const$/;"	f	class:tree::leaf_iterator	signature:(const leaf_iterator& other) const
tree::leaf_iterator::top_node	tree.hh	/^				tree_node *top_node;$/;"	m	class:tree::leaf_iterator	access:private
tree::max_depth	tree.hh	/^		int      max_depth() const;$/;"	p	class:tree	access:public	signature:() const
tree::max_depth	tree.hh	/^		int      max_depth(const iterator_base&) const;$/;"	p	class:tree	access:public	signature:(const iterator_base&) const
tree::max_depth	tree.hh	/^int tree<T, tree_node_allocator>::max_depth() const$/;"	f	class:tree	signature:() const
tree::max_depth	tree.hh	/^int tree<T, tree_node_allocator>::max_depth(const iterator_base& pos) const$/;"	f	class:tree	signature:(const iterator_base& pos) const
tree::merge	tree.hh	/^		void     merge(sibling_iterator, sibling_iterator, sibling_iterator, sibling_iterator, $/;"	p	class:tree	access:public	signature:(sibling_iterator, sibling_iterator, sibling_iterator, sibling_iterator, bool duplicate_leaves=false)
tree::merge	tree.hh	/^void tree<T, tree_node_allocator>::merge(sibling_iterator to1,   sibling_iterator to2,$/;"	f	class:tree	signature:(sibling_iterator to1, sibling_iterator to2, sibling_iterator from1, sibling_iterator from2, bool duplicate_leaves)
tree::move_after	tree.hh	/^		template<typename iter> iter move_after(iter target, iter source);$/;"	p	class:tree	access:public	signature:(iter target, iter source)
tree::move_after	tree.hh	/^template <typename iter> iter tree<T, tree_node_allocator>::move_after(iter target, iter source)$/;"	f	class:tree	signature:(iter target, iter source)
tree::move_before	tree.hh	/^      sibling_iterator move_before(sibling_iterator target, sibling_iterator source);$/;"	p	class:tree	access:public	signature:(sibling_iterator target, sibling_iterator source)
tree::move_before	tree.hh	/^      template<typename iter> iter move_before(iter target, iter source);$/;"	p	class:tree	access:public	signature:(iter target, iter source)
tree::move_before	tree.hh	/^template <typename iter> iter tree<T, tree_node_allocator>::move_before(iter target, iter source)$/;"	f	class:tree	signature:(iter target, iter source)
tree::move_before	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::move_before(sibling_iterator target, $/;"	f	class:tree	signature:(sibling_iterator target, sibling_iterator source)
tree::move_ontop	tree.hh	/^		template<typename iter> iter move_ontop(iter target, iter source);$/;"	p	class:tree	access:public	signature:(iter target, iter source)
tree::move_ontop	tree.hh	/^template <typename iter> iter tree<T, tree_node_allocator>::move_ontop(iter target, iter source)$/;"	f	class:tree	signature:(iter target, iter source)
tree::next_at_same_depth	tree.hh	/^		template<typename iter> iter next_at_same_depth(iter) const;$/;"	p	class:tree	access:public	signature:(iter) const
tree::next_at_same_depth	tree.hh	/^iter tree<T, tree_node_allocator>::next_at_same_depth(iter position) const$/;"	f	class:tree	signature:(iter position) const
tree::next_sibling	tree.hh	/^		template<typename iter> iter next_sibling(iter) const;$/;"	p	class:tree	access:public	signature:(iter) const
tree::next_sibling	tree.hh	/^iter tree<T, tree_node_allocator>::next_sibling(iter position) const$/;"	f	class:tree	signature:(iter position) const
tree::number_of_children	tree.hh	/^		static unsigned int number_of_children(const iterator_base&);$/;"	p	class:tree	access:public	signature:(const iterator_base&)
tree::number_of_children	tree.hh	/^unsigned int tree<T, tree_node_allocator>::number_of_children(const iterator_base& it) $/;"	f	class:tree	signature:(const iterator_base& it)
tree::number_of_siblings	tree.hh	/^		unsigned int number_of_siblings(const iterator_base&) const;$/;"	p	class:tree	access:public	signature:(const iterator_base&) const
tree::number_of_siblings	tree.hh	/^unsigned int tree<T, tree_node_allocator>::number_of_siblings(const iterator_base& it) const$/;"	f	class:tree	signature:(const iterator_base& it) const
tree::operator =	tree.hh	/^		void operator=(const tree<T, tree_node_allocator>&);$/;"	p	class:tree	access:public	signature:(const tree<T, tree_node_allocator>&)
tree::operator =	tree.hh	/^void tree<T, tree_node_allocator>::operator=(const tree<T, tree_node_allocator>& other)$/;"	f	class:tree	signature:(const tree<T, tree_node_allocator>& other)
tree::parent	tree.hh	/^		template<typename	iter> static iter parent(iter);$/;"	p	class:tree	access:public	signature:(iter)
tree::parent	tree.hh	/^iter tree<T, tree_node_allocator>::parent(iter position) $/;"	f	class:tree	signature:(iter position)
tree::post_order_iterator	tree.hh	/^		class post_order_iterator : public iterator_base {$/;"	c	class:tree	inherits:iterator_base	access:public
tree::post_order_iterator	tree.hh	/^		class post_order_iterator;$/;"	x
tree::post_order_iterator::descend_all	tree.hh	/^				void descend_all();$/;"	p	class:tree::post_order_iterator	access:public	signature:()
tree::post_order_iterator::descend_all	tree.hh	/^void tree<T, tree_node_allocator>::post_order_iterator::descend_all()$/;"	f	class:tree::post_order_iterator	signature:()
tree::post_order_iterator::operator !=	tree.hh	/^				bool    operator!=(const post_order_iterator&) const;$/;"	p	class:tree::post_order_iterator	access:public	signature:(const post_order_iterator&) const
tree::post_order_iterator::operator !=	tree.hh	/^bool tree<T, tree_node_allocator>::post_order_iterator::operator!=(const post_order_iterator& other) const$/;"	f	class:tree::post_order_iterator	signature:(const post_order_iterator& other) const
tree::post_order_iterator::operator ++	tree.hh	/^				post_order_iterator   operator++(int);$/;"	p	class:tree::post_order_iterator	access:public	signature:(int)
tree::post_order_iterator::operator ++	tree.hh	/^				post_order_iterator&  operator++();$/;"	p	class:tree::post_order_iterator	access:public	signature:()
tree::post_order_iterator::operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator tree<T, tree_node_allocator>::post_order_iterator::operator++(int)$/;"	f	class:tree::post_order_iterator	signature:(int)
tree::post_order_iterator::operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator& tree<T, tree_node_allocator>::post_order_iterator::operator++()$/;"	f	class:tree::post_order_iterator	signature:()
tree::post_order_iterator::operator +=	tree.hh	/^				post_order_iterator&  operator+=(unsigned int);$/;"	p	class:tree::post_order_iterator	access:public	signature:(unsigned int)
tree::post_order_iterator::operator +=	tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator& tree<T, tree_node_allocator>::post_order_iterator::operator+=(unsigned int num)$/;"	f	class:tree::post_order_iterator	signature:(unsigned int num)
tree::post_order_iterator::operator --	tree.hh	/^				post_order_iterator   operator--(int);$/;"	p	class:tree::post_order_iterator	access:public	signature:(int)
tree::post_order_iterator::operator --	tree.hh	/^			   post_order_iterator&  operator--();$/;"	p	class:tree::post_order_iterator	access:public	signature:()
tree::post_order_iterator::operator --	tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator tree<T, tree_node_allocator>::post_order_iterator::operator--(int)$/;"	f	class:tree::post_order_iterator	signature:(int)
tree::post_order_iterator::operator --	tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator& tree<T, tree_node_allocator>::post_order_iterator::operator--()$/;"	f	class:tree::post_order_iterator	signature:()
tree::post_order_iterator::operator -=	tree.hh	/^				post_order_iterator&  operator-=(unsigned int);$/;"	p	class:tree::post_order_iterator	access:public	signature:(unsigned int)
tree::post_order_iterator::operator -=	tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator& tree<T, tree_node_allocator>::post_order_iterator::operator-=(unsigned int num)$/;"	f	class:tree::post_order_iterator	signature:(unsigned int num)
tree::post_order_iterator::operator ==	tree.hh	/^				bool    operator==(const post_order_iterator&) const;$/;"	p	class:tree::post_order_iterator	access:public	signature:(const post_order_iterator&) const
tree::post_order_iterator::operator ==	tree.hh	/^bool tree<T, tree_node_allocator>::post_order_iterator::operator==(const post_order_iterator& other) const$/;"	f	class:tree::post_order_iterator	signature:(const post_order_iterator& other) const
tree::post_order_iterator::post_order_iterator	tree.hh	/^				post_order_iterator();$/;"	p	class:tree::post_order_iterator	access:public	signature:()
tree::post_order_iterator::post_order_iterator	tree.hh	/^				post_order_iterator(const iterator_base&);$/;"	p	class:tree::post_order_iterator	access:public	signature:(const iterator_base&)
tree::post_order_iterator::post_order_iterator	tree.hh	/^				post_order_iterator(const sibling_iterator&);$/;"	p	class:tree::post_order_iterator	access:public	signature:(const sibling_iterator&)
tree::post_order_iterator::post_order_iterator	tree.hh	/^				post_order_iterator(tree_node *);$/;"	p	class:tree::post_order_iterator	access:public	signature:(tree_node *)
tree::post_order_iterator::post_order_iterator	tree.hh	/^tree<T, tree_node_allocator>::post_order_iterator::post_order_iterator() $/;"	f	class:tree::post_order_iterator	signature:()
tree::post_order_iterator::post_order_iterator	tree.hh	/^tree<T, tree_node_allocator>::post_order_iterator::post_order_iterator(const iterator_base &other)$/;"	f	class:tree::post_order_iterator	signature:(const iterator_base &other)
tree::post_order_iterator::post_order_iterator	tree.hh	/^tree<T, tree_node_allocator>::post_order_iterator::post_order_iterator(const sibling_iterator& other)$/;"	f	class:tree::post_order_iterator	signature:(const sibling_iterator& other)
tree::post_order_iterator::post_order_iterator	tree.hh	/^tree<T, tree_node_allocator>::post_order_iterator::post_order_iterator(tree_node *tn)$/;"	f	class:tree::post_order_iterator	signature:(tree_node *tn)
tree::pre_order_iterator	tree.hh	/^		class pre_order_iterator : public iterator_base { $/;"	c	class:tree	inherits:iterator_base	access:public
tree::pre_order_iterator	tree.hh	/^		class pre_order_iterator;$/;"	x
tree::pre_order_iterator::operator !=	tree.hh	/^				bool    operator!=(const pre_order_iterator&) const;$/;"	p	class:tree::pre_order_iterator	access:public	signature:(const pre_order_iterator&) const
tree::pre_order_iterator::operator !=	tree.hh	/^bool tree<T, tree_node_allocator>::pre_order_iterator::operator!=(const pre_order_iterator& other) const$/;"	f	class:tree::pre_order_iterator	signature:(const pre_order_iterator& other) const
tree::pre_order_iterator::operator ++	tree.hh	/^				pre_order_iterator   operator++(int);$/;"	p	class:tree::pre_order_iterator	access:public	signature:(int)
tree::pre_order_iterator::operator ++	tree.hh	/^				pre_order_iterator&  operator++();$/;"	p	class:tree::pre_order_iterator	access:public	signature:()
tree::pre_order_iterator::operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator tree<T, tree_node_allocator>::pre_order_iterator::operator++(int)$/;"	f	class:tree::pre_order_iterator	signature:(int)
tree::pre_order_iterator::operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator& tree<T, tree_node_allocator>::pre_order_iterator::operator++()$/;"	f	class:tree::pre_order_iterator	signature:()
tree::pre_order_iterator::operator +=	tree.hh	/^				pre_order_iterator&  operator+=(unsigned int);$/;"	p	class:tree::pre_order_iterator	access:public	signature:(unsigned int)
tree::pre_order_iterator::operator +=	tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator& tree<T, tree_node_allocator>::pre_order_iterator::operator+=(unsigned int num)$/;"	f	class:tree::pre_order_iterator	signature:(unsigned int num)
tree::pre_order_iterator::operator --	tree.hh	/^				pre_order_iterator   operator--(int);$/;"	p	class:tree::pre_order_iterator	access:public	signature:(int)
tree::pre_order_iterator::operator --	tree.hh	/^			   pre_order_iterator&  operator--();$/;"	p	class:tree::pre_order_iterator	access:public	signature:()
tree::pre_order_iterator::operator --	tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator tree<T, tree_node_allocator>::pre_order_iterator::operator--(int)$/;"	f	class:tree::pre_order_iterator	signature:(int)
tree::pre_order_iterator::operator --	tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator& tree<T, tree_node_allocator>::pre_order_iterator::operator--()$/;"	f	class:tree::pre_order_iterator	signature:()
tree::pre_order_iterator::operator -=	tree.hh	/^				pre_order_iterator&  operator-=(unsigned int);$/;"	p	class:tree::pre_order_iterator	access:public	signature:(unsigned int)
tree::pre_order_iterator::operator -=	tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator& tree<T, tree_node_allocator>::pre_order_iterator::operator-=(unsigned int num)$/;"	f	class:tree::pre_order_iterator	signature:(unsigned int num)
tree::pre_order_iterator::operator ==	tree.hh	/^				bool    operator==(const pre_order_iterator&) const;$/;"	p	class:tree::pre_order_iterator	access:public	signature:(const pre_order_iterator&) const
tree::pre_order_iterator::operator ==	tree.hh	/^bool tree<T, tree_node_allocator>::pre_order_iterator::operator==(const pre_order_iterator& other) const$/;"	f	class:tree::pre_order_iterator	signature:(const pre_order_iterator& other) const
tree::pre_order_iterator::pre_order_iterator	tree.hh	/^				pre_order_iterator();$/;"	p	class:tree::pre_order_iterator	access:public	signature:()
tree::pre_order_iterator::pre_order_iterator	tree.hh	/^				pre_order_iterator(const iterator_base&);$/;"	p	class:tree::pre_order_iterator	access:public	signature:(const iterator_base&)
tree::pre_order_iterator::pre_order_iterator	tree.hh	/^				pre_order_iterator(const sibling_iterator&);$/;"	p	class:tree::pre_order_iterator	access:public	signature:(const sibling_iterator&)
tree::pre_order_iterator::pre_order_iterator	tree.hh	/^				pre_order_iterator(tree_node *);$/;"	p	class:tree::pre_order_iterator	access:public	signature:(tree_node *)
tree::pre_order_iterator::pre_order_iterator	tree.hh	/^tree<T, tree_node_allocator>::pre_order_iterator::pre_order_iterator() $/;"	f	class:tree::pre_order_iterator	signature:()
tree::pre_order_iterator::pre_order_iterator	tree.hh	/^tree<T, tree_node_allocator>::pre_order_iterator::pre_order_iterator(const iterator_base &other)$/;"	f	class:tree::pre_order_iterator	signature:(const iterator_base &other)
tree::pre_order_iterator::pre_order_iterator	tree.hh	/^tree<T, tree_node_allocator>::pre_order_iterator::pre_order_iterator(const sibling_iterator& other)$/;"	f	class:tree::pre_order_iterator	signature:(const sibling_iterator& other)
tree::pre_order_iterator::pre_order_iterator	tree.hh	/^tree<T, tree_node_allocator>::pre_order_iterator::pre_order_iterator(tree_node *tn)$/;"	f	class:tree::pre_order_iterator	signature:(tree_node *tn)
tree::prepend_child	tree.hh	/^		template<typename iter> iter prepend_child(iter position); $/;"	p	class:tree	access:public	signature:(iter position)
tree::prepend_child	tree.hh	/^		template<typename iter> iter prepend_child(iter position, const T& x);$/;"	p	class:tree	access:public	signature:(iter position, const T& x)
tree::prepend_child	tree.hh	/^		template<typename iter> iter prepend_child(iter position, iter other_position);$/;"	p	class:tree	access:public	signature:(iter position, iter other_position)
tree::prepend_child	tree.hh	/^iter tree<T, tree_node_allocator>::prepend_child(iter position)$/;"	f	class:tree	signature:(iter position)
tree::prepend_child	tree.hh	/^iter tree<T, tree_node_allocator>::prepend_child(iter position, const T& x)$/;"	f	class:tree	signature:(iter position, const T& x)
tree::prepend_child	tree.hh	/^iter tree<T, tree_node_allocator>::prepend_child(iter position, iter other)$/;"	f	class:tree	signature:(iter position, iter other)
tree::prepend_children	tree.hh	/^		template<typename iter> iter prepend_children(iter position, sibling_iterator from, sibling_iterator to);$/;"	p	class:tree	access:public	signature:(iter position, sibling_iterator from, sibling_iterator to)
tree::prepend_children	tree.hh	/^iter tree<T, tree_node_allocator>::prepend_children(iter position, sibling_iterator from, sibling_iterator to)$/;"	f	class:tree	signature:(iter position, sibling_iterator from, sibling_iterator to)
tree::previous_sibling	tree.hh	/^		template<typename iter> iter previous_sibling(iter) const;$/;"	p	class:tree	access:public	signature:(iter) const
tree::previous_sibling	tree.hh	/^iter tree<T, tree_node_allocator>::previous_sibling(iter position) const$/;"	f	class:tree	signature:(iter position) const
tree::reparent	tree.hh	/^		template<typename iter> iter reparent(iter position, iter from);$/;"	p	class:tree	access:public	signature:(iter position, iter from)
tree::reparent	tree.hh	/^		template<typename iter> iter reparent(iter position, sibling_iterator begin, sibling_iterator end);$/;"	p	class:tree	access:public	signature:(iter position, sibling_iterator begin, sibling_iterator end)
tree::reparent	tree.hh	/^iter tree<T, tree_node_allocator>::reparent(iter position, sibling_iterator begin, sibling_iterator end)$/;"	f	class:tree	signature:(iter position, sibling_iterator begin, sibling_iterator end)
tree::reparent	tree.hh	/^template <typename iter> iter tree<T, tree_node_allocator>::reparent(iter position, iter from)$/;"	f	class:tree	signature:(iter position, iter from)
tree::replace	tree.hh	/^		sibling_iterator replace(sibling_iterator orig_begin, sibling_iterator orig_end, $/;"	p	class:tree	access:public	signature:(sibling_iterator orig_begin, sibling_iterator orig_end, sibling_iterator new_begin, sibling_iterator new_end)
tree::replace	tree.hh	/^		template<typename iter> iter replace(iter position, const T& x);$/;"	p	class:tree	access:public	signature:(iter position, const T& x)
tree::replace	tree.hh	/^		template<typename iter> iter replace(iter position, const iterator_base& from);$/;"	p	class:tree	access:public	signature:(iter position, const iterator_base& from)
tree::replace	tree.hh	/^iter tree<T, tree_node_allocator>::replace(iter position, const T& x)$/;"	f	class:tree	signature:(iter position, const T& x)
tree::replace	tree.hh	/^iter tree<T, tree_node_allocator>::replace(iter position, const iterator_base& from)$/;"	f	class:tree	signature:(iter position, const iterator_base& from)
tree::replace	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::replace($/;"	f	class:tree	signature:( sibling_iterator orig_begin, sibling_iterator orig_end, sibling_iterator new_begin, sibling_iterator new_end)
tree::set_head	tree.hh	/^		pre_order_iterator set_head(const T& x);$/;"	p	class:tree	access:public	signature:(const T& x)
tree::set_head	tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator tree<T, tree_node_allocator>::set_head(const T& x)$/;"	f	class:tree	signature:(const T& x)
tree::sibling	tree.hh	/^		sibling_iterator sibling(const iterator_base& position, unsigned int);  				$/;"	p	class:tree	access:public	signature:(const iterator_base& position, unsigned int)
tree::sibling	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::sibling(const iterator_base& it, unsigned int num)$/;"	f	class:tree	signature:(const iterator_base& it, unsigned int num)
tree::sibling_iterator	tree.hh	/^		class sibling_iterator : public iterator_base {$/;"	c	class:tree	inherits:iterator_base	access:public
tree::sibling_iterator	tree.hh	/^		class sibling_iterator;$/;"	x
tree::sibling_iterator::operator !=	tree.hh	/^				bool    operator!=(const sibling_iterator&) const;$/;"	p	class:tree::sibling_iterator	access:public	signature:(const sibling_iterator&) const
tree::sibling_iterator::operator !=	tree.hh	/^bool tree<T, tree_node_allocator>::sibling_iterator::operator!=(const sibling_iterator& other) const$/;"	f	class:tree::sibling_iterator	signature:(const sibling_iterator& other) const
tree::sibling_iterator::operator ++	tree.hh	/^				sibling_iterator   operator++(int);$/;"	p	class:tree::sibling_iterator	access:public	signature:(int)
tree::sibling_iterator::operator ++	tree.hh	/^				sibling_iterator&  operator++();$/;"	p	class:tree::sibling_iterator	access:public	signature:()
tree::sibling_iterator::operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::sibling_iterator::operator++(int)$/;"	f	class:tree::sibling_iterator	signature:(int)
tree::sibling_iterator::operator ++	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator& tree<T, tree_node_allocator>::sibling_iterator::operator++()$/;"	f	class:tree::sibling_iterator	signature:()
tree::sibling_iterator::operator +=	tree.hh	/^				sibling_iterator&  operator+=(unsigned int);$/;"	p	class:tree::sibling_iterator	access:public	signature:(unsigned int)
tree::sibling_iterator::operator +=	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator& tree<T, tree_node_allocator>::sibling_iterator::operator+=(unsigned int num)$/;"	f	class:tree::sibling_iterator	signature:(unsigned int num)
tree::sibling_iterator::operator --	tree.hh	/^				sibling_iterator   operator--(int);$/;"	p	class:tree::sibling_iterator	access:public	signature:(int)
tree::sibling_iterator::operator --	tree.hh	/^				sibling_iterator&  operator--();$/;"	p	class:tree::sibling_iterator	access:public	signature:()
tree::sibling_iterator::operator --	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::sibling_iterator::operator--(int)$/;"	f	class:tree::sibling_iterator	signature:(int)
tree::sibling_iterator::operator --	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator& tree<T, tree_node_allocator>::sibling_iterator::operator--()$/;"	f	class:tree::sibling_iterator	signature:()
tree::sibling_iterator::operator -=	tree.hh	/^				sibling_iterator&  operator-=(unsigned int);$/;"	p	class:tree::sibling_iterator	access:public	signature:(unsigned int)
tree::sibling_iterator::operator -=	tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator& tree<T, tree_node_allocator>::sibling_iterator::operator-=(unsigned int num)$/;"	f	class:tree::sibling_iterator	signature:(unsigned int num)
tree::sibling_iterator::operator ==	tree.hh	/^				bool    operator==(const sibling_iterator&) const;$/;"	p	class:tree::sibling_iterator	access:public	signature:(const sibling_iterator&) const
tree::sibling_iterator::operator ==	tree.hh	/^bool tree<T, tree_node_allocator>::sibling_iterator::operator==(const sibling_iterator& other) const$/;"	f	class:tree::sibling_iterator	signature:(const sibling_iterator& other) const
tree::sibling_iterator::parent_	tree.hh	/^				tree_node *parent_;$/;"	m	class:tree::sibling_iterator	access:public
tree::sibling_iterator::range_first	tree.hh	/^				tree_node *range_first() const;$/;"	p	class:tree::sibling_iterator	access:public	signature:() const
tree::sibling_iterator::range_first	tree.hh	/^typename tree<T, tree_node_allocator>::tree_node *tree<T, tree_node_allocator>::sibling_iterator::range_first() const$/;"	f	class:tree::sibling_iterator	signature:() const
tree::sibling_iterator::range_last	tree.hh	/^				tree_node *range_last() const;$/;"	p	class:tree::sibling_iterator	access:public	signature:() const
tree::sibling_iterator::range_last	tree.hh	/^typename tree<T, tree_node_allocator>::tree_node *tree<T, tree_node_allocator>::sibling_iterator::range_last() const$/;"	f	class:tree::sibling_iterator	signature:() const
tree::sibling_iterator::set_parent_	tree.hh	/^				void set_parent_();$/;"	p	class:tree::sibling_iterator	access:private	signature:()
tree::sibling_iterator::set_parent_	tree.hh	/^void tree<T, tree_node_allocator>::sibling_iterator::set_parent_()$/;"	f	class:tree::sibling_iterator	signature:()
tree::sibling_iterator::sibling_iterator	tree.hh	/^				sibling_iterator();$/;"	p	class:tree::sibling_iterator	access:public	signature:()
tree::sibling_iterator::sibling_iterator	tree.hh	/^				sibling_iterator(const iterator_base&);$/;"	p	class:tree::sibling_iterator	access:public	signature:(const iterator_base&)
tree::sibling_iterator::sibling_iterator	tree.hh	/^				sibling_iterator(const sibling_iterator&);$/;"	p	class:tree::sibling_iterator	access:public	signature:(const sibling_iterator&)
tree::sibling_iterator::sibling_iterator	tree.hh	/^				sibling_iterator(tree_node *);$/;"	p	class:tree::sibling_iterator	access:public	signature:(tree_node *)
tree::sibling_iterator::sibling_iterator	tree.hh	/^tree<T, tree_node_allocator>::sibling_iterator::sibling_iterator() $/;"	f	class:tree::sibling_iterator	signature:()
tree::sibling_iterator::sibling_iterator	tree.hh	/^tree<T, tree_node_allocator>::sibling_iterator::sibling_iterator(const iterator_base& other)$/;"	f	class:tree::sibling_iterator	signature:(const iterator_base& other)
tree::sibling_iterator::sibling_iterator	tree.hh	/^tree<T, tree_node_allocator>::sibling_iterator::sibling_iterator(const sibling_iterator& other)$/;"	f	class:tree::sibling_iterator	signature:(const sibling_iterator& other)
tree::sibling_iterator::sibling_iterator	tree.hh	/^tree<T, tree_node_allocator>::sibling_iterator::sibling_iterator(tree_node *tn)$/;"	f	class:tree::sibling_iterator	signature:(tree_node *tn)
tree::size	tree.hh	/^		size_t   size() const;$/;"	p	class:tree	access:public	signature:() const
tree::size	tree.hh	/^		size_t   size(const iterator_base&) const;$/;"	p	class:tree	access:public	signature:(const iterator_base&) const
tree::size	tree.hh	/^size_t tree<T, tree_node_allocator>::size() const$/;"	f	class:tree	signature:() const
tree::size	tree.hh	/^size_t tree<T, tree_node_allocator>::size(const iterator_base& top) const$/;"	f	class:tree	signature:(const iterator_base& top) const
tree::sort	tree.hh	/^		void     sort(sibling_iterator from, sibling_iterator to, StrictWeakOrdering comp, bool deep=false);$/;"	p	class:tree	access:public	signature:(sibling_iterator from, sibling_iterator to, StrictWeakOrdering comp, bool deep=false)
tree::sort	tree.hh	/^		void     sort(sibling_iterator from, sibling_iterator to, bool deep=false);$/;"	p	class:tree	access:public	signature:(sibling_iterator from, sibling_iterator to, bool deep=false)
tree::sort	tree.hh	/^void tree<T, tree_node_allocator>::sort(sibling_iterator from, sibling_iterator to, $/;"	f	class:tree	signature:(sibling_iterator from, sibling_iterator to, StrictWeakOrdering comp, bool deep)
tree::sort	tree.hh	/^void tree<T, tree_node_allocator>::sort(sibling_iterator from, sibling_iterator to, bool deep)$/;"	f	class:tree	signature:(sibling_iterator from, sibling_iterator to, bool deep)
tree::subtree	tree.hh	/^		tree     subtree(sibling_iterator from, sibling_iterator to) const;$/;"	p	class:tree	access:public	signature:(sibling_iterator from, sibling_iterator to) const
tree::subtree	tree.hh	/^		void     subtree(tree&, sibling_iterator from, sibling_iterator to) const;$/;"	p	class:tree	access:public	signature:(tree&, sibling_iterator from, sibling_iterator to) const
tree::subtree	tree.hh	/^tree<T, tree_node_allocator> tree<T, tree_node_allocator>::subtree(sibling_iterator from, sibling_iterator to) const$/;"	f	class:tree	signature:(sibling_iterator from, sibling_iterator to) const
tree::subtree	tree.hh	/^void tree<T, tree_node_allocator>::subtree(tree& tmp, sibling_iterator from, sibling_iterator to) const$/;"	f	class:tree	signature:(tree& tmp, sibling_iterator from, sibling_iterator to) const
tree::swap	tree.hh	/^		void     swap(sibling_iterator it);$/;"	p	class:tree	access:public	signature:(sibling_iterator it)
tree::swap	tree.hh	/^	   void     swap(iterator, iterator);$/;"	p	class:tree	access:public	signature:(iterator, iterator)
tree::swap	tree.hh	/^void tree<T, tree_node_allocator>::swap(iterator one, iterator two)$/;"	f	class:tree	signature:(iterator one, iterator two)
tree::swap	tree.hh	/^void tree<T, tree_node_allocator>::swap(sibling_iterator it)$/;"	f	class:tree	signature:(sibling_iterator it)
tree::tree	tree.hh	/^		tree();$/;"	p	class:tree	access:public	signature:()
tree::tree	tree.hh	/^		tree(const T&);$/;"	p	class:tree	access:public	signature:(const T&)
tree::tree	tree.hh	/^		tree(const iterator_base&);$/;"	p	class:tree	access:public	signature:(const iterator_base&)
tree::tree	tree.hh	/^		tree(const tree<T, tree_node_allocator>&);$/;"	p	class:tree	access:public	signature:(const tree<T, tree_node_allocator>&)
tree::tree	tree.hh	/^tree<T, tree_node_allocator>::tree() $/;"	f	class:tree	signature:()
tree::tree	tree.hh	/^tree<T, tree_node_allocator>::tree(const T& x) $/;"	f	class:tree	signature:(const T& x)
tree::tree	tree.hh	/^tree<T, tree_node_allocator>::tree(const iterator_base& other)$/;"	f	class:tree	signature:(const iterator_base& other)
tree::tree	tree.hh	/^tree<T, tree_node_allocator>::tree(const tree<T, tree_node_allocator>& other)$/;"	f	class:tree	signature:(const tree<T, tree_node_allocator>& other)
tree::tree_node	tree.hh	/^		typedef tree_node_<T> tree_node;$/;"	t	class:tree	access:protected
tree::value_type	tree.hh	/^		typedef T value_type;$/;"	t	class:tree	access:public
tree::wrap	tree.hh	/^		template<typename iter> iter wrap(iter position, const T& x);$/;"	p	class:tree	access:public	signature:(iter position, const T& x)
tree::wrap	tree.hh	/^template <typename iter> iter tree<T, tree_node_allocator>::wrap(iter position, const T& x)$/;"	f	class:tree	signature:(iter position, const T& x)
tree::~tree	tree.hh	/^		~tree();$/;"	p	class:tree	access:public	signature:()
tree::~tree	tree.hh	/^tree<T, tree_node_allocator>::~tree()$/;"	f	class:tree	signature:()
tree_	octree.h	/^    OcTree< CoordType, ValueType >* tree_;$/;"	m	class:spatialaggregate::OcTreeNode	access:public
tree_hh_	tree.hh	25;"	d
tree_node	tree.hh	/^		typedef tree_node_<T> tree_node;$/;"	t	class:tree	access:protected
tree_node_	tree.hh	/^class tree_node_ { \/\/ size: 5*4=20 bytes (on 32 bit arch), can be reduced by 8.$/;"	c
tree_node_::data	tree.hh	/^		T data;$/;"	m	class:tree_node_	access:public
tree_node_::first_child	tree.hh	/^	   tree_node_<T> *first_child, *last_child;$/;"	m	class:tree_node_	access:public
tree_node_::last_child	tree.hh	/^	   tree_node_<T> *first_child, *last_child;$/;"	m	class:tree_node_	access:public
tree_node_::next_sibling	tree.hh	/^		tree_node_<T> *prev_sibling, *next_sibling;$/;"	m	class:tree_node_	access:public
tree_node_::parent	tree.hh	/^		tree_node_<T> *parent;$/;"	m	class:tree_node_	access:public
tree_node_::prev_sibling	tree.hh	/^		tree_node_<T> *prev_sibling, *next_sibling;$/;"	m	class:tree_node_	access:public
tree_util_hh_	tree_util.hh	28;"	d
trim	ConfigFile.cpp	/^void ConfigFile::trim( string& s )$/;"	f	class:ConfigFile	signature:( string& s )
trim	ConfigFile.h	/^	static void trim( string& s );$/;"	p	class:ConfigFile	access:protected	signature:( string& s )
trim_left	XYUtility.h	/^	static char *trim_left( char *szSource );$/;"	p	class:CXYUtility	access:public	signature:( char *szSource )
trim_right	XYUtility.h	/^	static char *trim_right( char *szSource );$/;"	p	class:CXYUtility	access:public	signature:( char *szSource )
twist	MersenneTwister.h	/^	uint32 twist( const uint32 m, const uint32 s0, const uint32 s1 ) const$/;"	f	class:MTRand	access:protected	signature:( const uint32 m, const uint32 s0, const uint32 s1 ) const
type_	octree.h	/^    OcTreeNodeType type_;$/;"	m	class:spatialaggregate::OcTreeNode	access:public
uint32	MersenneTwister.h	/^	typedef unsigned long uint32;  \/\/ unsigned integer type, at least 32 bits$/;"	t	class:MTRand	access:public
value_	octree.h	/^    ValueType value_;$/;"	m	class:spatialaggregate::OcTreeNode	access:public
value_type	tree.hh	/^				typedef T                               value_type;$/;"	t	class:tree::iterator_base	access:public
value_type	tree.hh	/^		typedef T value_type;$/;"	t	class:tree	access:public
volumeSizeForDepth	octree.h	/^    inline CoordType volumeSizeForDepth( int depth ) {$/;"	f	class:spatialaggregate::OcTree	access:public	signature:( int depth )
w	XYSO3Sequence.h	/^	double w;$/;"	m	struct:Quaternion	access:public
wrap	tree.hh	/^		template<typename iter> iter wrap(iter position, const T& x);$/;"	p	class:tree	access:public	signature:(iter position, const T& x)
wrap	tree.hh	/^template <typename iter> iter tree<T, tree_node_allocator>::wrap(iter position, const T& x)$/;"	f	class:tree	signature:(iter position, const T& x)
x	XYSO3Sequence.h	/^	double x;$/;"	m	struct:Quaternion	access:public
x_	octree.h	/^    uint32_t x_, y_, z_;$/;"	m	class:spatialaggregate::OcTreeKey	access:public
y	XYSO3Sequence.h	/^	double y;$/;"	m	struct:Quaternion	access:public
y_	octree.h	/^    uint32_t x_, y_, z_;$/;"	m	class:spatialaggregate::OcTreeKey	access:public
z	XYSO3Sequence.h	/^	double z;$/;"	m	struct:Quaternion	access:public
z_	octree.h	/^    uint32_t x_, y_, z_;$/;"	m	class:spatialaggregate::OcTreeKey	access:public
~CXYEigen	XYEigen.cpp	/^CXYEigen<Real>::~CXYEigen ()$/;"	f	class:CXYEigen	signature:()
~CXYEigen	XYEigen.h	/^	~CXYEigen(void);$/;"	p	class:CXYEigen	access:public	signature:(void)
~CXYEnsemble	XYEnsemble.cpp	/^CXYEnsemble::~CXYEnsemble(void)$/;"	f	class:CXYEnsemble	signature:(void)
~CXYEnsemble	XYEnsemble.h	/^	~CXYEnsemble(void);$/;"	p	class:CXYEnsemble	access:public	signature:(void)
~CXYFile	XYFile.cpp	/^CXYFile::~CXYFile(void)$/;"	f	class:CXYFile	signature:(void)
~CXYFile	XYFile.h	/^	~CXYFile(void);$/;"	p	class:CXYFile	access:public	signature:(void)
~CXYLapackEigen	XYLapack.cpp	/^CXYLapackEigen<Real>::~CXYLapackEigen ()$/;"	f	class:CXYLapackEigen	signature:()
~CXYLapackEigen	XYLapack.h	/^	~CXYLapackEigen(void);$/;"	p	class:CXYLapackEigen	access:public	signature:(void)
~CXYMath	XYMath.h	/^	~CXYMath(void);$/;"	p	class:CXYMath	access:public	signature:(void)
~CXYMath	XYMath.inl	/^CXYMath<Real>::~CXYMath(void)$/;"	f	class:CXYMath	signature:(void)
~CXYMatrix	XYMatrix.h	/^	~CXYMatrix(void);$/;"	p	class:CXYMatrix	access:public	signature:(void)
~CXYMatrix	XYMatrix.inl	/^CXYMatrix<Real>::~CXYMatrix ()$/;"	f	class:CXYMatrix	signature:()
~CXYPDB	XYPDB.cpp	/^CXYPDB::~CXYPDB(void)$/;"	f	class:CXYPDB	signature:(void)
~CXYPDB	XYPDB.h	/^	~CXYPDB(void);$/;"	p	class:CXYPDB	access:public	signature:(void)
~CXYPDBAtom	XYPDBAtom.cpp	/^CXYPDBAtom::~CXYPDBAtom(void)$/;"	f	class:CXYPDBAtom	signature:(void)
~CXYPDBAtom	XYPDBAtom.h	/^	~CXYPDBAtom(void);$/;"	p	class:CXYPDBAtom	access:public	signature:(void)
~CXYPoint3D	XYPoint3D.h	/^	~CXYPoint3D(void);$/;"	p	class:CXYPoint3D	access:public	signature:(void)
~CXYPoint3D	XYPoint3D.inl	/^CXYPoint3D<Real>::~CXYPoint3D(void)$/;"	f	class:CXYPoint3D	signature:(void)
~CXYSIS	XYSIS.cpp	/^CXYSIS::~CXYSIS(void)$/;"	f	class:CXYSIS	signature:(void)
~CXYSIS	XYSIS.h	/^  ~CXYSIS(void);$/;"	p	class:CXYSIS	access:public	signature:(void)
~CXYSO3Sequence	XYSO3Sequence.cpp	/^CXYSO3Sequence::~CXYSO3Sequence(){$/;"	f	class:CXYSO3Sequence	signature:()
~CXYSO3Sequence	XYSO3Sequence.h	/^	~CXYSO3Sequence(void);$/;"	p	class:CXYSO3Sequence	access:public	signature:(void)
~CXYUtility	XYUtility.cpp	/^CXYUtility::~CXYUtility(void)$/;"	f	class:CXYUtility	signature:(void)
~CXYUtility	XYUtility.h	/^	~CXYUtility(void);$/;"	p	class:CXYUtility	access:public	signature:(void)
~CXYVector	XYVector.h	/^	~CXYVector(void);$/;"	p	class:CXYVector	access:public	signature:(void)
~CXYVector	XYVector.inl	/^CXYVector<Real>::~CXYVector(void)$/;"	f	class:CXYVector	signature:(void)
~DynamicAllocator	octree.h	/^    ~DynamicAllocator() {$/;"	f	class:spatialaggregate::DynamicAllocator	access:public	signature:()
~OcTree	octree.h	/^    ~OcTree();$/;"	p	class:spatialaggregate::OcTree	access:public	signature:()
~OcTree	octree.hpp	/^spatialaggregate::OcTree< CoordType, ValueType >::~OcTree() {$/;"	f	class:spatialaggregate::OcTree	signature:()
~OcTreeKey	octree.h	/^    ~OcTreeKey() {}$/;"	f	class:spatialaggregate::OcTreeKey	access:public	signature:()
~OcTreeNode	octree.h	/^    ~OcTreeNode() {$/;"	f	class:spatialaggregate::OcTreeNode	access:public	signature:()
~OcTreeNodeAllocator	octree.h	/^    virtual ~OcTreeNodeAllocator() {}$/;"	f	class:spatialaggregate::OcTreeNodeAllocator	access:public	signature:()
~OcTreeNodeDynamicAllocator	octree.h	/^    virtual ~OcTreeNodeDynamicAllocator() {$/;"	f	class:spatialaggregate::OcTreeNodeDynamicAllocator	access:public	signature:()
~OcTreeNodeFixedCountAllocator	octree.h	/^    virtual ~OcTreeNodeFixedCountAllocator() {$/;"	f	class:spatialaggregate::OcTreeNodeFixedCountAllocator	access:public	signature:()
~tree	tree.hh	/^		~tree();$/;"	p	class:tree	access:public	signature:()
~tree	tree.hh	/^tree<T, tree_node_allocator>::~tree()$/;"	f	class:tree	signature:()
